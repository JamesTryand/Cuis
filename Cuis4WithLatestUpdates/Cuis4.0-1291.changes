'From Cuis 4.0 of 21 April 2012 [latest update: #1260] on 21 April 2012 at 12:41:42 pm'!


	Smalltalk condenseSources!

Clipboard default: Clipboard new!

Transcript clear!

Clipboard default: Clipboard new!

Smalltalk flushClassNameCache.!

DebuggerMethodMap voidMapCache.!

Smalltalk garbageCollect.!

Smalltalk garbageCollect.!

Smalltalk garbageCollect.!

----SNAPSHOT----#(21 April 2012 12:42:58 pm) Cuis4.0.image priorSource: 0!

----QUIT----#(21 April 2012 12:43:04 pm) Cuis4.0.image priorSource: 358!

----STARTUP----#(11 May 2012 3:20:35 pm) as I:\Cuis\Cuis4.0.image!


'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 2:34:25 pm'!
!DropEvent methodsFor: 'accessing' stamp: 'jmv 12/11/2011 23:10'!
    eventPosition
	^position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:42'!
       morphPosition
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"
	^ bounds topLeft! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:43'!
          morphPosition: aPoint
	"Change the position of this morph and and all of its submorphs."

	"Detesto el falso polimorfismo con streams. Ponerle otro nombre a esto!!
	Igual, todavia esta #position, el getter, que es igual de feo..."
	
	"
	VER SENDERS. Acomodar. el argumento es en coord del owner o del world?
	Convertir los senders a senders de #zzpositionInOwner: o #zzpositionInWorld
	Espero que pocos hablen en coordenadas del world!!
	"

	| delta |
	delta _ aPoint - bounds topLeft.
	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.
	self privateFullMoveBy: delta.

	"En realidad, quiero coordenadas relativas al owner!!"
"	position _ aPoint."

	self redrawNeeded
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!HaloMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:43'!
                        morphPosition: pos
	"Halos display imprefectly if their coordinates are non-integral
		-- especially the direction handles."

	^ super morphPosition: pos asIntegerPoint! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:44'!
                morphPosition: aPoint
	"Prevent moving a world (e.g. via HandMorph>>specialGesture:)"

	"for now, let's allow it and see what happens"

	self isWorldMorph ifFalse: [ ^super morphPosition: aPoint ].
	super morphPosition: aPoint.
	self viewBox ifNotNil: [ self viewBox: (aPoint extent: self viewBox extent) ]! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:44'!
      morphPosition: newPos
	super morphPosition: newPos.
	isCollapsed
		ifTrue: [ collapsedFrame _ bounds ]
		ifFalse: [ fullFrame _ bounds ]! !
!UserInputEvent methodsFor: 'accessing' stamp: 'jmv 12/11/2011 23:10'!
             eventPosition
	^position! !
!MouseEvent methodsFor: 'accessing' stamp: 'jmv 12/11/2011 23:12'!
 eventPosition
	"Answer the location of the cursor's hotspot when this event occured."
	^ position! !
!AbstractSound methodsFor: 'file i/o' stamp: 'jmv 12/12/2011 10:43' prior: 16779362!
      storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream
	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files). If self isStereo is true, both channels are stored, creating a stereo file. Otherwise, only the left channel is stored, creating a mono file."

	| bufSize stereoBuffer reverseBytes  |
	self reset.
	bufSize _ (2 * self samplingRate rounded) min: samplesToStore.  "two second buffer"
	stereoBuffer _ SoundBuffer newStereoSampleCount: bufSize.
	reverseBytes _ bigEndianFlag ~= Smalltalk isBigEndian.

	'Storing audio...' displayProgressAt: World activeHand morphPosition
		from: 0 to: samplesToStore during: [:bar | | remaining out |
			remaining _ samplesToStore.
			[remaining > 0] whileTrue: [
				bar value: samplesToStore - remaining.
				stereoBuffer primFill: 0.  "clear the buffer"
				self playSampleCount: (bufSize min: remaining) into: stereoBuffer startingAt: 1.
				self isStereo
					ifTrue: [out _ stereoBuffer]
					ifFalse: [out _ stereoBuffer extractLeftChannel].
				reverseBytes ifTrue: [out reverseEndianness].
				(aBinaryStream isKindOf: StandardFileStream)
					ifTrue: [  "optimization for files: write sound buffer directly to file"
						aBinaryStream next: (out size // 2) putAll: out startingAt: 1]  "size in words"
					ifFalse: [  "for non-file streams:"
						1 to: out monoSampleCount do: [:i | aBinaryStream int16: (out at: i)]].
				remaining _ remaining - bufSize]].
! !
!AutoCompleter methodsFor: 'menu morph' stamp: 'jmv 12/12/2011 10:43' prior: 16783264!
                   openCompletionMenu
	| theEditor |
	theEditor _ textMorph editor.
	position _ theEditor startIndex - 1.
	self closeMenu.
	self computeEntries.
	entries notEmpty
		ifTrue: [ 
			menuMorph _  AutoCompleterMorph 
				completer: self
				position: theEditor startBlock bottomLeft + textMorph morphPosition ]! !
!CodePackage methodsFor: 'testing' stamp: 'jmv 4/10/2012 14:22' prior: 16812459!
                             changeRecordForOverriddenMethod: aMethodReference
	| sourceFilesCopy method position |
	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.
	position := method filePosition.
	sourceFilesCopy := SourceFiles collect:
		[:x | x isNil ifTrue: [ nil ]
				ifFalse: [x readOnlyCopy]].
	[ | file prevPos prevFileIndex chunk stamp methodCategory tokens |
	method fileIndex = 0 ifTrue: [^ nil].
	file := sourceFilesCopy at: method fileIndex.
	[position notNil & file notNil] whileTrue: [
		file position: (0 max: position-150).  "Skip back to before the preamble"
		[file position < (position-1)]  "then pick it up from the front"
			whileTrue: [ chunk _ file nextChunk ].

		"Preamble is likely a linked method preamble, if we're in
			a changes file (not the sources file).  Try to parse it
			for prior source position and file index"
		prevPos := nil.
		stamp := ''.
		(chunk findString: 'methodsFor:' startingAt: 1) > 0
			ifTrue: [tokens := Scanner new scanTokens: chunk]
			ifFalse: [tokens := #()  "ie cant be back ref"].
		((tokens size between: 7 and: 8)
			and: [(tokens at: tokens size-5) = #methodsFor:])
			ifTrue:
				[(tokens at: tokens size-3) = #stamp:
				ifTrue: ["New format gives change stamp and unified prior pointer"
						stamp := tokens at: tokens size-2.
						prevPos := tokens last.
						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.
						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]
				ifFalse: ["Old format gives no stamp; prior pointer in two parts"
						prevPos := tokens at: tokens size-2.
						prevFileIndex := tokens last].
				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].
		((tokens size between: 5 and: 6)
			and: [(tokens at: tokens size-3) = #methodsFor:])
			ifTrue:
				[(tokens at: tokens size-1) = #stamp:
				ifTrue: ["New format gives change stamp and unified prior pointer"
						stamp := tokens at: tokens size]].
		methodCategory := (tokens after: #methodsFor:) ifNil: ['as yet unclassifed'].
		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:
			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].
			^ ChangeRecord new file: file position: position type: #method
						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].
		position := prevPos.
		prevPos notNil ifTrue: [
			file _ sourceFilesCopy at: prevFileIndex]].
		^ nil]
			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]
	! !
!DropEvent methodsFor: 'printing' stamp: 'jmv 12/11/2011 23:32' prior: 16841192!
                          printOn: aStream

	aStream nextPut: $[.
	aStream nextPutAll: self eventPosition printString; space.
	aStream nextPutAll: self type.
	aStream nextPut: $].! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/12/2011 10:49' prior: 16896791!
             aboutToBeGrabbedBy: aHand
	"The receiver is being grabbed by a hand.
	Perform necessary adjustments (if any) and return the actual morph
	that should be added to the hand."
	self formerOwner: owner.
	self formerPosition: self morphPosition.
	^self "Grab me"! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/12/2011 10:52' prior: 16896972!
     slideBackToFormerSituation: evt 
	| slideForm formerOwner formerPosition aWorld startPoint endPoint |
	formerOwner _ self formerOwner.
	formerPosition _ self formerPosition.
	aWorld _ evt hand world.
	slideForm _ self imageForm offset: 0 @ 0.
	startPoint _ evt hand fullBounds origin.
	endPoint _ formerPosition.
	owner removeMorph: self.
	aWorld displayWorld.
	slideForm 
		slideFrom: startPoint
		to: endPoint
		nSteps: 12
		delay: 15.
	formerOwner addMorph: self.
	self morphPosition: formerPosition.
	self justDroppedInto: formerOwner event: evt! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 12/11/2011 23:28' prior: 16897556!
 handleMouseOver: anEvent
	"System level event handling."
	anEvent hand mouseFocus == self ifTrue:[
		"Got this directly through #handleFocusEvent: so check explicitly"
		(self containsPoint: anEvent eventPosition event: anEvent) ifFalse:[^self]].
	anEvent hand noticeMouseOver: self event: anEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 12/11/2011 23:29' prior: 16897704!
                             rejectDropEvent: anEvent
	"This hook allows the receiver to repel a drop operation currently executed. The method is called prior to checking children so the receiver must validate that the event was really designated for it.
	Note that the ordering of the tests below is designed to avoid a (possibly expensive) #fullContainsPoint: test. If the receiver doesn't want to repel the morph anyways we don't need to check after all."
	(self repelsMorph: anEvent contents event: anEvent) ifFalse:[^self]. "not repelled"
	(self fullContainsPoint: anEvent eventPosition) ifFalse:[^self]. "not for me"
	"Throw it away"
	anEvent wasHandled: true.
	anEvent contents rejectDropMorphEvent: anEvent.! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:49' prior: 16897802!
 align: aPoint1 with: aPoint2
	"Translate by aPoint2 - aPoint1."

	^ self morphPosition: self morphPosition + (aPoint2 - aPoint1)! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:52' prior: 16897828!
               bounds: newBounds
	| oldExtent newExtent |
	oldExtent _ bounds extent.
	newExtent _ newBounds extent.
	"Moving stuff around is most likely the most common operation.
	Optimize it"
	oldExtent = newExtent ifTrue: [
		^self morphPosition: newBounds topLeft ].
	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[
		"We're growing. First move then resize."
		self morphPosition: newBounds topLeft; extent: newExtent.
	] ifFalse: [
		"We're shrinking. First resize then move."
		self extent: newExtent; morphPosition: newBounds topLeft.
	].! !
!Morph methodsFor: 'geometry eToy' stamp: 'jmv 12/12/2011 10:52' prior: 16897925!
                       referencePosition: aPoint
	"a rather ugly way to say #center: . Just for consistency with #referencePosition"
	self morphPosition: aPoint - (bounds extent // 2)! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 12/12/2011 10:49' prior: 16898093!
 editBalloonHelpContent: aString
	| reply |
	reply _ FillInTheBlank
		multiLineRequest: 'Edit the balloon help text for ' , (self printStringLimitedTo: 40)
		centerAt: self world activeHand morphPosition
		initialAnswer: (aString ifNil: [self noHelpString] ifNotNil: [aString])
		answerHeight: 200.
	reply ifNil: [^ self].  "User cancelled out of the dialog"
	(reply isEmpty or: [reply asString = self noHelpString])
		ifTrue: [self setBalloonText: nil]
		ifFalse: [self setBalloonText: reply]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 12/11/2011 23:29' prior: 16898232!
                     transferHalo: event from: formerHaloOwner
	"Progressively transfer the halo to the next likely recipient"
	| w |

	"Never transfer halo to top-most world"
	(self isWorldMorph and:[owner isNil]) ifFalse: [
		(self wantsHaloFromClick and:[formerHaloOwner ~~ self]) 
			ifTrue:[^self addHalo: event from: formerHaloOwner]].

	event shiftPressed ifTrue: [
		"Pass it outwards"
		owner ifNotNil:[^owner transferHalo: event from: formerHaloOwner].
		"We're at the top level; throw the event back in to find recipient"
		formerHaloOwner removeHalo.
		^self processEvent: event copy resetHandlerFields.
	].
	self submorphsDo: [ :m |
		(m fullContainsPoint: event eventPosition) 
			ifTrue:[^m transferHalo: event from: formerHaloOwner].
	].
	"We're at the bottom most level; throw the event back up to the root to find recipient"
	formerHaloOwner removeHalo.
	(w _ self world) ifNil: [ ^self ].
	^w processEvent: event copy resetHandlerFields.
! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 10:49' prior: 16898352!
 openInWorld: aWorld
	"Add this morph to the requested World."
	(aWorld viewBox origin ~= (0@0) and: [self morphPosition = (0@0)]) ifTrue: [
		self morphPosition: aWorld viewBox origin].
	aWorld addMorph: self.
	aWorld startSteppingSubmorphsOf: self! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 12/12/2011 10:49' prior: 16898838!
                   changeColorTarget: anObject selector: aSymbol originalColor: aColor hand: aHand
	"Put up a color picker for changing some kind of color.  May be modal or modeless, depending on #modalColorPickers setting"
	self flag: #arNote. "Simplify this due to anObject == self for almost all cases"
	^ ColorPickerMorph new
		choseModalityFromPreference;
		sourceHand: aHand;
		target: anObject;
		selector: aSymbol;
		originalColor: aColor;
		putUpFor: anObject near: ((anObject is: #Morph)
					ifTrue: [ Rectangle center: self morphPosition extent: 20 ]
					ifFalse: [ anObject == self world
								ifTrue: [ anObject viewBox bottomLeft + (20@-20) extent: 200 ]
								ifFalse: [ anObject fullBounds ]]);
		yourself! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/12/2011 10:51' prior: 16899455!
                               addMorphFront: aMorph fromWorldPosition: aPoint

	self addMorphFront: aMorph.
	aMorph morphPosition: aPoint! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/12/2011 10:49' prior: 16899461!
                        addMorphFrontFromWorldPosition: aMorph
	^self addMorphFront: aMorph fromWorldPosition: aMorph morphPosition.! !
!Morph methodsFor: 'testing' stamp: 'jmv 12/11/2011 23:36' prior: 16899658!
    shouldDropOnMouseUp
	| former |
	"
	former _ self formerPosition ifNil:[^false].
	^(former dist: self zzposition) > 10
	"^true! !
!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 10:51' prior: 16783581!
                              setCompleter: anAutoCompleter position: aPoint 
	completer _ anAutoCompleter.
	self morphPosition: aPoint.
	self resetMenu.
	self openInWorld! !
!AutoCompleterMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:13' prior: 16783707!
               mouseUp: evt
	(self containsPoint: evt eventPosition)
		ifTrue: [
			self selected: 
				((evt eventPosition y - bounds top // self class itemHeight) + 
					self firstVisible).
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !
!FillInTheBlankMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:14' prior: 16852801!
                           mouseDown: evt
	(self containsPoint: evt eventPosition) ifFalse:[^ Beeper beep]. "sent in response to outside modal click"
	evt hand grabMorph: self. "allow repositioning"! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 10:45' prior: 16852995!
       request: queryString
	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph request: 'What is your favorite color?'"

	^ self
		request: queryString
		initialAnswer: ''
		centerAt: World activeHand morphPosition! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 10:45' prior: 16853010!
              request: queryString initialAnswer: defaultAnswer 
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph
		request: 'What is your favorite color?'
		initialAnswer: 'red, no blue. Ahhh!!'"

	^ self
		request: queryString
		initialAnswer: defaultAnswer
		centerAt: World activeHand morphPosition! !
!HaloMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/12/2011 10:45' prior: 16863637!
        startDrag: evt with: dragHandle
	"Drag my target without removing it from its owner."

	self obtainHaloForEvent: evt andRemoveAllHandlesBut: dragHandle.
	positionOffset _ dragHandle referencePosition - target morphPosition! !
!HaloMorph methodsFor: 'event handling' stamp: 'jmv 12/12/2011 10:51' prior: 16863647!
       mouseMove: evt
	"Drag our target around"
	| thePoint |
	thePoint _ evt eventPosition - positionOffset.
	target morphPosition: thePoint! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 12/12/2011 10:45' prior: 16863654!
       popUpFor: aMorph event: evt
	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."

	| hand anEvent |
	self flag: #workAround.	"We should really have some event/hand here..."
	anEvent _ evt
				ifNil: [
					hand _ aMorph world activeHand.
					hand ifNil: [ hand _ aMorph world firstHand ]. 
					hand lastEvent ]
				ifNotNil: [
					hand _ evt hand.
					evt ].
	self target: aMorph.
	hand halo: self.
	hand world addMorphFront: self.
	positionOffset _ anEvent eventPosition - aMorph morphPosition.
	self startStepping! !
!HaloMorph methodsFor: 'events-processing' stamp: 'jmv 12/11/2011 23:27' prior: 16863687!
            containsPoint: aPoint event: anEvent
	"mouseButton3 events are handled by the halo"
	(anEvent isMouse and: [ anEvent isMouseDown and: [ anEvent mouseButton3Pressed ]])
		ifFalse:  [^super containsPoint: aPoint event: anEvent ].
	^self fullBounds containsPoint: anEvent eventPosition! !
!HaloMorph methodsFor: 'meta-actions' stamp: 'jmv 12/12/2011 10:45' prior: 16863915!
             mouseButton3Down: event
	"Transfer the halo to the next likely recipient"
	target ifNil:[^self delete].
	event hand obtainHalo: self.
	positionOffset _ event eventPosition - target morphPosition.
	"wait for drags or transfer"
	event hand 
		waitForClicksOrDrag: self 
		event: event
		clkSel: #transferHalo:
		dblClkSel: nil! !
!HaloMorph methodsFor: 'stepping' stamp: 'jmv 12/12/2011 10:51' prior: 16863927!
       step
	| newBounds |
	target
		ifNil: [^ self].
	newBounds _ target isWorldMorph
				ifTrue: [target bounds]
				ifFalse: [target worldBoundsForHalo truncated].
	newBounds = bounds
		ifTrue: [^ self].
	newBounds extent = bounds extent
		ifTrue: [^ self morphPosition: newBounds origin].
	growingOrRotating
		ifFalse: [submorphs size > 1
				ifTrue: [self addHandles]].
	"adjust halo bounds if appropriate"
	self bounds: newBounds! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/30/2011 23:40' prior: 16863963!
addHandle: handleSpec on: eventName send: selector to: recipient 
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint iconName colorToUse aMorph |
	aPoint := self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	handle := HaloHandleMorph new.
	self addMorph: handle.
	handle 
		bounds: (Rectangle center: aPoint extent: HandleSize asPoint);
		color: (colorToUse := Color colorFrom: handleSpec color).
	(iconName := handleSpec iconSymbol) ifNotNil: [
			| form |
			form := Icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				aMorph _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				aMorph morphPosition: aPoint - (form extent // 2).
				handle addMorphFront: aMorph.
				]].
	handle 
		on: #mouseUp
		send: #endInteraction
		to: self.
	handle 
		on: eventName
		send: selector
		to: recipient.
	handle 
		setBalloonText: (target balloonHelpTextForHandle: handle).
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16864040!
                    addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w |
	w := self world ifNil: [target world].
	nameMorph := StringMorph contents: aString.
	nameMorph color: Color magenta.
	namePosition := outerRectangle bottomCenter 
				- ((nameMorph width // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph 
		morphPosition: (namePosition min: w viewBox bottomRight - nameMorph extent y + 5).
	self addMorph: (RectangleMorph new
		bounds: (nameMorph bounds outsetBy: 2);
		borderWidth: 0;
		color: (Color lightBlue alpha: 0.9)).
	self addMorph: nameMorph.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16864096!
        doDrag: evt with: dragHandle
	| thePoint |
	evt hand obtainHalo: self.
	thePoint _ evt eventPosition - positionOffset.
	target morphPosition: thePoint! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16864126!
                      doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target bounds topLeft.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target extent: newExtent.
	growHandle morphPosition: evt eventPosition - (growHandle extent // 2).
	self someSubmorphPositionOrExtentChanged
! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:15' prior: 16864158!
                       doRecolor: evt with: aHandle
	"The mouse went down in the 'recolor' halo handle.  Allow the user to change the color of the innerTarget"

	evt hand obtainHalo: self.
	(aHandle containsPoint: evt eventPosition)
		ifFalse: [  "only do it if mouse still in handle on mouse up"
			self delete.
			target addHalo: evt]
		ifTrue: [
			innerTarget changeColor]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16864171!
           doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Color lightBlue]
		ifFalse: [rotHandle color: Color blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPosition: evt eventPosition - (rotHandle extent // 2).
	self someSubmorphPositionOrExtentChanged! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:15' prior: 16864211!
                    maybeCollapse: evt with: collapseHandle 
	"Ask hand to collapse my target if mouse comes up in it."

	evt hand obtainHalo: self.
	self delete.
	(collapseHandle containsPoint: evt eventPosition) 
		ifFalse: [
			target addHalo: evt ]
		ifTrue: [
			target collapse ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:16' prior: 16864222!
   maybeDismiss: evt with: dismissHandle
	"Ask hand to dismiss my target if mouse comes up in it."

	evt hand obtainHalo: self.
	(dismissHandle containsPoint: evt eventPosition)
		ifFalse: [
			self delete.
			target addHalo: evt]
		ifTrue: [
			target resistsRemoval ifTrue: [
				(PopUpMenu
					confirm: 'Really throw this away'
					trueChoice: 'Yes'
					falseChoice: 'Um, no, let me reconsider') ifFalse: [^ self]].

			self delete.
			target dismissViaHalo]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:16' prior: 16864285!
                               setDismissColor: evt with: dismissHandle
	"Called on mouseStillDown in the dismiss handle; set the color appropriately."

	| colorToUse |
	evt hand obtainHalo: self.
	colorToUse _  (dismissHandle containsPoint: evt eventPosition)
		ifFalse: [ Color red muchLighter ]
		ifTrue: [ Color lightGray ].
	dismissHandle color: colorToUse! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:16' prior: 16864298!
  startGrow: evt with: growHandle
	"Initialize resizing of my target.  Launch a command representing it, to support Undo"

	| botRt |
	self obtainHaloForEvent: evt andRemoveAllHandlesBut: growHandle.
	botRt _ target bounds bottomRight.
	positionOffset _ (self world viewBox containsPoint: botRt)
		ifTrue: [evt eventPosition - botRt]
		ifFalse: [0@0]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:16' prior: 16864311!
                startRot: evt with: rotHandle
	"Initialize rotation of my target if it is rotatable.  Launch a command object to represent the action"

	self obtainHaloForEvent: evt andRemoveAllHandlesBut: rotHandle.
	growingOrRotating _ true.

	self removeAllHandlesBut: rotHandle.  "remove all other handles"
	angleOffset _ evt eventPosition - target referencePosition.
	angleOffset _ Point
			r: angleOffset r
			degrees: angleOffset degrees - target rotationDegrees

! !
!HandMorph methodsFor: 'cursor' stamp: 'jmv 12/12/2011 10:46' prior: 16864626!
      cursorBounds

	^self morphPosition extent: CursorWithMask normal extent! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 12/12/2011 10:46' prior: 16865010!
                           handleEvent: anEvent
	| evt |
	owner ifNil: [ ^ self ].
	evt _ anEvent.
	evt isMouseOver ifTrue: [ ^ self sendMouseEvent: evt ].

	"Notify listeners"
	self sendListenEvent: evt to: self eventListeners.
	
	evt isWindowEvent ifTrue: [
		self sendEvent: evt.
		^ self mouseOverHandler processMouseOver: lastMouseEvent ].

	evt isKeyboard ifTrue: [
		self sendListenEvent: evt to: self keyboardListeners.
		self sendKeyboardEvent: evt.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	evt isDropEvent ifTrue: [
		self sendEvent: evt.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	evt isMouse ifTrue: [
		self sendListenEvent: evt to: self mouseListeners.
		lastMouseEvent _ evt.	
		lastMouseEventTime _ Time millisecondClockValue].

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: evt from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			^self mouseOverHandler processMouseOver: lastMouseEvent  ]].

	evt isMove ifTrue: [
		self morphPosition: evt eventPosition.
		self sendMouseEvent: evt.
	] ifFalse: [
		"Issue a synthetic move event if we're not at the position of the event"
		evt eventPosition = self morphPosition ifFalse: [ self moveToEvent: evt ].
		"Drop submorphs on button events"
		self hasSubmorphs
			ifTrue: [ self dropMorphs: evt ]
			ifFalse: [ self sendMouseEvent: evt ].
	].
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 12/12/2011 10:46' prior: 16865120!
           newMouseFocus: aMorph event: event 
	aMorph ifNotNil: [ 
		targetOffset _ event eventPosition - aMorph morphPosition].
	^self newMouseFocus: aMorph! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/12/2011 10:46' prior: 16865187!
               attachMorph: m
	"Position the center of the given morph under this hand, then grab it.
	This method is used to grab far away or newly created morphs."
	| delta |
	self releaseMouseFocus. "Break focus"
	delta _ m bounds extent // 2.
	m morphPosition: (self morphPosition - delta).
	m formerPosition: m morphPosition.
	targetOffset _ m morphPosition - self morphPosition.
	self addMorphBack: m.! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/12/2011 10:46' prior: 16865201!
                          dropMorph: aMorph event: anEvent
	"Drop the given morph which was carried by the hand"
	| event |
	(anEvent isMouseUp and:[aMorph shouldDropOnMouseUp not]) ifTrue:[^self].

	"Note: For robustness in drag and drop handling we remove the morph BEFORE we drop him, but we keep his owner set to the hand. This prevents system lockups when there is a problem in drop handling (for example if there's an error in #wantsToBeDroppedInto:). THIS TECHNIQUE IS NOT RECOMMENDED FOR CASUAL USE."
	self privateRemove: aMorph.
	aMorph privateOwner: self.

	event _ DropEvent new setPosition: self morphPosition contents: aMorph hand: self.
	self sendEvent: event.
	event wasHandled ifFalse:[aMorph rejectDropMorphEvent: event].
	aMorph owner == self ifTrue:[aMorph delete].
	self mouseOverHandler processMouseOver: anEvent.! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/12/2011 10:46' prior: 16865237!
                          grabMorph: aMorph from: formerOwner
	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."

	self releaseMouseFocus. "Break focus"
	"And compute distance from hand's position"
	targetOffset _ aMorph morphPosition - self morphPosition.
	self addMorphBack: aMorph.
	aMorph justGrabbedFrom: formerOwner.! !
!HandMorph methodsFor: 'paste buffer' stamp: 'jmv 12/12/2011 10:47' prior: 16865483!
  pasteMorph

	| pastee |
	pastee _ Clipboard retrieveMorph.
	pastee ifNil: [^ self inform: 'Nothing to paste.'].
	self attachMorph: pastee.
	pastee align: pastee referencePosition with: self morphPosition
! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 12/12/2011 10:46' prior: 16865496!
                         generateKeyboardEvent: evtBuf 
	"Generate the appropriate mouse event for the given raw event buffer"

	| buttons modifiers type keyValue pressType stamp |
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [stamp _ Time millisecondClockValue].
	(evtBuf sixth <= 0 or: [
		(keyValue _ (Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth)) isNil ])
			ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].
	modifiers _ evtBuf fifth.
	pressType _ evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type _ #keyDown.
		lastKeyDownValue _ keyValue].
	pressType = EventSensor eventKeyUp ifTrue: [type _ #keyUp].
	pressType = EventSensor eventKeyChar ifTrue: [
		type _ #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [		"Control key pressed"
			keyValue < 27 ifTrue: [
				
				"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [		"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ 	"If Equal, Ctrl-alphabetic in Windows => do translate"
							lastKeyDownValue < 47 ]) ifTrue: [		"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue _ (modifiers anyMask: 1)
							ifFalse: [ keyValue + 96 ]	"shift not pressed: conver to lowercase letter"
							ifTrue: [ keyValue + 64 ]].	"shift pressed: conver to uppercase letter"
					]
				].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [
				modifiers _ modifiers bitOr: 8 ]
			]].
	buttons _ modifiers bitShift: 3.
	^KeyboardEvent new 
		setType: type
		buttons: buttons
		position: self morphPosition
		keyValue: keyValue
		hand: self
		stamp: stamp! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 12/12/2011 10:46' prior: 16865642!
             moveToEvent: anEvent
	"Issue a mouse move event to make the receiver appear at the given position"
	self handleEvent: (MouseMoveEvent new
		setType: #mouseMove 
		startPoint: self morphPosition 
		endPoint: anEvent eventPosition 
		trail: (Array with: self morphPosition with: anEvent eventPosition)
		buttons: anEvent buttons
		hand: self
		stamp: anEvent timeStamp)! !
!HandleMorph methodsFor: 'event handling' stamp: 'jmv 4/10/2012 14:29' prior: 16865778!
                     keyStroke: evt
	"Check for cursor keys"
	| keyValue |
	(owner is: #HandMorph) ifFalse: [ ^self ].
	keyValue _ evt keyValue.
	keyValue = 28 ifTrue: [ ^self morphPosition: self morphPosition - (1@0) ].
	keyValue = 29 ifTrue: [ ^self morphPosition: self morphPosition + (1@0) ].
	keyValue = 30 ifTrue: [ ^self morphPosition: self morphPosition - (0@1) ].
	keyValue = 31 ifTrue: [ ^self morphPosition: self morphPosition + (0@1) ].
	"Special case for return"
	evt isReturnKey ifTrue:[
		"Drop the receiver and be done"
	self flag: #arNote. "Probably unnecessary"
		owner releaseKeyboardFocus: self.
		self delete ]! !
!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 10:47' prior: 16867371!
                              popUpForHand: aHand
	"Pop up the receiver as balloon help for the given hand"

	| xcess |
	(contents isNil or: [ contents isEmpty ]) ifTrue: [ ^self ].
	self morphPosition: aHand morphPosition + (-6@20).
	xcess _ bounds right - aHand world bounds right.
	xcess > 0 ifTrue: [
		self morphPosition: self morphPosition - (xcess@0) ].
	aHand world addMorphFront: self.
	aHand balloonHelp: self! !
!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 12/11/2011 23:17' prior: 16870032!
  enterClickableRegion: evt
	| index isLink |
	evt hand hasSubmorphs ifTrue: [ ^self ].
	paragraph ifNotNil:[
		index _ (paragraph characterBlockAtPoint: evt eventPosition) stringIndex.
		isLink _ (model actualContents attributesAt: index) 
					anySatisfy: [ :attr | attr mayActOnClick ].
		isLink ifTrue: [ Cursor webLink show ] ifFalse: [ Cursor normal show ]]! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:17' prior: 16870178!
                       mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].
	self handleInteraction: [ editor mouseMove: (evt translatedBy: bounds topLeft negated)].
	(evt eventPosition y between: owner bounds top and: owner bounds bottom) ifFalse: [
		WorldState addDeferredUIMessage: [
			owner scrollSelectionIntoView: evt ]
	]! !
!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 10:47' prior: 16879765!
            handPoint
	^ hand morphPosition adhereTo: owner bounds! !
!LayoutAdjustingMorph methodsFor: 'stepping' stamp: 'jmv 12/12/2011 10:47' prior: 16879781!
          step
	"got the #mouseLeave: message"
	| p |
	hand ifNil: [
		indicator ifNotNil: [
			indicator delete.
			indicator _ nil ].
		Cursor currentCursor == self cursor ifTrue: [
			Cursor normal show ].
		^self stopStepping ].

	"hasn't got the #mouseLeave: message (yet)"
	p _ self handPoint.
	hand lastEvent mouseButton1Pressed
		ifTrue: [
			indicator
				ifNil: [ self adjustOwnerAt: p ]
				ifNotNil: [ self adjustIndicatorAt: p ]]
		ifFalse: [
			indicator ifNotNil: [
				indicator delete.
				indicator _ nil.
				self adjustOwnerAt: p ].
			"If the button was unpressed outside the morph (can happen if you try to go outside container),
			we might not get the #mouseLeave: message"
			(self containsPoint: hand morphPosition) ifFalse: [
				hand _ nil.
				Cursor normal show.
				self stopStepping ]]! !
!LayoutAdjustingMorph methodsFor: 'adjusting' stamp: 'jmv 12/12/2011 10:47' prior: 16879814!
                        adjustIndicatorAt: aPoint
	owner direction = #vertical
		ifTrue: [
			indicator morphPosition: indicator morphPosition x @ (aPoint y-(indicator height//2)) ]
		ifFalse: [
			indicator morphPosition: (aPoint x-(indicator width//2)) @ indicator morphPosition y ]! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 12/12/2011 10:48' prior: 16885163!
      chooseMagnification: evt
	| handle origin aHand currentMag |
	currentMag _ magnification.
	aHand _ evt ifNil: [ self world activeHand ] ifNotNil: [evt hand].
	origin _ aHand morphPosition y.
	handle _ HandleMorph new forEachPointDo:
		[ :newPoint | self magnification: (newPoint y - origin) / 8.0 + currentMag ].
	aHand attachMorph: handle.
	handle startStepping.
	self redrawNeeded. ! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 12/12/2011 10:48' prior: 16885245!
    sourcePoint
	"If we are being dragged use our center, otherwise use pointer position"
	^ (trackPointer not or: [owner notNil and: [owner is: #HandMorph]])
		ifTrue: [ bounds center ]
		ifFalse: [ self activeHand morphPosition ]! !
!MagnifierMorph methodsFor: 'round view' stamp: 'jmv 12/11/2011 23:35' prior: 16885274!
 toggleRoundness
	| |
"	w _ self world.
	self isRound
		ifTrue: [owner delete.
				w addMorph: self]
		ifFalse: [sm _ ScreeningMorph new position: self zzposition.
				sm addMorph: self.
				sm addMorph: (EllipseMorph newBounds: self bounds).
				w addMorph: sm]
			"! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 10:51' prior: 16886778!
                            contents: aString withMarkers: aBool inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	self contentString: nil.	"get rid of old"
	aBool ifFalse: [^super contents: aString].
	self removeAllMorphs.	"get rid of old markers if updating"
	self hasIcon ifTrue: [ self icon: nil ].
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	self contentString: aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	marker morphPosition: bounds left @ (bounds top + 2).
	self addMorphFront: marker! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:17' prior: 16886907!
                      activateOwnerMenu: evt
	"Activate our owner menu; e.g., pass control to it"
	owner ifNil:[^false]. "not applicable"
	(owner fullContainsPoint: evt eventPosition) ifFalse:[^false].
	owner activate: evt.
	^true! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:17' prior: 16886916!
                         activateSubmenu: evt
	"Activate our submenu; e.g., pass control to it"
	subMenu ifNil:[^false]. "not applicable"
	(subMenu fullContainsPoint: evt eventPosition) ifFalse:[^false].
	subMenu activate: evt.
	self removeAlarm: #deselectTimeOut:.
	^true! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 4/10/2012 14:30' prior: 16887473!
                 addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s p w |
	
	titleMorph _ RectangleMorph new.
	self setTitleParametersFor: titleMorph.
	p _ titleMorph morphPosition + (8@2).
	aString asString linesDo: [ :line | 
		s _ StringMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		s morphPosition: p.
		titleMorph addMorphBack: s.
		p _ p + (0@(s height+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each width ].
	titleMorph height: p y; width: w + 8.
	self addMorphFront: titleMorph.
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/12/2011 10:49' prior: 16887634!
 popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem
	"Present this menu at the given point under control of the given hand."

	| delta tryToPlace selectedOffset |

	hand world startSteppingSubmorphsOf: self.
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil:[self items first]) morphPosition - self morphPosition.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self fullBounds amountToTranslateWithin: sourceItem world bounds.
		(delta x = 0 or: [ mustFit ]) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			sourceItem owner owner addMorphFront: self.
			^ self]].
	tryToPlace 
		value: rightOrLeftPoint first value: false;
		value: rightOrLeftPoint last  - (self width @ 0) value: false;
		value: rightOrLeftPoint first value: true

	! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/12/2011 10:49' prior: 16887698!
                            popUpForHand: hand in: aWorld
	| p |
	"Present this menu under control of the given hand."

	p _ hand morphPosition truncated.
	^self popUpAt: p forHand: hand in: aWorld
! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/12/2011 10:49' prior: 16887712!
  popUpInWorld: aWorld
	"Present this menu under control of the given hand."
	^self
		popUpAt: aWorld activeHand morphPosition
		forHand: aWorld activeHand
		in: aWorld
! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:17' prior: 16887796!
      mouseDown: evt
	"Handle a mouse down event."
	(stayUp or:[self fullContainsPoint: evt eventPosition]) 
		ifFalse:[^self deleteIfPopUp: evt]. "click outside"
	self isSticky ifTrue: [^self].
	"Grab the menu and drag it to some other place"
	evt hand grabMorph: self.! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:17' prior: 16887807!
     mouseUp: evt
	"Handle a mouse up event.
	Note: This might be sent from a modal shell."
	(self fullContainsPoint: evt eventPosition) ifFalse:[
		"Mouse up outside. Release eventual focus and delete if pop up."
		evt hand releaseMouseFocus: self.
		^self deleteIfPopUp: evt].
	stayUp ifFalse:[
		"Still in pop-up transition; keep focus"
		evt hand newMouseFocus: self].! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 12/12/2011 10:48' prior: 16887856!
                    displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m isKindOf: MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Color veryDarkGray.
		feedbackMorph morphPosition: self morphPosition - (0@20).
		self
			 addLine;
			 addMorphBack: feedbackMorph lock.
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self submorphs last delete.
		self removeProperty: #feedbackMorph ].
	matches size = 1 ifTrue: [
		self
			selectItem: matches first
			event: evt ].! !
!MenuMorph methodsFor: 'menu' stamp: 'jmv 12/12/2011 10:51' prior: 16888036!
                        sightTarget: event 
	| bullseye menu newTarget |
	owner
		ifNil: [^ self ].
	bullseye _ Point fromUserWithCursor: Cursor target.
	ActiveHand morphPosition: bullseye.
	menu _ CustomMenu new.
	(owner morphsAt: bullseye) do: [ :m |
		menu add: m printString action: m ].
	menu title: self printString, ' targets... '.
	newTarget _ menu startUp.
	newTarget
		ifNil: [^ self].
	self target: newTarget! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 12/12/2011 10:48' prior: 16888084!
                           invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu"

	^ self invokeModalAt: ActiveHand morphPosition in: ActiveWorld allowKeyboard: allowKeyboardControl! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16888140!
             adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p tl |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: (
			(each respondsTo: #minItemWidth)
				ifTrue: [each minItemWidth]
				ifFalse: [each width])].

	w _ w + 4.
	tl _ bounds topLeft.
	p _ tl + 5.
	submorphs do: [ :m |
		m width: w.
		m morphPosition: p.
		p _ m bounds bottomLeft +(0@1) ].
	
	self extent: submorphs last bounds bottomRight - tl + 5! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:49' prior: 16888172!
     positionAt: aPoint relativeTo: aMenuItem inWorld: aWorld
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| i yOffset sub delta |
	self adjustSubmorphsLayout.
	i _ 0.
	yOffset _ 0.
	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]
		whileFalse: [ yOffset _ yOffset + sub height ].

	self morphPosition: aPoint - (2 @ (yOffset + 8)).

	"If it doesn't fit, show it to the left, not to the right of the hand."
	bounds right > aWorld world bounds right
		ifTrue: [
			self moveRight: aPoint x + 1].

	"Make sure that the menu fits in the world."
	delta _ bounds amountToTranslateWithin:
		(aWorld world bounds withHeight: ((aWorld world bounds height - 18) max: (ActiveHand morphPosition y) + 1)).
	delta = (0 @ 0) ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!MenuMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:51' prior: 16888218!
         moveRight: aNumber
	self morphPosition: ((aNumber - bounds width) @ bounds top)! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 12/12/2011 10:48' prior: 16884746!
                         informUserAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	| w titleString |

	titleString _ titleMorph submorphs first.
	self visible: false.
	w _ ActiveWorld.
	aBlock value: [ :string |
		self visible ifFalse: [
			w addMorph: self centeredNear: aPoint.
			self visible: true].
		titleString contents: string.
		titleMorph width: titleString width + 8.
		self morphPosition: w activeHand morphPosition.
		self adjustSubmorphsLayout.
		self redrawNeeded.
		w displayWorld		 "show myself"
	]. 
	self delete.
	w displayWorld! !
!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 12/11/2011 23:29' prior: 16900281!
                      dispatchDefault: anEvent with: aMorph
	"Dispatch the given event. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."
	| inside |
	"See if we're fully outside aMorphs bounds"
	(aMorph fullBounds containsPoint: anEvent eventPosition) ifFalse: [ ^#rejected ]. "outside"

	"Traverse children"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [
				"Not rejected. The event was in some submorph of the receiver"
				inside _ true
			]]].

	"Check for being inside the receiver"
	inside ifFalse: [ inside _ aMorph containsPoint: anEvent eventPosition event: anEvent ].
	inside ifTrue: [ ^aMorph handleEvent: anEvent ].
	^ #rejected! !
!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 12/11/2011 23:31' prior: 16900308!
                   dispatchDropEvent: anEvent with: aMorph
	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."
	| inside |

	"Try to get out quickly"
	(aMorph fullBounds containsPoint: anEvent eventPosition)
		ifFalse: [ ^#rejected ].

	"Give aMorph a chance to repel the dropping morph"
	aMorph rejectDropEvent: anEvent.
	anEvent wasHandled ifTrue:[^self].

	"Go looking if any of our submorphs wants it"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [
				inside _ true
			]]].

	inside ifFalse: [ inside _ aMorph containsPoint: anEvent eventPosition event: anEvent ].
	inside ifTrue: [ ^aMorph handleEvent: anEvent ].
	^#rejected! !
!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 12/11/2011 23:31' prior: 16900369!
      dispatchMouseDown: anEvent with: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
"
	| globalPt handler inside lastHandler |
	"Try to get out quickly"
	globalPt _ anEvent eventPosition.
	(aMorph fullBounds containsPoint: globalPt) ifFalse: [ ^#rejected ].

	"Install the prospective handler for the receiver"
	lastHandler _ anEvent handler. "in case the mouse wasn't even in the receiver"
	handler _ aMorph handlerForMouseDown: anEvent.
	handler ifNotNil: [ anEvent handler: handler ].

	"Now give our submorphs a chance to handle the event"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [
				"Some child did contain the point so we're part of the top-most chain."
				inside _ true.
			]]].

	(inside or: [ aMorph containsPoint: anEvent eventPosition event: anEvent ]) ifTrue:[
		"Receiver is in the top-most unlocked, visible chain."
		handler ifNotNil: [ handler handleEvent: anEvent ].
		"Note: Re-installing the handler is not really necessary but good style."
		anEvent handler: lastHandler.
		^self ].

	"Mouse was not on receiver nor any of its children"
	anEvent handler: lastHandler.
	^#rejected! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 12/12/2011 10:52' prior: 16900611!
                    placeEmbeddedObject: anchoredFormOrMorph

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	(anchoredFormOrMorph is: #Morph)
		ifTrue: [
			anchoredFormOrMorph morphPosition:
				((destX - anchoredFormOrMorph width)@
				(lineY+ line baseline - anchoredFormOrMorph height)) -
					paraTopLeft ]
		ifFalse: [
			destY _ lineY.
			runX _ destX.
			anchoredFormOrMorph 
				displayOn: canvas grafPort destForm 
				at: destX - anchoredFormOrMorph width @ (destY + line baseline - anchoredFormOrMorph height)
				clippingBox: canvas grafPort clipRect
				rule: Form blend
				fillColor: nil ].
	^ true! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 12/30/2011 23:41' prior: 16900948!
                            handleEvent: evt from: aHand
	"Process the given mouse event to detect a click, double-click, or drag.
	Return true if the event should be processed by the sender, false if it shouldn't.
	NOTE: This method heavily relies on getting *all* mouse button events."

	| timedOut distance |
	timedOut _ (evt timeStamp - lastClickDown timeStamp) > DoubleClickTimeout.
	distance _ (evt eventPosition - lastClickDown eventPosition) r.
	"Real action dispatch might be done after the triggering event, for example, because of waiting for timeout.
	So, count the button downs and ups(clicks), to be processed, maybe later, maybe in a mouseMove..."
	evt isMouseDown ifTrue: [
		lastClickDown _ evt.
		buttonDownCount _ buttonDownCount + 1 ].
	evt isMouseUp ifTrue: [
		buttonUpCount _ buttonUpCount + 1 ].

	"Simulate button 2 if timeout during first click (i.e. tap & hold). Useful for opening menus on pen computers."
	(buttonDownCount = 1 and: [ buttonUpCount = 0]) ifTrue: [
		(timedOut and: [ sendMouseButton2Activity and: [ distance = 0]]) ifTrue: [
			aHand dontWaitForMoreClicks.
			clickClient mouseButton2Activity.
			^ false ].
		"If we have already moved, then it won't be a double or triple click... why wait?"
		distance > 0 ifTrue: [
			aHand dontWaitForMoreClicks.
			self click.
			^ false ]].

	"If we're over triple click, or timed out, or mouse moved, don't allow more clicks."
	(buttonDownCount = 4 or: [ timedOut or: [ distance > 0 ]]) ifTrue: [
		aHand dontWaitForMoreClicks.
		^ false ].

	"Simple click."
	(buttonDownCount = 1 and: [ buttonUpCount = 1 ]) ifTrue: [
		self click ].

	"Click & hold"
	(buttonDownCount = 2 and: [ buttonUpCount = 1]) ifTrue: [
		self clickAndAHalf ].

	"Double click."
	(buttonDownCount = 2 and: [ buttonUpCount = 2]) ifTrue: [
		self doubleClick ].

	"Double click & hold."
	(buttonDownCount = 3 and: [ buttonUpCount = 2]) ifTrue: [
		self doubleClickAndHalf ].

	"Triple click"
	(buttonDownCount = 3 and: [ buttonUpCount = 3]) ifTrue: [
		self tripleClick ].

	"This means: if a mouseDown, then don't further process this event (so we can turn it into a double or triple click on next buttonUp)"
	^ evt isMouseDown! !
!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 12/30/2011 23:42' prior: 16906472!
               mouseDown: event
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	event hand newKeyboardFocus: self.

	self handleInteraction: [
		self editor mouseDown: event index: (self characterIndexAtPoint: event eventPosition) ].

	event hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: event
		clkSel: nil
		clkNHalf: #clickAndHalf:
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 12/30/2011 23:42' prior: 16906497!
        mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self].
	self handleInteraction: [
		self editor mouseMove: evt index: (self characterIndexAtPoint: evt eventPosition) ]! !
!Parser methodsFor: 'public access' stamp: 'jmv 12/11/2011 22:42' prior: 16911313!
                              parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock
	"Answer a MethodNode for the argument, sourceStream, that is the root of
	 a parse tree. Parsing is done with respect to the argument, class, to find
	 instance, class, and pool variables; and with respect to the argument,
	 ctxt, to find temporary variables. Errors in parsing are reported to the
	 argument, req, if not nil; otherwise aBlock is evaluated. The argument
	 noPattern is a Boolean that is true if the the sourceStream does not
	 contain a method header (i.e., for DoIts)."
	| methNode repeatNeeded myStream s p |
	category _ aCategory.
	myStream _ sourceStream.
	[
		repeatNeeded _ false.
		p _ myStream position.
		s _ myStream upToEnd.
		myStream position: p.
		self encoder init: class context: ctxt notifying: self.
		self init: myStream notifying: req failBlock: [
			^ aBlock value ].
		doitFlag _ noPattern.
		failBlock _ aBlock.
		[ methNode _ self method: noPattern context: ctxt ]
			on: ReparseAfterSourceEditing
			do: [ :ex |
				repeatNeeded _ true.
				myStream _ sourceStreamGetter notNil 	"Cuis specific. Do not remove!!"
					ifTrue: [ requestor perform: sourceStreamGetter ]
					ifFalse: [ ReadStream on: requestor text string ]].
		repeatNeeded
	] whileTrue: [
		encoder _ self encoder class new ].
	methNode sourceText: s.
	^ methNode! !
!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/12/2011 10:52' prior: 16911627!
                 acceptDroppingMorph: dropped event: evt 
	"The supplied morph, known to be acceptable to the receiver, is now to be assimilated; the precipitating event is supplied"

	| aMorph |
	aMorph := self morphToDropFrom: dropped.
	self isWorldMorph 
		ifTrue: [	"Add the given morph to this world and start stepping it if it wants to be."

			self addMorphFront: aMorph.
			(aMorph fullBounds intersects: self viewBox) 
				ifFalse: [
					Beeper beep.
					aMorph morphPosition: bounds center]]
		ifFalse: [super acceptDroppingMorph: aMorph event: evt].
	aMorph submorphsDo: [ :m | (m isKindOf: HaloMorph) ifTrue: [ m delete ]].
	self world startSteppingSubmorphsOf: aMorph! !
!PasteUpMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:30' prior: 16911698!
         morphToGrab: event
	"Return the morph to grab from a mouse down event. If none, return nil."
	self submorphsDo: [ :m |
		((m rejectsEvent: event) not and:[m fullContainsPoint: event eventPosition]) ifTrue:[^m].
	].
	^nil! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 12/12/2011 10:52' prior: 16912032!
       viewBox: newViewBox
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
	super morphPosition: newViewBox topLeft.
	fullBounds _ bounds _ newViewBox.! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 12/12/2011 10:52' prior: 16912372!
                     addMorph: aMorph centeredNear: aPoint
	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."

	| trialRect delta |
	trialRect _ Rectangle center: aPoint extent: aMorph fullBounds extent.
	delta _ trialRect amountToTranslateWithin: bounds.
	aMorph morphPosition: trialRect origin + delta.
	self addMorph: aMorph.
! !
!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:17' prior: 16913714!
            mouseUp: evt
	isPressed _ false.
	mouseIsOver _ false.
	(actWhen == #buttonUp and: [self containsPoint: evt eventPosition])
		ifTrue: [ self performAction ].
	self redrawNeeded! !
!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 12/12/2011 10:50' prior: 16914904!
                   addToScroller: aMorph

	aMorph morphPosition: scroller morphPosition.
	scroller addMorph: aMorph! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:50' prior: 16915100!
 scrollerOffset
	^self viewableBounds topLeft - scroller morphPosition! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:52' prior: 16915105!
                            scrollerOffset: newOffset
	scroller morphPosition: self viewableBounds topLeft - newOffset! !
!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 12/30/2011 23:43' prior: 16866476!
                               mouseDown: evt

	| aMorph |
	evt hand newKeyboardFocus: self.
	aMorph _ self itemFromPoint: evt eventPosition.
	(aMorph notNil and: [ aMorph inToggleArea: evt eventPosition ])
		ifTrue: [ ^self toggleExpandedState: aMorph event: evt ]. 
	evt mouseButton2Pressed  "First check for option (menu) click"
		ifTrue: [ ^ self mouseButton2Activity ].
	aMorph ifNil: [ ^super mouseDown: evt ].
	aMorph highlightForMouseDown.
	evt hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: evt 
		clkSel: #click:
		clkNHalf: nil
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:28' prior: 16866504!
               mouseUp: event 
	| aMorph |
	aMorph := self itemFromPoint: event eventPosition.
	aMorph ifNil: [^self].
	aMorph highlightedForMouseDown ifFalse: [^self].
	aMorph highlightForMouseDown: false.
	"No change if model is locked"
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].
	((autoDeselect isNil or: [autoDeselect]) and: [aMorph == selectedMorph]) 
		ifTrue: [self setSelectedMorph: nil]
		ifFalse: [self setSelectedMorph: aMorph].
	Cursor normal show! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:30' prior: 16914057!
                            doubleClick: event
	| index |
	doubleClickSelector ifNil: [^super doubleClick: event].
	index _ self rowAtLocation: event eventPosition.
	index = 0 ifTrue: [^super doubleClick: event].
	"selectedMorph ifNil: [self setSelectedMorph: aMorph]."
	^ self model perform: doubleClickSelector! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 12/30/2011 23:43' prior: 16914069!
        mouseDown: evt

	| row |
	evt mouseButton2Pressed  "First check for option (menu) click"
		ifTrue: [^ self mouseButton2Activity].
	self hasKeyboardFocus ifFalse: [
		evt hand newKeyboardFocus: self.
		"If we are focusing, deselect, so that later selection doesn't result in deselect."
		self listMorph noSelection].
	row _ self rowAtLocation: evt eventPosition.
	row = 0  ifTrue: [^super mouseDown: evt].
	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."
	evt hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: evt
		clkSel: #click:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:30' prior: 16914093!
                              mouseUp: event
	"The mouse came up within the list; take appropriate action"

	| row |
	row _ self rowAtLocation: event eventPosition.
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].
	(autoDeselect == false and: [row = 0]) ifTrue: [^ self].  "work-around the no-mans-land bug"
	"No change if model is locked"
	((autoDeselect == nil or: [autoDeselect]) and: [row == self selectionIndex])
		ifTrue: [self changeModelSelection: 0]
		ifFalse: [self changeModelSelection: row].
	Cursor normal show.
! !
!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 12/30/2011 23:44' prior: 16914630!
 mouseDown: event

	| oldIndex oldVal row w |
	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].

	self hasKeyboardFocus ifFalse: [
		event hand newKeyboardFocus: self ].

	row _ self rowAtLocation: event eventPosition.

	row = 0 ifTrue: [^super mouseDown: event].

	w _ self ownerThatIsA: SystemWindow.
	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

		"Set meaning for subsequent dragging of selection"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row.
		oldIndex _ self getCurrentSelectionIndex.
		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].

		"Set or clear new primary selection (listIndex)"
		dragOnOrOff
			ifTrue: [self changeModelSelection: row]
			ifFalse: [self changeModelSelection: 0].

		"Need to restore the old one, due to how model works, and set new one."
		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].
		self listSelectionAt: row put: dragOnOrOff.
		"event hand releaseMouseFocus: aMorph."
		"aMorph changed"
	].
	event hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: event
		clkSel: nil
		clkNHalf: nil
		dblClkSel: #doubleClick:
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:30' prior: 16914671!
                         mouseMove: event 
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	row _ (event eventPosition y < bounds top and: [ scrollBar value > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: bounds topLeft) + 2 ]
		ifFalse: [
			(event eventPosition y > bounds bottom and: [ scrollBar value < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: bounds bottomLeft) - 3 ]
				ifFalse: [ self rowAtLocation: event eventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self changeModelSelection: row ]
		ifFalse: [ self changeModelSelection: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/11/2011 23:17' prior: 16916622!
                dragVertex: ix event: evt fromHandle: handle
	| p |
	p _ evt eventPosition.
	handle referencePosition: p.
	self verticesAt: ix put: p.
! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/11/2011 23:18' prior: 16916645!
  mouseDown: evt

	^ evt shiftPressed
		ifTrue: [((owner isKindOf: PolygonMorph) and: [owner includesHandle: self])
					ifTrue: ["Prevent insertion handles from getting edited"
							^ super mouseDown: evt].
				self toggleHandles.
				handles ifNil: [^ self].
				vertices withIndexDo:  "Check for click-to-drag at handle site"
					[:vertPt :vertIndex |
					((handles at: vertIndex*2-1 ifAbsent: [ ^self ]) containsPoint: evt eventPosition) ifTrue:
						["If clicked near a vertex, jump into drag-vertex action"
						evt hand newMouseFocus: (handles at: vertIndex*2-1)]]]
		ifFalse: [super mouseDown: evt]! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/11/2011 23:18' prior: 16916667!
       newVertex: ix event: evt fromHandle: handle
	"Insert a new vertex and fix everything up!! Install the drag-handle of the new vertex as recipient of further mouse events."

	| pt |
	(self hasProperty: #noNewVertices) ifFalse: [
		pt _ evt eventPosition.
		self setVertices: (vertices copyReplaceFrom: ix + 1 to: ix with: (Array with: pt)).
		evt hand newMouseFocus: (handles at: ((ix + 1) * 2) - 1)]
! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/12/2011 10:52' prior: 16916682!
                          updateHandles
	| newVert oldVert midPts nextVertIx tweens |
	smoothCurve
		ifTrue: [
			handles first referencePosition: vertices first.
			handles last referencePosition: vertices last.
			midPts _ OrderedCollection new.
			nextVertIx _ 2.
			tweens _ OrderedCollection new.
			self
				lineSegmentsDo: [:p1 :p2 | 
					tweens addLast: p2 asIntegerPoint.
					p2
							= (vertices atWrap: nextVertIx)
						ifTrue: ["Found endPoint."
							midPts addLast: (tweens at: tweens size // 2)
									+ (tweens at: tweens size + 1 // 2) // 2.
							tweens _ OrderedCollection new.
							nextVertIx _ nextVertIx + 1]].
			midPts
				withIndexDo: [:midPt :vertIndex | (closed
							or: [vertIndex < vertices size])
						ifTrue: [newVert _ handles at: vertIndex * 2.
							newVert referencePosition: midPt ]]]
		ifFalse: [vertices
				withIndexDo: [:vertPt :vertIndex | 
					oldVert _ handles at: vertIndex * 2 - 1.
					oldVert referencePosition: vertPt.
					(closed
							or: [vertIndex < vertices size])
						ifTrue: [newVert _ handles at: vertIndex * 2.
							newVert morphPosition: vertPt
									+ (vertices atWrap: vertIndex + 1) - newVert bounds extent // 2 + (1 @ -1)]]]! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:50' prior: 16917278!
         borderForm
	"A form must be created for drawing the border whenever the borderColor is translucent."

	| borderCanvas |
	borderForm ifNotNil: [^ borderForm].
	borderCanvas _ Display defaultCanvasClass forShadowOver: bounds.
	self drawBorderOn: borderCanvas.
	borderForm _ borderCanvas form.
	self arrowForms do:
		[:f |  "Eliminate overlap between line and arrowheads if transparent."
		borderForm copy: f boundingBox from: f to: f offset - self morphPosition rule: Form erase].
	^ borderForm! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:50' prior: 16917330!
                             computeBounds
	| oldBounds delta excludeHandles |
	vertices ifNil: [^ self].

	self redrawNeeded.
	oldBounds _ bounds.
	self releaseCachedState.
	bounds _ self curveBounds truncated.
	self arrowForms do: [ :f |
		bounds _ bounds merge: (f offset extent: f extent)].
	handles ifNotNil: [ self updateHandles ].

	"since we are directly updating bounds, see if any ordinary submorphs exist and move them accordingly"
	(oldBounds notNil and: [(delta _ bounds origin - oldBounds origin) ~= (0@0)]) ifTrue: [
		excludeHandles _ IdentitySet new.
		handles ifNotNil: [excludeHandles addAll: handles].
		self submorphsDo: [ :each |
			(excludeHandles includes: each) ifFalse: [
				each morphPosition: each morphPosition + delta ] ] ].
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded.! !
!PolygonMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 10:52' prior: 16917481!
    fromHand: hand
	"Let the user draw a polygon, clicking at each vertex, and ending
		by clicking within 5 of the first point..."
	| p1 poly oldVerts pN opposite |
	Cursor crossHair showWhile:
		[[Sensor anyButtonPressed] whileFalse:
			[self currentWorld displayWorldSafely; runStepMethods].
		p1 _ Sensor mousePoint].
	opposite _ (Display colorAt: p1) negated.
	opposite = Color transparent ifTrue: [opposite _ Color red].
	(poly _ LineMorph from: p1 to: p1 color: opposite width: 2) openInWorld.
	oldVerts _ {p1}.
	self currentWorld displayWorldSafely; runStepMethods.
	[true] whileTrue:
		[[Sensor anyButtonPressed] whileTrue:
			[pN _ Sensor mousePoint.
			poly setVertices: (oldVerts copyWith: pN).
			self currentWorld displayWorldSafely; runStepMethods].
		(oldVerts size > 1 and: [(pN dist: p1) < 5]) ifTrue: [
			hand morphPosition: Sensor mousePoint.  "Done -- update hand pos"
			^ (poly setVertices: (poly vertices copyWith: p1)) delete].
		oldVerts _ poly vertices.
		[Sensor anyButtonPressed] whileFalse:
			[pN _ Sensor mousePoint.
			poly setVertices: (oldVerts copyWith: pN).
			self currentWorld displayWorldSafely; runStepMethods]].
! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 12/12/2011 10:50' prior: 16917691!
                              startUpWithoutKeyboard
	"Display and make a selection from the receiver as long as the button  is pressed. Answer the current selection.  Do not allow keyboard input into the menu"
	
	^ self startUpWithCaption: nil at: ActiveHand morphPosition allowKeyboard: false! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:52' prior: 16934905!
   computeSlider
	| r |
	r _ self roomToMove.
	slider morphPosition:
		(bounds isWide
			ifTrue: [r topLeft + ((r width * value) asInteger @ 0)]
			ifFalse: [r topLeft + (0 @ (r height * value)  asInteger)])! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 12/11/2011 23:31' prior: 16935077!
                              setNextDirectionFromEvent: event

	nextPageDirection _ bounds isWide
		ifTrue: [ event eventPosition x >= slider referencePosition x ]
		ifFalse: [ event eventPosition y >= slider referencePosition y ]! !
!SketchMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 10:50' prior: 16939928!
                               form: aForm
	"Set the receiver's form"

	| oldForm |
	oldForm _ originalForm.
	originalForm _ aForm.
	self basicExtent: originalForm extent.

	oldForm ifNotNil: [ self morphPosition: self morphPosition + (oldForm extent - aForm extent // 2) ]! !
!ColorPickerMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:14' prior: 16821097!
            mouseDown: evt
	| localPt |
	localPt _ evt eventPosition - bounds topLeft.
	self deleteAllBalloons.
	clickedTranslucency _ TransparentBox containsPoint: localPt.
	self inhibitDragging ifFalse: [
		(DragBox containsPoint: localPt)
			ifTrue: [^ evt hand grabMorph: self].
	].
	(RevertBox containsPoint: localPt)
		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].
	self inhibitDragging ifFalse: [self comeToFront].
	sourceHand _ evt hand.
	self startStepping.
! !
!ColorPickerMorph methodsFor: 'menu' stamp: 'jmv 12/12/2011 10:45' prior: 16821230!
     pickUpColorFor: aMorph
	"Show the eyedropper cursor, and modally track the mouse through a mouse-down and mouse-up cycle"

      | aHand localPt oldCursor |
	aHand _ aMorph isNil
		ifTrue: [self world activeHand] 
		ifFalse: [ aMorph activeHand].
	self addToWorld: aHand world near: (aMorph ifNil: [aHand world]) fullBounds.
	self owner ifNil: [^ self].

	oldCursor _ Sensor currentCursor.
	ColorPickerMorph eyeDropperCursor show.

	self updateContinuously: false.
	[Sensor anyButtonPressed]
		whileFalse: 
			 [self trackColorUnderMouse].
	self deleteAllBalloons.

	localPt _World activeHand morphPosition - bounds topLeft.
	self inhibitDragging ifFalse: [
		(DragBox containsPoint: localPt) ifTrue:
			["Click or drag the drag-dot means to anchor as a modeless picker"
			^ self anchorAndRunModeless: aHand].
	].
	(clickedTranslucency _ TransparentBox containsPoint: localPt)
		ifTrue: [selectedColor _ originalColor].

	self updateContinuously: true.
	[Sensor anyButtonPressed]
		whileTrue:
			 [self updateTargetColorWith: self indicateColorUnderMouse].
	aHand newMouseFocus: nil;
		flushEvents.
	oldCursor show.
	self delete.
		 
 ! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/12/2011 10:51' prior: 16821278!
                       addToWorld: world near: box
	| goodLocation |
	goodLocation _ self bestPositionNear: box inWorld: world.
	world allMorphsDo:
		[:p | (p isMemberOf: ColorPickerMorph) ifTrue:
		[(p ~~ self and: [p owner notNil and: [p target == target]]) ifTrue:
			[(p selector == selector and: [p argument == argument])
				ifTrue: [^ p comeToFront  "uncover existing picker"]
				ifFalse: ["place second picker relative to first"
						goodLocation _ self bestPositionNear: p bounds inWorld: world]]]].
	self morphPosition: goodLocation.
	world addMorphFront: self.
	self redrawNeeded! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/12/2011 10:45' prior: 16821314!
              indicateColorUnderMouse
	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."

	| pt |
	self pickColorAt: (pt _ World activeHand morphPosition ).
	isModal ifTrue: [
		self world activeHand morphPosition: pt.
		self world displayWorldSafely; runStepMethods].
	^ selectedColor	! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/12/2011 10:45' prior: 16821356!
       trackColorUnderMouse
	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."

	| pt |
	selectedColor _ originalColor.
	self trackColorAt: (pt _ World activeHand morphPosition ).
	isModal ifTrue: [
		self world activeHand morphPosition: pt.
		self world displayWorldSafely; runStepMethods.
		self modalBalloonHelpAtPoint: pt].
	^ selectedColor	! !
!ColorPickerMorph methodsFor: 'stepping and presenter' stamp: 'jmv 12/12/2011 10:45' prior: 16821374!
                    step

	sourceHand ifNotNil: [
		self pickColorAt: sourceHand morphPosition ]! !
!ColorPickerMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16821382!
                         anchorAndRunModeless: aHand
	"If user clicks on the drag-dot of a modal picker,
	anchor it, and change to modeless operation."

	self initializeModal: false; originalColor: originalColor.  "reset as modeless"
	aHand flushEvents.  "Drop any events gathered during modal loop"
	aHand morphPosition: Sensor mousePoint; grabMorph: self.  "Slip into drag operation"
! !
!Sonogram methodsFor: 'all' stamp: 'jmv 12/12/2011 10:50' prior: 16947376!
        plotColumn: dataArray

	| chm1 i normVal r |
	columnForm unhibernate.
	chm1 _ columnForm height - 1.
	0 to: chm1 do:
		[:y | 
		i _ y*(dataArray size-1)//chm1 + 1.
		normVal _ ((dataArray at: i) - minVal) / (maxVal - minVal).
		normVal < 0.0 ifTrue: [normVal _ 0.0].
		normVal > 1.0 ifTrue: [normVal _ 1.0].
		columnForm bits at: chm1-y+1 put: (pixValMap at: (normVal * 255.0) truncated + 1)].
	(lastX _ lastX + 1) > (image width - 1) ifTrue:
		[self scroll].
	image copy: (r _ (lastX@0 extent: 1@image height))
			from: (32//image depth-1)@0
			in: columnForm rule: Form over.
	"self changed."
	self invalidRect: (r translateBy: self morphPosition)! !
!StarMorph methodsFor: 'editing' stamp: 'jmv 12/12/2011 10:50' prior: 16952212!
   dragVertex: label event: evt fromHandle: handle
	| ext oldR pt center |
	label == #center ifTrue: [
		self morphPosition: self morphPosition + (evt eventPosition - handle referencePosition)].

	label == #outside ifTrue: [
		center _ handles first referencePosition.
		pt _ center - evt eventPosition.
		ext _ pt r.
		oldR _ ext.
		vertices _ (0 to: 359 by: (360//vertices size)) collect: [ :angle |
			(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse: [ext])
					degrees: angle + pt degrees)
				+ center].
		handle align: handle referencePosition with: evt eventPosition ].

	self computeBounds.
! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 12/12/2011 10:50' prior: 16965017!
           makeMeVisible 

	self world extent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world extent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self isCollapsed
		ifTrue: [ self morphPosition: (RealEstateAgent assignCollapsePointFor: self)]
		ifFalse: [ self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: bounds extent world: self world) topLeft].

! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:50' prior: 16965086!
    justDroppedInto: aMorph event: anEvent
	isCollapsed
		ifTrue: [
			self morphPosition: (self morphPosition max: 0@0).
			collapsedFrame _ bounds]
		ifFalse: [
			fullFrame _ bounds.
			TopWindow ~~ self ifTrue: [self activate]].
	^super justDroppedInto: aMorph event: anEvent! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/12/2011 10:52' prior: 16965255!
               initializeLabelArea
	"Initialize the label area (titlebar) for the window."

	| spacing |
	spacing _ self boxExtent x + 2.

	self
		addMorph: (self createCloseBox morphPosition: 2@2);
		addMorph: (self createCollapseBox morphPosition: spacing+2@2);
		addMorph: (self createExpandBox morphPosition: spacing*2+2@2);
		addMorph: (self createMenuBox morphPosition: spacing*3+2@2)! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 12/12/2011 10:52' prior: 16965463!
               openInWorld: aWorld extent: extent
	"This msg and its callees result in the window being activeOnlyOnTop"
	self morphPosition: (RealEstateAgent initialFrameFor: self world: aWorld) topLeft; extent: extent.
	^self openAsIsIn: aWorld! !
!SystemWindow methodsFor: 'top window' stamp: 'jmv 12/12/2011 10:50' prior: 16965697!
                               activateAndForceLabelToShow
	self activate.
	bounds top < 0 ifTrue: [
		self morphPosition: (self morphPosition x @ 0)]! !
!TextEditor methodsFor: 'events' stamp: 'jmv 12/30/2011 23:31' prior: 16971740!
                     doubleClickAndHalf: evt

	| here b interval |
	b _ paragraph characterBlockAtPoint: evt eventPosition.
	here _ b stringIndex.
	interval _ self privateCurrentString encompassParagraph: (here to: here).
	self selectFrom: interval first to: interval last.

	doWordSelection _ false.
	doParagraphSelection _ true.
	initialSelectionStart _ self startBlock.
	initialSelectionStop _ self stopBlock! !
!TextEditor methodsFor: 'events' stamp: 'jmv 12/30/2011 23:44' prior: 16971755!
      mouseDown: evt 
	| clickPoint b |

	initialSelectionStart _ nil.
	initialSelectionStop _ nil.
	doWordSelection _ false.
	doParagraphSelection _ false.

	"Multiple selection of text.
	Windows uses Control, Mac uses Command (i.e. commandAlt)
	On the Mac, command-button1 is translated to command-button3 by the VM. do:
		Preferences disable: #commandClickOpensHalo
	to disable this behavior and make command-button1 work for multiple selection. "
	(evt controlKeyPressed or: [ evt commandAltKeyPressed ]) ifTrue: [
		self selectionInterval size > 0 ifTrue: [
			selectionStartBlocks _ selectionStartBlocks copyWith: self startBlock.
			selectionStopBlocks _ selectionStopBlocks copyWith: self stopBlock ]]
	ifFalse: [
		selectionStartBlocks _ #().
		selectionStopBlocks _ #() ].

	clickPoint _ evt eventPosition.
	b _ paragraph characterBlockAtPoint: clickPoint.

	(paragraph clickAt: clickPoint) ifTrue: [
		markBlock _ b.
		pointBlock _ b.
		evt hand releaseKeyboardFocus: self.
		^ self ].
	
	evt shiftPressed
		ifFalse: [
			(self markIndex = b stringIndex and: [ self pointIndex = b stringIndex ])
				ifTrue: [
					markBlock _ b.
					pointBlock _ b ]
				ifFalse: [
					markBlock _ b.
					pointBlock _ b.	
					self setEmphasisHereFromText ]]! !
!TextEditor methodsFor: 'events' stamp: 'jmv 12/30/2011 23:48' prior: 16971797!
          mouseMove: evt
	"Change the selection in response to mouse-down drag"

	| b interval i1 i2 |

	doWordSelection ifTrue: [
		pointBlock _ (paragraph characterBlockAtPoint: (evt eventPosition)).
		self selectWordLeftDelimiters: '' rightDelimiters: ''.
		markBlock _ self startBlock min: initialSelectionStart.
		pointBlock _ self stopBlock max: initialSelectionStop.
		self storeSelectionInParagraph.
		^self ].

	doParagraphSelection ifTrue: [
		b _ paragraph characterBlockAtPoint: evt eventPosition.
		i1 _ b stringIndex min: initialSelectionStart stringIndex.
		i2 _ b stringIndex max: initialSelectionStop stringIndex-1.
		interval _ self privateCurrentString encompassParagraph: (i1 to: i2).
		self selectFrom: interval first to: interval last.
		markBlock _ self startBlock min: initialSelectionStart.
		pointBlock _ self stopBlock max: initialSelectionStop.
		self storeSelectionInParagraph.
		^self ].

	pointBlock _ (paragraph characterBlockAtPoint: (evt eventPosition)).
	self storeSelectionInParagraph! !
!TextEditor methodsFor: 'events' stamp: 'jmv 12/11/2011 23:19' prior: 16971831!
                          mouseUp: evt
	| cursorBlock cursorIndex startBlock startIndex stopBlock stopIndex |

	evt shiftPressed
		ifTrue: [
			"Squeak classic behavior for click, move, shift-click sequence "
			"pointBlock _(paragraph characterBlockAtPoint: (evt eventPosition))."

			"Mac behavior"
			cursorBlock _ paragraph characterBlockAtPoint: evt eventPosition.
			cursorIndex _ cursorBlock stringIndex.
			startBlock _ self startBlock min: cursorBlock.
			startIndex _ startBlock stringIndex.
			stopBlock _ self stopBlock max: cursorBlock.
			stopIndex _ stopBlock stringIndex.
			(stopIndex - cursorIndex) < (cursorIndex - startIndex)
				ifTrue: [
					markBlock _ startBlock.
					pointBlock _ cursorBlock ]
				ifFalse: [
					markBlock _ stopBlock.
					pointBlock _ cursorBlock ]].
	self storeSelectionInParagraph! !
!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 12/11/2011 23:32' prior: 16973778!
                              scrollSelectionIntoView: event
	"Scroll my text into view if necessary and return true, else return false"
	| selRects rectToTest cpHere |
	selRects _ self textMorph selectionRects.
	selRects isEmpty ifTrue: [ ^ self ].
	rectToTest _ selRects first merge: selRects last.
	(event notNil and: [ event anyButtonPressed ]) ifTrue: [  "Check for autoscroll"
		cpHere _ event eventPosition.
		cpHere y <= bounds top
			ifTrue:  [ rectToTest _ selRects first topLeft extent: 2@2 ]
			ifFalse: [
				cpHere y >= bounds bottom
					ifTrue: [ rectToTest _ selRects last bottomRight extent: 2@2 ]
					ifFalse: [ ^ self ]]].
	^ self scrollToShow: rectToTest! !
!MouseEvent methodsFor: 'comparing' stamp: 'jmv 12/11/2011 23:29' prior: 16901120!
   = aMorphicEvent
	super = aMorphicEvent ifFalse:[^false].
	position = aMorphicEvent eventPosition ifFalse: [^ false].
	buttons = aMorphicEvent buttons ifFalse: [^ false].
	^ true
! !
!MouseEvent methodsFor: 'printing' stamp: 'jmv 12/11/2011 23:37' prior: 16901181!
                        printOn: aStream

	aStream nextPut: $[.
	aStream nextPutAll: self eventPosition printString; space.
	aStream nextPutAll: type; space.
	aStream nextPutAll: self modifierString.
	aStream nextPutAll: self buttonString.
	aStream nextPutAll: timeStamp printString.
	aStream nextPut: $].! !
!MouseMoveEvent methodsFor: 'comparing' stamp: 'jmv 12/11/2011 23:29' prior: 16901270!
            = aMorphicEvent
	super = aMorphicEvent ifFalse:[^false].
	position = aMorphicEvent eventPosition ifFalse: [^ false].
	startPoint = aMorphicEvent startPoint ifFalse: [^ false].
	buttons = aMorphicEvent buttons ifFalse: [^ false].
	^ true
! !
!WindowEdgeAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 10:50' prior: 16985939!
              handPoint
	^ hand morphPosition! !

MouseEvent removeSelector: #position!

MouseEvent removeSelector: #position!

UserInputEvent removeSelector: #position!

UserInputEvent removeSelector: #position!

SystemWindow removeSelector: #position:!

SystemWindow removeSelector: #position:!

PasteUpMorph removeSelector: #position:!

PasteUpMorph removeSelector: #position:!

HaloMorph removeSelector: #position:!

HaloMorph removeSelector: #position:!

Morph removeSelector: #position!

Morph removeSelector: #position!

Morph removeSelector: #position:!

Morph removeSelector: #position:!

DropEvent removeSelector: #position!

DropEvent removeSelector: #position!

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4201-positionFalsePolymorphism-jmv.8.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 2:37:37 pm'!

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!Morph methodsFor: 'as yet unclassified' stamp: 'jmv 12/12/2011 11:15'!
                       initPosExtent
"
Morph allSubInstancesDo: [ :m | m initPosExtent ]
"
	position ifNil: [
		position _ owner
			ifNil: [ bounds topLeft ]
			ifNotNil: [
				owner initPosExtent.
				owner internalizeFromWorld: bounds topLeft ]].
	extent ifNil: [ extent _ bounds extent ].! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 23:00'!
                   externalizeToWorld: aPoint
	"aPoint is in own coordinates. Answer is in world coordinates."
	^owner
		ifNotNil: [ owner internalizeFromWorld: aPoint + position ]
		ifNil: [ aPoint + position ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 22:59'!
                               internalizeFromWorld: aPoint
	"aPoint is in World coordinates. Answer is in own coordinates."
	^(owner
		ifNotNil: [ owner internalizeFromWorld: aPoint ]
		ifNil: [ aPoint ])
			- position! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 22:59'!
                            externalizeToWorld: aPoint
	"aPoint is in own coordinates. Answer is in world coordinates."
	^self isWorldMorph
		ifTrue: [ aPoint ]
		ifFalse: [ super externalizeToWorld: aPoint ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 22:59'!
    internalizeFromWorld: aPoint
	"aPoint is in World coordinates. Answer is in own coordinates."
	^self isWorldMorph
		ifTrue: [ aPoint ]
		ifFalse: [ super internalizeFromWorld: aPoint ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 19:05' prior: 16897808!
                       basicExtent: aPoint

	bounds extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	bounds _ bounds topLeft extent: aPoint.
	extent _ aPoint.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 13:22' prior: 50331684!
    morphPosition: aPoint
	"Change the position of this morph and and all of its submorphs."

	"Detesto el falso polimorfismo con streams. Ponerle otro nombre a esto!!
	Igual, todavia esta #position, el getter, que es igual de feo..."
	
	"
	VER SENDERS. Acomodar. el argumento es en coord del owner o del world?
	Convertir los senders a senders de #zzpositionInOwner: o #zzpositionInWorld
	Espero que pocos hablen en coordenadas del world!!
	"

	| delta |
	delta _ aPoint - bounds topLeft.
	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.
	self privateFullMoveBy: delta.

	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].

	self redrawNeeded
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/11/2011 19:08' prior: 16898319!
          initialize
	"initialize the state of the receiver"

	owner _ nil.
	submorphs _ #().
	bounds _ self defaultBounds.
	position _ bounds topLeft.
	extent _ bounds extent.
	color _ self defaultColor! !
!Morph methodsFor: 'private' stamp: 'jmv 12/12/2011 11:16' prior: 16899783!
               privateBounds: boundsRect
	"Private!! Use position: and/or extent: instead."

	fullBounds _ nil.
	bounds _ boundsRect.
	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].
	extent _ bounds extent.! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 12/11/2011 19:22' prior: 16865312!
            initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	bounds _ 0@0 extent: CursorWithMask normal extent.
	position _ 0@0.
	extent _ CursorWithMask normal extent.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 12/11/2011 19:20' prior: 16887838!
  initialize
	super initialize.
	bounds _ 0@0 corner: 40@10.
	position _ 0@0.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil
! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 19:21' prior: 16911766!
                             extent: aPoint

	bounds extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 12/12/2011 11:19' prior: 50333461!
                   viewBox: newViewBox
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
	super morphPosition: newViewBox topLeft.
	fullBounds _ bounds _ newViewBox.
	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].
	extent _ bounds extent.! !

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

World allMorphsDo: [ :m | m initPosExtent ].
Morph allSubInstancesDo: [ :m | m initPosExtent ]!

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4202-positionAndExtentIvars-jmv.7.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 2:48:24 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:06'!
          morphHeight
"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	^ bounds height! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:06'!
                              morphHeight: aNumber

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self extent: bounds width@aNumber asInteger.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 09:02'!
                      morphPositionInOwner
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"

	self flag: #jmvVer2.
	self validateOwnerNotNil.
	self validatePositionAndBounds.

	^ position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 20:47'!
                     morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = bounds topLeft ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

owner ifNil: [
	'-----trying to set position before setting owner... bad idea!!-----' print.
	thisContext printStack: 10 ].


"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 09:02'!
                               morphPositionInWorld
	| answer1 answer2 |
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"


	self flag: #jmvVer2.
	self validateOwnerNotNil.
	self validatePositionAndBounds.
	
	answer1 _ owner
		ifNotNil: [ owner externalizeToWorld: position ]
		ifNil: [ position ].
	answer2 _ bounds topLeft.
	{ answer1 . answer2 }.

	^answer2! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 20:47'!
                 morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
owner ifNil: [
	'-----trying to set position before setting owner... bad idea!!-----' print.
	thisContext printStack: 10 ].

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
"Quizas no un null change del todo... Es posible que bounds y position se desincronicen, al cambiar el owner (o cualquier owner en el medio). Todo esto es fulerote. espero sacarlo pronto!!"
		self privateFullMoveBy: newPositionInWorld - bounds topLeft.
		^ self ].		"Null change"


	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:09'!
        morphWidth

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	^ bounds width! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:09'!
                               morphWidth: aNumber
"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self extent: aNumber asInteger@bounds height.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 09:01'!
                       validateOwnerNotNil
	"To be removed. Just to check consistency"

	self flag: #jmvVer2.
	owner ifNil: [
		'-----Still no owner, but this stuff kind of requires it!!-----' print.
		thisContext printStack: 10 ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 20:38'!
                validatePositionAndBounds
	"To be removed. Just to check consistency"
	| answer1 answer2 |
	self flag: #jmvVer2.

	answer1 _ owner
		ifNotNil: [ owner externalizeToWorld: position ]
		ifNil: [ position ].
	answer2 _ bounds topLeft.

	answer1 = answer2 ifFalse: [
		#validatePositionAndBounds print.
		answer1 print.
		answer2 print.
		thisContext printStack: 10 ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 16:14'!
             morphPositionInWorld

	self flag: #jmvVer2. "Solo para evitar los warning por falta de owner... pensar despues este caso"
	self isWorldMorph ifTrue: [ ^ 0@0 ].
	^super morphPositionInWorld! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:39'!
                            windowBottom: aNumber
	"aNumber is an Y coordinate in the owner's coordinate system"
	self bounds: (bounds bottom: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:40'!
                             windowBottomLeft: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self bounds: (aPoint x @ bounds top corner: bounds right @ aPoint y)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:41'!
                     windowBottomRight: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self bounds: (bounds origin corner: aPoint)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:41'!
             windowLeft: aNumber
	"aNumber is an X coordinate in the owner's coordinate system"
	self bounds: (bounds left: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:42'!
 windowRight: aNumber
	"aNumber is an X coordinate in the owner's coordinate system"
	self bounds: (bounds right: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:42'!
                               windowTop: aNumber
	"aNumber is an Y coordinate in the owner's coordinate system"
	self bounds: (bounds top: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:43'!
   windowTopLeft: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self bounds: (aPoint corner: bounds corner)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:43'!
                 windowTopRight: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self bounds: (bounds left @ aPoint y corner: aPoint x @ bounds bottom)! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
                          forBottom
	^self new initializeBottom! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
                        forBottomLeft
	^self new initializeBottomLeft! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
                forBottomRight
	^self new initializeBottomRight! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
              forLeft
	^self new initializeLeft! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
                            forRight
	^self new initializeRight! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:58'!
                          forTop
	^self new initializeTop! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:58'!
                              forTopLeft
	^self new initializeTopLeft! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:58'!
                      forTopRight
	^self new initializeTopRight! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 12/13/2011 23:33' prior: 16803680!
                           placeEmbeddedObject: anchoredFormOrMorph
	"Place the anchoredMorph or return false if it cannot be placed.
	In any event, advance destX by its width."

	destX _ destX + anchoredFormOrMorph morphWidth.
	(destX > rightMargin and: [ lastIndex ~= line first ])
		"Won't fit, but  not at start of a line. Start a new line with it"
		ifTrue: [ ^ false].
	lastIndex _ lastIndex + 1.
	^ true! !
!CharacterBlockScanner methodsFor: 'scanning' stamp: 'jmv 12/13/2011 23:33' prior: 16803579!
placeEmbeddedObject: anchoredFormOrMorph

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	specialWidth _ anchoredFormOrMorph morphWidth.
	^ true! !
!CompositionScanner methodsFor: 'stop conditions' stamp: 'jmv 12/13/2011 23:35' prior: 16825773!
                    placeEmbeddedObject: anchoredFormOrMorph
	| descent |

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [
		line stop: lastIndex-1.
		^ false].
	descent _ lineHeight - baseline.
	baseline _ baseline max: anchoredFormOrMorph morphHeight.
	lineHeight _ baseline + descent.
	line stop: lastIndex.
	^ true! !
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 12/13/2011 23:35' prior: 16880957!
                  fixedOrMorphHeight: aNumber
	"aNumber is taken as the fixed height to use.
	No proportional part."
	fixedHeight
		ifNotNil: [ fixedHeight _ aNumber ]
		ifNil: [ morph morphHeight: aNumber ].
	proportionalHeight _ nil! !
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 12/13/2011 23:34' prior: 16880966!
                 fixedOrMorphWidth: aNumber
	"aNumber is taken as the fixed width to use.
	No proportional part."
	fixedWidth
		ifNotNil: [ fixedWidth _ aNumber ]
		ifNil: [ morph morphWidth: aNumber ].
	proportionalWidth _ nil! !
!LayoutSpec methodsFor: 'layout' stamp: 'jmv 12/13/2011 23:35' prior: 16881091!
                          fixedHeight
	"If proportional is zero, answer stored fixed extent, or actual morph extent if undefined. (no proportional extent is computed)
	Otherwise, we do proportional layout, and the stored extent is a minimum extent, so we don't  really a fixed extent."
	proportionalHeight ifNotNil: [
		^0 ].
	^ fixedHeight ifNil: [ morph morphHeight ]! !
!LayoutSpec methodsFor: 'layout' stamp: 'jmv 12/13/2011 23:33' prior: 16881104!
                     fixedWidth
	"If proportional is zero, answer stored fixed extent, or actual morph extent if undefined. (no proportional extent is computed)
	Otherwise, we do proportional layout, and the stored extent is a minimum extent, so we don't  really a fixed extent."
	proportionalWidth ifNotNil: [
		^0 ].
	^ fixedWidth ifNil: [ morph morphWidth ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 09:01' prior: 50334437!
                            basicExtent: aPoint

	self flag: #jmvVer2.
	"Lo dejo un rato porque se llama dde initialize... De ultima, es un problema? Es cierto que no se la escala aun..."
	"
	self validateOwnerNotNil.
	"
	
	"ver senders. Es en owner's o en world's ???"
	
	
	bounds extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	bounds _ bounds topLeft extent: aPoint.
	extent _ aPoint.
	self validatePositionAndBounds.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:10' prior: 16897816!
  bounds
	"Return the bounds of this morph."
	"Note: It is best not to override this method because many methods in Morph and its subclasses use the instance variable directly rather than 'self bounds'. Instead, subclasses should be sure that the bounds instance variable is correct."

	"remove senders and implementors"
	self flag: #jmvVer2.

	^ bounds
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:10' prior: 50331984!
               bounds: newBounds
	| oldExtent newExtent |

	"remove senders and implementors"
	self flag: #jmvVer2.
		
	oldExtent _ bounds extent.
	newExtent _ newBounds extent.
	"Moving stuff around is most likely the most common operation.
	Optimize it"
	oldExtent = newExtent ifTrue: [
		^self morphPosition: newBounds topLeft ].
	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[
		"We're growing. First move then resize."
		self morphPosition: newBounds topLeft; extent: newExtent.
	] ifFalse: [
		"We're shrinking. First resize then move."
		self extent: newExtent; morphPosition: newBounds topLeft.
	].! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:11' prior: 16897847!
                               extent
"
?
'' print.
thisContext printStack: 10.
"
"Needs to be turned into extentInOwner and extentInWorld"
"or better yet into morphExtent:, and assume it is always in owner's coordinates!!"
	self flag: #jmvVer2.
	^ bounds extent! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:11' prior: 16897850!
        extent: aPoint
"
?
'' print.
thisContext printStack: 10.
"
"Needs to be turned into extentInOwner: and extentInWorld:"
"or better yet into morphExtent:, and assume it is always in owner's coordinates!!"
	self flag: #jmvVer2.
	self basicExtent: aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 16:01' prior: 50334402!
                     externalizeToWorld: aPoint
	"aPoint is in own coordinates. Answer is in world coordinates."
	self flag: #jmvVer2.
	^owner
		ifNotNil: [ owner externalizeToWorld: aPoint + position ]
		ifNil: [ aPoint + position ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:08' prior: 16897853!
                           height
	self flag: #jmvVer2.
"False polymorphism elimination: turn senders into morphHeight"
'' print.
thisContext printStack: 10.
	^ bounds height! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:07' prior: 16897856!
                            height: aNumber
	self flag: #jmvVer2.
"False polymorphism elimination: turn senders into morphHeight:"
'' print.
thisContext printStack: 10.
	self extent: bounds width@aNumber asInteger.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:07' prior: 16897860!
                    innerBounds
	"Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."

"In own's coordinates!!"
	self flag: #jmvVer2.
	^ bounds! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 16:01' prior: 50334411!
           internalizeFromWorld: aPoint
	"aPoint is in World coordinates. Answer is in own coordinates."
	self flag: #jmvVer2.
	^(owner
		ifNotNil: [ owner internalizeFromWorld: aPoint ]
		ifNil: [ aPoint ])
			- position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:06' prior: 16897868!
                             minimumExtent
	| ext |
	"This returns the minimum extent that the morph may be shrunk to.  Not honored in too many places yet, but respected by the resizeToFit feature, at least.  copied up from SystemWindow 6/00"
	self flag: #jmvVer2.	"in owner's coordinates?"
	(ext _ self valueOfProperty: #minimumExtent)
		ifNotNil:
			[^ ext].
	^ 100 @ 80! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 15:45' prior: 50331674!
                        morphPosition
"
Ver que senders quieren #morphPositionInOwner y quienes #morphPosirionInWorld (espero que pocos!!)
Eventualmente eliminar los senders a este...
"
	self flag: #jmvVer2.
	^ self morphPositionInWorld! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 15:45' prior: 50334446!
                           morphPosition: newPositionInWorld
"Cuando terminemos, el arg es en coords del owner
entonces: Warning: argument is in owner's coordinate system. When creating new morphs, first add to owner, then set position."
	"Change the position of this morph."
	"
	Para morphs que estan en el mundo, da lo mismo!! Y para los que estan en otro morph, la mayoria de las veces usaremos un layout. Y las veces que no, usaremos coordenadas del owner tambien!!
	Podemos hacer que por default, #morphPosition y #morphPosition: sean en el owner, y chequear los senders...
	Quizas el camino es ir cambiando los senders a isOwner, y cuando todos sean ahi, eliminar los demas... suena razonable, no?
	Lo mismo para setter.
	Lo mismo para extent, height, width... aunque aqui, hasta que no introduzca factor de escala, no es tan urgente (i.e. no se rompe ya mismo!!) Eso quiere decir que no necesito pasar por los sufijos provisorios InOwner e InWorld!!
	Y en algun momento de todo esto, empezar a atacar los usos directos de la ivar bounds!!
	"
	
	"
Ver que senders quieren #morphPositionInOwner: y quienes #morphPosirionInWorld: (espero que pocos!!)
Eventualmente eliminar los senders a este...
NO OLVIDARSE que hay redefiniciones de este metodo... Redefinir los 2 setters que quedan?
	"
	self flag: #jmvVer2.
	^self morphPositionInWorld: newPositionInWorld! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:08' prior: 16897895!
                        width

	self flag: #jmvVer2.
"False polymorphism elimination: turn senders into morphWidth"
'' print.
thisContext printStack: 10.
	^ bounds width! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:08' prior: 16897898!
                              width: aNumber

	self flag: #jmvVer2.
"False polymorphism elimination: turn senders into morphWidth:"
'' print.
thisContext printStack: 10.
	self extent: aNumber asInteger@bounds height.
! !
!Morph methodsFor: 'geometry eToy' stamp: 'jmv 12/14/2011 15:51' prior: 50332005!
               referencePosition: aPoint
	"a rather ugly way to say #center: . Just for consistency with #referencePosition"
	self flag: #jmvVer2.
	self morphPosition: aPoint - (bounds extent // 2)! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/14/2011 16:04' prior: 16898303!
                   inATwoWayScrollPane
	"Answer a two-way scroll pane that allows the user to scroll the receiver in either direction.  It will have permanent scroll bars unless you take some special action."

	| widget |
	self flag: #jmvVer2.
	widget _ PluggableScrollPane new.
	widget addToScroller: self.
	widget extent: (self morphWidth min: 300 max: 100) @ (self morphHeight min: 150 max: 100).
	widget setScrollDeltas.
	widget color: self color darker darker.
	^widget! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/15/2011 20:43' prior: 50334475!
  initialize
	"initialize the state of the receiver"

	owner _ nil.
	submorphs _ #().
	
	self flag: #jmvVer2.
	"Ir convirtiendo todos los usos (no las asignaciones!!) a las vars nuevas.
	Despues eliminar las asignaciones y las propias ivars (bounds y fullBounds)"
	bounds _ self defaultBounds.

	position _ bounds topLeft.
	extent _ bounds extent.
	self validatePositionAndBounds.
	color _ self defaultColor! !
!Morph methodsFor: 'private' stamp: 'jmv 12/16/2011 09:03' prior: 16899789!
                           privateFullMoveBy: delta
	"Private!! Relocate me and all of my subMorphs by recursion. Subclasses that implement different coordinate systems may override this method."

	"All these will die soon!!"
	self flag: #jmvVer2.

	self privateMoveBy: delta.
	submorphs do: [ :m |
		m privateFullMoveBy: delta ]! !
!Morph methodsFor: 'private' stamp: 'jmv 12/16/2011 09:03' prior: 16899799!
  privateMoveBy: delta
	"Private!! Use 'position:' instead."

	"All these will die soon!!"

	self flag: #jmvVer2.
	self validateOwnerNotNil.

	bounds _ bounds translateBy: delta.
	fullBounds ifNotNil: [ fullBounds _ fullBounds translateBy: delta ].! !
!Morph methodsFor: 'private' stamp: 'jmv 12/16/2011 09:04' prior: 16899806!
                          privateOwner: aMorph
	"Private!! Should only be used by methods that maintain the ower/submorph invariant."

	| oldGlobalPosition prevOwner |
	self flag: #jmvVer2.
	"
	(aMorph notNil and: [
		bounds origin ~= self defaultBounds origin ]) ifTrue: [
			'                                ---------------- Nos mandan #privateOwner: , pero nos han mandado bounds antes (no necesariamente un problema!!!!!!!!!!)!!' print.
			thisContext printStack: 10 ].
	"
		
	self flag: #jmvVer2.
	"Is this the best behavior???"
	prevOwner _ owner.
	prevOwner
		ifNotNil: [
			"Had an owner. Maintain my global position..."
			oldGlobalPosition _ self morphPositionInWorld ].
	owner _ aMorph.
	owner
		ifNil: [
			"Won't have any owner. Keep local position, as it will be maintained in my new owner later"
			bounds _ position extent: bounds extent.
			fullBounds _ nil.
			self validatePositionAndBounds
			]
		ifNotNil: [
			prevOwner
				ifNil: [
					"Didn't have any owner. Assume my local position is to be maintained in my new owner"
					bounds _ (owner externalizeToWorld: position) extent: bounds extent.
					fullBounds _ nil.
					self validatePositionAndBounds
					]
				ifNotNil: [
					"Had an owner. Maintain my global position..."
					position _ owner internalizeFromWorld: oldGlobalPosition.
					self validatePositionAndBounds
					]]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 19:56' prior: 50332304!
                      addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w |
	w := self world ifNil: [target world].
	nameMorph := StringMorph contents: aString.
	nameMorph color: Color magenta.
	namePosition := outerRectangle bottomCenter 
				- ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph 
		morphPosition: (namePosition min: w viewBox bottomRight - nameMorph extent y + 5).
	self addMorph: (RectangleMorph new
		bounds: (nameMorph bounds outsetBy: 2);
		borderWidth: 0;
		color: (Color lightBlue alpha: 0.9)).
	self addMorph: nameMorph.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 19:56' prior: 16864064!
   basicBox
	| aBox minSide anExtent w |
	minSide _ 4 * self handleSize.
	anExtent _ ((self morphWidth + self handleSize + 8) max: minSide) @
				((self morphHeight + self handleSize + 8) max: minSide).
	aBox _ Rectangle center: bounds center extent: anExtent.
	w _ self world ifNil: [ target outermostWorldMorph ].
	^ w
		ifNil:
			[ aBox ]
		ifNotNil:
			[ aBox intersect: (w viewBox insetBy: 8@8) ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/14/2011 15:56' prior: 50332336!
                              doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target bounds topLeft.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target extent: newExtent.
	growHandle morphPosition: evt eventPosition - (growHandle extent // 2).
	self someSubmorphPositionOrExtentChanged
! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/14/2011 15:56' prior: 50332371!
 doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Color lightBlue]
		ifFalse: [rotHandle color: Color blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPosition: evt eventPosition - (rotHandle extent // 2).
	self someSubmorphPositionOrExtentChanged! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 12/15/2011 20:46' prior: 50334495!
                       initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	bounds _ 0@0 extent: CursorWithMask normal extent.
	position _ 0@0.
	extent _ CursorWithMask normal extent.
	self validatePositionAndBounds.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:31' prior: 16869456!
                      adjustExtent
	"And reposition submorphs"
	| w p0 h y |
	"make all items wide, so selection indicator is wide too"
	w _ self desiredWidth.
	p0 _ bounds topLeft..
	y _ 0.
	self submorphsDo: [ :m |
		h _ m morphHeight.
		m privateBounds: (p0 + (0@y) extent: w@h).
		y _ y + h ].
	self extent: w@y! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 14:19' prior: 16869890!
model: aTextModel wrappedTo: width
	"Accept new text contents.  Lay it out, wrapping to width.
	Then fit my height to the result."
	wrapFlag _ true.
	self basicExtent: width truncated@self morphHeight.
	self model: aTextModel! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 12/12/2011 14:18' prior: 16880116!
          adjustHorizontallyBy: aLayoutAdjustMorph at: aPoint
	| delta l ls r rs lNewWidth rNewWidth i lCurrentWidth rCurrentWidth doNotResizeBelow |
	doNotResizeBelow _ self minPaneWidthForReframe.
	i _ submorphs indexOf: aLayoutAdjustMorph.
	l _ self submorphs at: i +1.
	ls _ l layoutSpec.
	lCurrentWidth _ l morphWidth max: 1.	"avoid division by zero"
	r _ self submorphs at: i - 1.
	rs _ r layoutSpec.
	rCurrentWidth _ r morphWidth max: 1.	"avoid division by zero"
	delta _ aPoint x - aLayoutAdjustMorph referencePosition x.
	delta _ delta max: doNotResizeBelow - lCurrentWidth.
	delta _ delta min: rCurrentWidth - doNotResizeBelow.
	delta = 0 ifTrue: [ ^self ].
	rNewWidth _ rCurrentWidth - delta.
	lNewWidth _ lCurrentWidth + delta.
	(ls isProportionalWidth and: [ rs isProportionalWidth ])
		ifTrue: [	"If both proportional, update them"
			ls setProportionalWidth: (1.0 * lNewWidth / lCurrentWidth * ls proportionalWidth).
			rs setProportionalWidth: (1.0 * rNewWidth / rCurrentWidth * rs proportionalWidth) ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ls isProportionalWidth ifFalse: [
				ls fixedOrMorphWidth: lNewWidth ].
			rs isProportionalWidth ifFalse: [
				rs fixedOrMorphWidth: rNewWidth ]].
	self layoutSubmorphs.
	fullBounds _ bounds! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 12/12/2011 14:18' prior: 16880158!
                        adjustVerticallyBy: aLayoutAdjustMorph at: aPoint
	| delta t ts b bs tNewHeight bNewHeight i tCurrentHeight bCurrentHeight doNotResizeBelow |
	doNotResizeBelow _ self minPaneHeightForReframe.
	i _ submorphs indexOf: aLayoutAdjustMorph.
	t _ self submorphs at: i +1.
	ts _ t layoutSpec.
	tCurrentHeight _ t morphHeight max: 1.	"avoid division by zero"
	b _ self submorphs at: i - 1.
	bs _ b layoutSpec.
	bCurrentHeight _ b morphHeight max: 1.	"avoid division by zero"
	delta _ aPoint y - aLayoutAdjustMorph referencePosition y.
	delta _ delta max: doNotResizeBelow - tCurrentHeight.
	delta _ delta min: bCurrentHeight - doNotResizeBelow.
	delta = 0 ifTrue: [ ^self ].
	tNewHeight _ tCurrentHeight + delta.
	bNewHeight _ bCurrentHeight - delta.
	(ts isProportionalHeight and: [ bs isProportionalHeight ])
		ifTrue: [	"If both proportional, update them"
			ts setProportionalHeight: (1.0 * tNewHeight / tCurrentHeight * ts proportionalHeight).
			bs setProportionalHeight: (1.0 * bNewHeight / bCurrentHeight * bs proportionalHeight) ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ts isProportionalHeight ifFalse: [
				ts fixedOrMorphHeight: tNewHeight ].
			bs isProportionalHeight ifFalse: [
				bs fixedOrMorphHeight: bNewHeight ]].
	self layoutSubmorphs.
	fullBounds _ bounds! !
!MenuLineMorph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 14:20' prior: 16887230!
                 initialize
	super initialize.
	self morphHeight: 2! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 12/12/2011 14:27' prior: 16887433!
                     addStayUpIcons
	| closeBox pinBox w |
	
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	closeBox _ PluggableButtonMorph model: self action: #delete.
	closeBox icon: Theme current closeIcon.
	pinBox _ PluggableButtonMorph model: self action: #stayUp.
	pinBox icon: Theme current pushPinIcon.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 42.
	self addMorphFront: 
		(LayoutMorph newRow
			morphHeight: (titleMorph morphHeight max: 19);
			morphWidth: w;	"Make room for buttons"
			color: Color transparent;
			addMorph: closeBox fixedWidth: 20;
			addMorph: (RectangleMorph new borderWidth: 0; color: Color transparent) fixedWidth: 4;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (RectangleMorph new borderWidth: 0; color: Color transparent) fixedWidth: 4;
			addMorph: pinBox fixedWidth: 20).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 3/14/2012 13:47' prior: 50332896!
                     addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w |
	
	titleMorph _ RectangleMorph new.
	self setTitleParametersFor: titleMorph.
	pp _ 8@2.
	aString asString linesDo: [ :line |
		s _ StringMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		titleMorph addMorphBack: s.
		s morphPositionInOwner: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphHeight: pp y; morphWidth: w + 8.
	self addMorphFront: titleMorph.
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 12/15/2011 20:45' prior: 50334506!
                       initialize
	super initialize.
	bounds _ 0@0 corner: 40@10.
	position _ 0@0.
	self validatePositionAndBounds.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil
! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 14:25' prior: 50333056!
adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p tl |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: (
			(each respondsTo: #minItemWidth)
				ifTrue: [each minItemWidth]
				ifFalse: [each morphWidth])].

	w _ w + 4.
	tl _ bounds topLeft.
	p _ tl + 5.
	submorphs do: [ :m |
		m morphWidth: w.
		m morphPosition: p.
		p _ m bounds bottomLeft +(0@1) ].
	
	self extent: submorphs last bounds bottomRight - tl + 5! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 14:21' prior: 50333078!
                           positionAt: aPoint relativeTo: aMenuItem inWorld: aWorld
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| i yOffset sub delta |
	self adjustSubmorphsLayout.
	i _ 0.
	yOffset _ 0.
	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]
		whileFalse: [ yOffset _ yOffset + sub morphHeight ].

	self morphPosition: aPoint - (2 @ (yOffset + 8)).

	"If it doesn't fit, show it to the left, not to the right of the hand."
	bounds right > aWorld world bounds right
		ifTrue: [
			self moveRight: aPoint x + 1].

	"Make sure that the menu fits in the world."
	delta _ bounds amountToTranslateWithin:
		(aWorld world bounds withHeight: ((aWorld world bounds height - 18) max: (ActiveHand morphPosition y) + 1)).
	delta = (0 @ 0) ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 20:46' prior: 50334515!
 extent: aPoint

	self flag: #jmvVer2.
	bounds extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self validatePositionAndBounds.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 12/15/2011 20:46' prior: 50334531!
                           viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
"	super morphPosition: newViewBox topLeft."
	fullBounds _ bounds _ newViewBox.
	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].
	extent _ bounds extent.
	self validatePositionAndBounds.! !
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 12/13/2011 14:44' prior: 16912138!
                          bringWindowsFullOnscreen
	"Make ever SystemWindow on the desktop be totally on-screen, whenever possible."
	
	(SystemWindow windowsIn: self satisfying: [ :w | true]) do:
		[ :aWindow | 
			aWindow windowRight: (aWindow bounds right min: bounds right).
			aWindow windowBottom: (aWindow bounds bottom min: bounds bottom).
			aWindow windowLeft: (aWindow bounds left max: bounds left).
			aWindow windowTop: (aWindow bounds top max: bounds top)]! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:14' prior: 16915064!
      hTotalScrollRange
	"Return the width extent of the receiver's scrollable area"
	^scroller morphWidth! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:14' prior: 16915181!
                             vTotalScrollRange
	"Return the height extent of the receiver's scrollable area"
	^scroller morphHeight! !
!HierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:15' prior: 16866576!
                         scrollDeltaHeight
	scroller hasSubmorphs ifFalse: [ ^1].
	^ scroller firstSubmorph morphHeight! !
!LimitedHeightTextMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:20' prior: 16881445!
innerHeight: aNumber
	"Adjust height and scrollbar to the new contents height."
	self morphHeight: (aNumber + 10 min: maxHeight)! !
!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 14:17' prior: 16914165!
                            initialize
	super initialize.
	scroller morphWidth: self morphWidth.
	scroller color: self textColor.! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 12/15/2011 20:45' prior: 50333820!
    computeBounds
	| oldBounds delta excludeHandles |

	self flag: #jmvVer2.
	vertices ifNil: [^ self].

	self redrawNeeded.
	oldBounds _ bounds.
	self releaseCachedState.
	bounds _ self curveBounds truncated.
	self arrowForms do: [ :f |
		bounds _ bounds merge: (f offset extent: f extent)].
	handles ifNotNil: [ self updateHandles ].

	"since we are directly updating bounds, see if any ordinary submorphs exist and move them accordingly"
	(oldBounds notNil and: [(delta _ bounds origin - oldBounds origin) ~= (0@0)]) ifTrue: [
		excludeHandles _ IdentitySet new.
		handles ifNotNil: [excludeHandles addAll: handles].
		self submorphsDo: [ :each |
			(excludeHandles includes: each) ifFalse: [
				each morphPosition: each morphPosition + delta ] ] ].
	self validatePositionAndBounds.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded.! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:17' prior: 16934914!
                              expandSlider
	"Compute the new size of the slider (use the old sliderThickness as a minimum)."
	| r |
	r _ self totalSliderArea.
	slider extent: (bounds isWide
		ifTrue: [((r width * interval) asInteger max: 7) @ slider morphHeight]
		ifFalse: [slider morphWidth @ ((r height * interval) asInteger max: 7)])! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/12/2011 13:58' prior: 16965222!
               initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	isCollapsed _ false.
	
	self wantsLabel ifTrue: [self initializeLabelArea].
	self extent: 300 @ 200.
	updatablePanes _ #().

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorph: m ].

	"by default"
	self beColumn! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985872!
           initializeBottom
	selector _ #windowBottom:.
	coordinateGetter _ #y.
	cursorGetter _ #resizeBottom! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985878!
                    initializeBottomLeft
	selector _ #windowBottomLeft:.
	coordinateGetter _ #yourself.
	cursorGetter _ #resizeBottomLeft! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985885!
 initializeBottomRight
	selector _ #windowBottomRight:.
	coordinateGetter _ #yourself.
	cursorGetter _ #resizeBottomRight! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985892!
                              initializeLeft
	selector _ #windowLeft:.
	coordinateGetter _ #x.
	cursorGetter _ #resizeLeft! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985898!
                          initializeRight
	selector _ #windowRight:.
	coordinateGetter _ #x.
	cursorGetter _ #resizeRight! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985904!
                       initializeTop
	selector _ #windowTop:.
	coordinateGetter _ #y.
	cursorGetter _ #resizeTop! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985910!
                             initializeTopLeft
	selector _ #windowTopLeft:.
	coordinateGetter _ #yourself.
	cursorGetter _ #resizeTopLeft! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985916!
          initializeTopRight
	selector _ #windowTopRight:.
	coordinateGetter _ #yourself.
	cursorGetter _ #resizeTopRight! !
!WindowEdgeAdjustingMorph methodsFor: 'geometry testing' stamp: 'jmv 12/13/2011 14:46' prior: 16985961!
     containsPoint: aPoint
	| sensitiveBorder |
	(bounds containsPoint: aPoint) ifFalse: [ ^false ].
	sensitiveBorder _ 4.
	selector caseOf: {
		[ #windowTopLeft: ] -> [ ^ aPoint x - bounds left < sensitiveBorder or: [ aPoint y - bounds top < sensitiveBorder ]].
		[ #windowTopRight: ] -> [ ^ bounds right - aPoint x <= sensitiveBorder or: [ aPoint y - bounds top < sensitiveBorder ]].
		[ #windowBottomLeft: ] -> [ ^ aPoint x - bounds left < sensitiveBorder or: [ bounds bottom - aPoint y <= sensitiveBorder ]].
		[ #windowBottomRight: ] -> [ ^ bounds right - aPoint x <= sensitiveBorder or: [ bounds bottom - aPoint y <= sensitiveBorder ]].
	}
	otherwise: [
		"all the morph is sensitive for horizontal and vertical (i.e. non corner) instances."
		^true ]! !

WindowEdgeAdjustingMorph class removeSelector: #bottom!

WindowEdgeAdjustingMorph class removeSelector: #bottom!

WindowEdgeAdjustingMorph class removeSelector: #bottomLeft!

WindowEdgeAdjustingMorph class removeSelector: #bottomLeft!

WindowEdgeAdjustingMorph class removeSelector: #bottomRight!

WindowEdgeAdjustingMorph class removeSelector: #bottomRight!

WindowEdgeAdjustingMorph class removeSelector: #left!

WindowEdgeAdjustingMorph class removeSelector: #left!

WindowEdgeAdjustingMorph class removeSelector: #right!

WindowEdgeAdjustingMorph class removeSelector: #right!

WindowEdgeAdjustingMorph class removeSelector: #top!

WindowEdgeAdjustingMorph class removeSelector: #top!

WindowEdgeAdjustingMorph class removeSelector: #topLeft!

WindowEdgeAdjustingMorph class removeSelector: #topLeft!

WindowEdgeAdjustingMorph class removeSelector: #topRight!

WindowEdgeAdjustingMorph class removeSelector: #topRight!

SystemWindow removeSelector: #bottom:!

SystemWindow removeSelector: #bottom:!

SystemWindow removeSelector: #bottomLeft:!

SystemWindow removeSelector: #bottomLeft:!

SystemWindow removeSelector: #bottomRight:!

SystemWindow removeSelector: #bottomRight:!

SystemWindow removeSelector: #left:!

SystemWindow removeSelector: #left:!

SystemWindow removeSelector: #right:!

SystemWindow removeSelector: #right:!

SystemWindow removeSelector: #top:!

SystemWindow removeSelector: #top:!

SystemWindow removeSelector: #topLeft:!

SystemWindow removeSelector: #topLeft:!

SystemWindow removeSelector: #topRight:!

SystemWindow removeSelector: #topRight:!

Morph removeSelector: #initPosExtent!

Morph removeSelector: #initPosExtent!

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4203-positionSettersAndFixes-jmv.6.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 3:03:39 pm'!
!InnerTextMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/13/2011 23:05'!
               addMorphFrontFromWorldPosition: aMorph
	"Overridden for more specific re-layout and positioning"
	| positionInWorld |
	positionInWorld _ aMorph morphPosition.
	^self anchorMorph: aMorph at: positionInWorld! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/13/2011 20:42'!
               positionAt: aPoint relativeTo: aMenuItem
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| i yOffset sub delta |
	self adjustSubmorphsLayout.
	i _ 0.
	yOffset _ 0.
	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]
		whileFalse: [ yOffset _ yOffset + sub morphHeight ].

	self morphPosition: aPoint - (2 @ (yOffset + 8)).

	"If it doesn't fit, show it to the left, not to the right of the hand."
	bounds right > owner world bounds right
		ifTrue: [
			self moveRight: aPoint x + 1].

	"Make sure that the menu fits in the world."
	delta _ bounds amountToTranslateWithin:
		(owner world bounds withHeight: ((owner world bounds height - 18) max: (ActiveHand morphPosition y) + 1)).
	delta = (0 @ 0) ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 23:36'!
                             openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| h w |
	aWorld addMorph: self.
	w _ ((labelMorph measureContents x max: subLabelMorph measureContents x) max: progress morphWidth) + 8.
	h _ labelMorph morphHeight + subLabelMorph morphHeight + progress morphHeight + 10.
	self bounds: (0@0 extent: w@h).
	labelMorph fitContents.
	subLabelMorph fitContents.
	self layoutSubmorphs.
	self align: self fullBounds center with: Display boundingBox center.
	aWorld startSteppingSubmorphsOf: self.! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 12/13/2011 21:12' prior: 16897989!
             addHalo: evt
	| halo prospectiveHaloClass |
	prospectiveHaloClass _ Smalltalk at: self haloClass ifAbsent: [HaloMorph].
	halo _ prospectiveHaloClass new.
	halo popUpFor: self event: evt.
	halo bounds: self worldBoundsForHalo.
	^halo! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 23:12' prior: 50332064!
 openInWorld: aWorld
	"Add this morph to the requested World."
	aWorld addMorph: self.
	aWorld startSteppingSubmorphsOf: self! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/13/2011 23:05' prior: 50332108!
       addMorphFrontFromWorldPosition: aMorph
	| positionInWorld |
	positionInWorld _ aMorph morphPosition.
	self addMorphFront: aMorph.
	aMorph morphPosition: positionInWorld! !
!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 12/14/2011 16:48' prior: 50332122!
                    setCompleter: anAutoCompleter position: aPoint 
	completer _ anAutoCompleter.
	self resetMenu.
	self openInWorld.
	self morphPositionInOwner: aPoint.! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/13/2011 19:44' prior: 50333987!
                  addToWorld: world near: box
	| goodLocation |
	goodLocation _ self bestPositionNear: box inWorld: world.
	world allMorphsDo:
		[:p | (p isMemberOf: ColorPickerMorph) ifTrue:
		[(p ~~ self and: [p owner notNil and: [p target == target]]) ifTrue:
			[(p selector == selector and: [p argument == argument])
				ifTrue: [^ p comeToFront  "uncover existing picker"]
				ifFalse: ["place second picker relative to first"
						goodLocation _ self bestPositionNear: p bounds inWorld: world]]]].
	world addMorphFront: self.
	self morphPositionInOwner: goodLocation.
	self redrawNeeded! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/13/2011 19:44' prior: 50334008!
       indicateColorUnderMouse
	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."

	| pt |
	self pickColorAt: (pt _ World activeHand morphPosition ).
	isModal ifTrue: [
		self world activeHand morphPositionInOwner: pt.
		self world displayWorldSafely; runStepMethods].
	^ selectedColor	! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/13/2011 19:45' prior: 50334024!
trackColorUnderMouse
	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."

	| pt |
	selectedColor _ originalColor.
	self trackColorAt: (pt _ World activeHand morphPosition ).
	isModal ifTrue: [
		self world activeHand morphPositionInOwner: pt.
		self world displayWorldSafely; runStepMethods.
		self modalBalloonHelpAtPoint: pt].
	^ selectedColor	! !
!ColorPickerMorph methodsFor: 'private' stamp: 'jmv 12/13/2011 19:44' prior: 50334049!
                            anchorAndRunModeless: aHand
	"If user clicks on the drag-dot of a modal picker,
	anchor it, and change to modeless operation."

	self initializeModal: false; originalColor: originalColor.  "reset as modeless"
	aHand flushEvents.  "Drop any events gathered during modal loop"
	aHand morphPositionInOwner: Sensor mousePoint; grabMorph: self.  "Slip into drag operation"
! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 4/10/2012 14:59' prior: 16852813!
            createAcceptButton
	"create the [accept] button"
	| result buttonColor theme |
	theme _ Theme current.
	theme useUniformColors
		ifTrue: [ buttonColor _ theme buttonColorFrom: theme defaultWindowColor ]
		ifFalse: [ buttonColor _ theme acceptButton].
	result _ PluggableButtonMorph new
		 model: self;
		 color: buttonColor;
		 label: 'Accept';
		 action: #acceptClicked.
	self addMorph: result.
	result bounds: (29@90 corner: 122@117).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 4/10/2012 14:59' prior: 16852830!
                              createCancelButton
	"create the [cancel] button"
	| result buttonColor theme |
	theme _ Theme current.
	theme useUniformColors
		ifTrue: [ buttonColor _ theme buttonColorFrom: theme defaultWindowColor ]
		ifFalse: [ buttonColor _ theme buttonColorFrom: theme cancelButton ].
	result _ PluggableButtonMorph new
		 model: self;
		 color: buttonColor;
		 label: 'Cancel';
		 action: #cancelClicked.
	self addMorph: result.
	result bounds: (149@90 corner: 242@117).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 22:52' prior: 16852848!
    createQueryTextMorph: queryString 
	"create the queryTextMorph"
	| result |
	result _ StringMorph new contents: queryString.
	result lock.
	self addMorph: result.
	result bounds: ( 30@7 corner: 269@22).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 22:52' prior: 16852858!
       createTextPaneExtent: answerExtent acceptBoolean: acceptBoolean
	"create the textPane"
	| result |
	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval.
	result extent: answerExtent.
	result borderWidth: 1; borderColor: Color lightGray.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	self addMorph: result.
	result bounds: (14@25 corner: 257@84).
	^ result! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 12/13/2011 21:12' prior: 50332201!
                          popUpFor: aMorph event: evt
	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."

	| hand anEvent |
	self flag: #workAround.	"We should really have some event/hand here..."
	anEvent _ evt
				ifNil: [
					hand _ aMorph world activeHand.
					hand ifNil: [ hand _ aMorph world firstHand ]. 
					hand lastEvent ]
				ifNotNil: [
					hand _ evt hand.
					evt ].
	hand halo: self.
	hand world addMorphFront: self.
	self target: aMorph.
	positionOffset _ anEvent eventPosition - aMorph morphPosition.
	self startStepping! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/31/2011 00:15' prior: 50332264!
                      addHandle: handleSpec on: eventName send: selector to: recipient 
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint iconName colorToUse icon |
	aPoint := self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle bounds: (Rectangle center: aPoint extent: HandleSize asPoint).
	(iconName _ handleSpec iconSymbol) ifNotNil: [
			| form |
			form _ Icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon.
				icon morphPositionInOwner: 0@0 ]].
	handle 
		on: #mouseUp
		send: #endInteraction
		to: self.
	handle 
		on: eventName
		send: selector
		to: recipient.
	handle 
		setBalloonText: (target balloonHelpTextForHandle: handle).
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/13/2011 20:24' prior: 50335286!
                 addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w nameBackground |
	w _ self world ifNil: [ target world ].
	nameBackground _ RectangleMorph new
		borderWidth: 0;
		color: (Color lightBlue alpha: 0.9).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color magenta.
	self addMorph: nameBackground.
	self addMorph: nameMorph.
	namePosition _ outerRectangle bottomCenter - ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph morphPosition: (namePosition min: w viewBox bottomRight - nameMorph extent y + 5).
	nameBackground bounds: (nameMorph bounds outsetBy: 2).
	^nameMorph! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/13/2011 20:28' prior: 50332534!
     attachMorph: m
	"Position the center of the given morph under this hand, then grab it.
	This method is used to grab far away or newly created morphs."
	| delta |
	self releaseMouseFocus. "Break focus"
	self addMorphBack: m.
	delta _ m bounds extent // 2.
	m morphPosition: (self morphPosition - delta).
	m formerPosition: m morphPosition.
	targetOffset _ m morphPosition - self morphPosition.! !
!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 20:29' prior: 50332712!
                        popUpForHand: aHand
	"Pop up the receiver as balloon help for the given hand"

	| xcess |
	(contents isNil or: [ contents isEmpty ]) ifTrue: [ ^self ].
	aHand world addMorphFront: self.
	self morphPosition: aHand morphPosition + (-6@20).
	xcess _ bounds right - aHand world bounds right.
	xcess > 0 ifTrue: [
		self morphPosition: self morphPosition - (xcess@0) ].
	aHand balloonHelp: self! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 18:14' prior: 50335387!
                     adjustExtent
	"And reposition submorphs"
	| w p0 h y |
	"make all items wide, so selection indicator is wide too"
	w _ self desiredWidth.
	p0 _ bounds topLeft..
	y _ 0.
	self submorphsDo: [ :m |
		h _ m morphHeight.
		m bounds: (p0 + (0@y) extent: w@h).
		y _ y + h ].
	self extent: w@y! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 12/13/2011 20:30' prior: 50332838!
        contents: aString withMarkers: aBool inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	self contentString: nil.	"get rid of old"
	aBool ifFalse: [^super contents: aString].
	self removeAllMorphs.	"get rid of old markers if updating"
	self hasIcon ifTrue: [ self icon: nil ].
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	self contentString: aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker.
	marker morphPosition: bounds left @ (bounds top + 2).! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/13/2011 23:07' prior: 50332923!
                        popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem
	"Present this menu at the given point under control of the given hand."

	| delta tryToPlace selectedOffset |
	hand world startSteppingSubmorphsOf: self.
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition - self morphPosition.
	sourceItem owner owner addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self fullBounds amountToTranslateWithin: sourceItem world bounds.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPoint first value: false;
		value: rightOrLeftPoint last - (self width @ 0) value: false;
		value: rightOrLeftPoint first value: true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/13/2011 20:42' prior: 16887672!
      popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [:m | m isKindOf: UpdatingMenuItemMorph]) 
		do: [:m | m updateContents].
	aWorld addMorphFront: self.
	self 
		positionAt: aPoint
		relativeTo: (selectedItem ifNil: [self items first]).
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [hand newKeyboardFocus: self].
	evt := hand lastEvent.
	(evt isKeyboard or: [evt isMouse and: [evt anyButtonPressed not]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt]! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 12/13/2011 22:55' prior: 50332995!
displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m isKindOf: MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Color veryDarkGray.
		self addMorphBack: feedbackMorph lock.
		feedbackMorph morphPosition: self morphPosition - (0@20).
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self submorphs last delete.
		self removeProperty: #feedbackMorph ].
	matches size = 1 ifTrue: [
		self
			selectItem: matches first
			event: evt ].! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 12/13/2011 23:34' prior: 50333114!
  informUserAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	| w titleString |

	titleString _ titleMorph submorphs first.
	self visible: false.
	w _ ActiveWorld.
	aBlock value: [ :string |
		self visible ifFalse: [
			w addMorph: self centeredNear: aPoint.
			self visible: true].
		titleString contents: string.
		titleMorph morphWidth: titleString width + 8.
		self morphPosition: w activeHand morphPosition.
		self adjustSubmorphsLayout.
		self redrawNeeded.
		w displayWorld		 "show myself"
	]. 
	self delete.
	w displayWorld! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 12/13/2011 23:36' prior: 50333259!
                            placeEmbeddedObject: anchoredFormOrMorph

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	(anchoredFormOrMorph is: #Morph)
		ifTrue: [
			anchoredFormOrMorph morphPosition:
				((destX - anchoredFormOrMorph morphWidth)@
				(lineY+ line baseline - anchoredFormOrMorph morphHeight)) -
					paraTopLeft ]
		ifFalse: [
			destY _ lineY.
			runX _ destX.
			anchoredFormOrMorph 
				displayOn: canvas grafPort destForm 
				at: destX - anchoredFormOrMorph morphWidth @ (destY + line baseline - anchoredFormOrMorph morphHeight)
				clippingBox: canvas grafPort clipRect
				rule: Form blend
				fillColor: nil ].
	^ true! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 12/13/2011 22:53' prior: 50333473!
       addMorph: aMorph centeredNear: aPoint
	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."

	| trialRect delta |
	trialRect _ Rectangle center: aPoint extent: aMorph fullBounds extent.
	delta _ trialRect amountToTranslateWithin: bounds.
	self addMorph: aMorph.
	aMorph morphPosition: trialRect origin + delta.! !
!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 12/13/2011 23:56' prior: 50333499!
                      addToScroller: aMorph

	scroller addMorph: aMorph.
	aMorph morphPosition: scroller morphPosition! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/31/2011 00:18' prior: 16915261!
hHideScrollBar
	hScrollBar hide.
	scroller adjustExtent! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/31/2011 00:18' prior: 16915291!
         hShowScrollBar

	hScrollBar show.
	scroller adjustExtent! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/31/2011 00:19' prior: 16915367!
        vHideScrollBar
	scrollBar hide.
	scroller adjustExtent! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/31/2011 00:19' prior: 16915391!
          vShowScrollBar

	scrollBar show.
	scroller adjustExtent! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/13/2011 23:58' prior: 50333761!
                  updateHandles
	| newVert oldVert midPts nextVertIx tweens |
	smoothCurve
		ifTrue: [
			handles first referencePosition: vertices first.
			handles last referencePosition: vertices last.
			midPts _ OrderedCollection new.
			nextVertIx _ 2.
			tweens _ OrderedCollection new.
			self
				lineSegmentsDo: [:p1 :p2 | 
					tweens addLast: p2 asIntegerPoint.
					p2 = (vertices atWrap: nextVertIx)
						ifTrue: ["Found endPoint."
							midPts addLast: (tweens at: tweens size // 2)
									+ (tweens at: tweens size + 1 // 2) // 2.
							tweens _ OrderedCollection new.
							nextVertIx _ nextVertIx + 1]].
			midPts withIndexDo: [:midPt :vertIndex |
				(closed or: [vertIndex < vertices size]) ifTrue: [
					newVert _ handles at: vertIndex * 2.
					newVert referencePosition: midPt ]]]
		ifFalse: [
			vertices
				withIndexDo: [ :vertPt :vertIndex | 
					oldVert _ handles at: vertIndex * 2 - 1.
					oldVert referencePosition: vertPt.
					(closed or: [vertIndex < vertices size])
						ifTrue: [
							newVert _ handles at: vertIndex * 2.
							newVert morphPosition: vertPt
									+ (vertices atWrap: vertIndex + 1) - newVert bounds extent // 2 + (1 @ -1)]]]! !
!ProgressMorph methodsFor: 'accessing' stamp: 'jmv 12/13/2011 23:20' prior: 16923490!
                label: aString subLabel: otherString
	labelMorph contents: aString.
	subLabelMorph contents: otherString! !
!ProgressMorph class methodsFor: 'example' stamp: 'jmv 12/13/2011 23:38' prior: 16923548!
                          example
	"
	ProgressMorph example
	"
	| progress |
	progress _ ProgressMorph label: 'Test progress' subLabel: 'this is the subheading'.
	progress openInWorld.
	[
		100 timesRepeat: [
			(Delay forMilliseconds: 20) wait.
			progress incrDone: 0.01 ].
		progress delete] fork! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 16965176!
                 createCloseBox
	^ (PluggableButtonMorph model: self action: #closeBoxHit)
		icon: Theme current closeIcon;
		setBalloonText: 'close this window'! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 16965184!
                  createCollapseBox
	^(PluggableButtonMorph model: self action: #collapseOrExpand)
		icon: Theme current collapseIcon;
		setBalloonText: 'collapse this window'! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 16965193!
     createExpandBox
	^ (PluggableButtonMorph model: self action: #expandBoxHit)
		icon: Theme current expandIcon;
		setBalloonText: 'expand to full screen'! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 16965201!
           createMenuBox
	^ (PluggableButtonMorph model: self action: #offerWindowMenu)
		icon: Theme current windowMenuIcon;
		setBalloonText: 'window menu'! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 50334139!
                initializeLabelArea
	"Initialize the label area (titlebar) for the window."

	| spacing box |
	spacing _ self boxExtent x + 2.

	box _ self createCloseBox.
	self addMorph: box.
	box morphPosition: 2@2.
	box extent: self boxExtent.

	box _ self createCollapseBox.
	self addMorph: box.
	box morphPosition: spacing+2@2.
	box extent: self boxExtent.

	box _ self createExpandBox.
	self addMorph: box.
	box morphPosition: spacing*2+2@2.
	box extent: self boxExtent.

	box _ self createMenuBox.
	self addMorph: box.
	box morphPosition: spacing*3+2@2.
	box extent: self boxExtent.! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 12/13/2011 21:06' prior: 16965454!
         openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	aWorld addMorph: self.
	self bounds: (RealEstateAgent initialFrameFor: self world: aWorld).
	self activate.
	aWorld startSteppingSubmorphsOf: self.! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 12/13/2011 21:07' prior: 50334154!
                       openInWorld: aWorld extent: extent
	"This msg and its callees result in the window being activeOnlyOnTop"
	aWorld addMorph: self.
	self morphPosition: (RealEstateAgent initialFrameFor: self world: aWorld) topLeft; extent: extent.
	self activate.
	aWorld startSteppingSubmorphsOf: self.! !

SystemWindow removeSelector: #openAsIsIn:!

SystemWindow removeSelector: #openAsIsIn:!

ProgressMorph removeSelector: #setupMorphs!

ProgressMorph removeSelector: #setupMorphs!

MenuMorph removeSelector: #positionAt:relativeTo:inWorld:!

MenuMorph removeSelector: #positionAt:relativeTo:inWorld:!

InnerTextMorph removeSelector: #addMorphFront:fromWorldPosition:!

InnerTextMorph removeSelector: #addMorphFront:fromWorldPosition:!

Morph removeSelector: #addMorphFront:fromWorldPosition:!

Morph removeSelector: #addMorphFront:fromWorldPosition:!

Morph removeSelector: #privateBounds:!

Morph removeSelector: #privateBounds:!

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4204-FirstAddMorphThenPosition-jmv.5.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 3:14:11 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:43'!
                       morphExtent
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^ bounds extent! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:43'!
                             morphExtent: aPoint
"assume it is always in owner's coordinates!!"
	self flag: #jmvVer2.
	self basicExtent: aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:31'!
             validateNotSent
	"To be removed. Just to check consistency"

	self flag: #jmvVer2.
	Count ifNil: [ Count _ 0 ].
	Count _ Count + 1.
	Count < 10 ifTrue: [
		'-----False polymorphism. Should not be sent!!-----' print.
		thisContext printStack: 10 ]! !
!ImageMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:21'!
    morphExtent: aPoint
	"Do nothing; my extent is determined by my image Form."
! !
!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:27'!
         morphExtent: aPoint
	| newExtent |
	"Resist changing the extent if no wordwrap.. this should be checked."
	wrapFlag ifFalse: [ ^ self ].
	newExtent _ aPoint truncated max: self minimumExtent.
	
	"No change of wrap width"
	newExtent x = bounds extent x ifTrue: [ ^ self ].

	super morphExtent: newExtent.
	
	self resetParagraph.
	self editor recomputeSelection.	
	self updateFromParagraph.! !
!MagnifierMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:32'!
                  morphExtent: aPoint
	"Round to multiples of magnification"
	srcExtent _ (aPoint - (2 * borderWidth)) // magnification.
	^super morphExtent: self defaultExtent! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:32'!
                          morphExtent: aPoint

	self flag: #jmvVer2.
	bounds extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self validatePositionAndBounds.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PluggableButtonMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28'!
   morphExtent: aPoint
	super morphExtent: aPoint.
	magnifiedIcon _ nil.
	self redrawNeeded! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28'!
                         morphExtent: newExtent
	
	| minH minW |
	"Figure out the minimum width and height for this pane so that scrollbars will appear"
	minH _ Preferences scrollbarThickness * 2.
	minW _ minH.
	super morphExtent: (newExtent max: (minW@minH)).

	"Now reset widget sizes"
	scroller adjustExtent.
	self updateScrollBarsBounds.
	self setScrollDeltas! !
!LimitedHeightTextMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:27'!
                            morphExtent: aPoint
	maxHeight _ aPoint y.
	super morphExtent: aPoint.! !
!PolygonMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:21'!
                  morphExtent: newExtent 
	"Not really advisable, but we can preserve most of the geometry if we don't
	shrink things too small."
	| safeExtent center |
	center _ self referencePosition.
	safeExtent _ newExtent max: 20@20.
	self setVertices: (vertices collect:
		[:p | p - center * (safeExtent asFloatPoint / (bounds extent max: 1@1)) + center])! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/10/2012 15:10'!
     morphExtent: newExtent
	| newExtentToUse |
	newExtent = bounds extent ifTrue: [^ self].
	newExtentToUse _ bounds isWide
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = bounds extent ifTrue: [^ self].
	super morphExtent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!Sonogram methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:22'!
  morphExtent: newExtent
	super image: (Form extent: newExtent depth: Display depth).
	lastX _ -1.
	columnForm _ Form extent: (32//image depth)@(image height) depth: image depth.
	pixValMap _ ((1 to: 256) collect:
			[:i | columnForm pixelValueFor: (Color gray: (256-i)/255.0)])
		as: Bitmap.
! !
!StringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:26'!
                     setWidth: width

	self morphExtent: width @ (font ifNil: [StrikeFont default]) height! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28'!
   morphExtent: aPoint 
	"Set the receiver's extent to value provided. Respect my minimumExtent."

	| newExtent |
	newExtent _ self isCollapsed
		ifTrue: [aPoint]
		ifFalse: [aPoint max: self minimumExtent].
	newExtent = bounds extent ifTrue: [^ self].

	isCollapsed
		ifTrue: [super morphExtent: newExtent x @ (self labelHeight + 2)]
		ifFalse: [super morphExtent: newExtent].
	isCollapsed
		ifTrue: [collapsedFrame _ bounds]
		ifFalse: [fullFrame _ bounds]! !
!TranscriptMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28'!
              morphExtent: aPoint
	super morphExtent: aPoint.
	(form isNil or: [ form extent ~= aPoint ]) ifTrue: [
		form _ Form extent: aPoint depth: Display depth ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:34' prior: 50334999!
                      bounds: newBounds
	| oldExtent newExtent |

	"remove senders and implementors"
	self flag: #jmvVer2.
		
	oldExtent _ bounds extent.
	newExtent _ newBounds extent.
	"Moving stuff around is most likely the most common operation.
	Optimize it"
	oldExtent = newExtent ifTrue: [
		^self morphPosition: newBounds topLeft ].
	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[
		"We're growing. First move then resize."
		self morphPosition: newBounds topLeft; morphExtent: newExtent.
	] ifFalse: [
		"We're shrinking. First resize then move."
		self morphExtent: newExtent; morphPosition: newBounds topLeft.
	].! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:43' prior: 50335022!
                     extent
"Needs to be turned into extentInOwner and extentInWorld"
"or better yet into morphExtent:, and assume it is always in owner's coordinates!!"
	self flag: #jmvVer2.
	self validateNotSent.
	^ bounds extent! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 14:57' prior: 50335032!
                             extent: aPoint
"Needs to be turned into extentInOwner: and extentInWorld:"
"or better yet into morphExtent:, and assume it is always in owner's coordinates!!"
"(when deleting, delete all inheritance!!)"
	self flag: #jmvVer2.
	self validateNotSent.
	self basicExtent: aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:38' prior: 50335053!
                              height
	self flag: #jmvVer2.
	"False polymorphism elimination: turn senders into morphHeight"
	self validateNotSent.
	^ bounds height! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:38' prior: 50335061!
          height: aNumber
	self flag: #jmvVer2.
	"False polymorphism elimination: turn senders into morphHeight:"
	self validateNotSent.
	self morphExtent: bounds width@aNumber asInteger.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:25' prior: 50334583!
                             morphHeight: aNumber

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self morphExtent: bounds width@aNumber asInteger.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:38' prior: 50334603!
 morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = bounds topLeft ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

	self validateOwnerNotNil.


"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:38' prior: 50334657!
                morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
"Quizas no un null change del todo... Es posible que bounds y position se desincronicen, al cambiar el owner (o cualquier owner en el medio). Todo esto es fulerote. espero sacarlo pronto!!"
		self privateFullMoveBy: newPositionInWorld - bounds topLeft.
		^ self ].		"Null change"


	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:25' prior: 50334747!
                         morphWidth: aNumber
"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self morphExtent: aNumber asInteger@bounds height.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:36' prior: 50335159!
  width

	self flag: #jmvVer2.
	"False polymorphism elimination: turn senders into morphWidth"
	self validateNotSent.
	^ bounds width! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:37' prior: 50335167!
            width: aNumber

	self flag: #jmvVer2.
	"False polymorphism elimination: turn senders into morphWidth:"
	self validateNotSent.
	self morphExtent: aNumber asInteger@bounds height! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 12/16/2011 10:25' prior: 16898966!
                           resizeMorph: evt 
	| handle |
	handle := HandleMorph new 
				forEachPointDo: [:newPoint | self morphExtent: newPoint - bounds topLeft].
	evt hand attachMorph: handle.
	handle startStepping! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:27' prior: 50336147!
                              createTextPaneExtent: answerExtent acceptBoolean: acceptBoolean
	"create the textPane"
	| result |
	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval.
	result morphExtent: answerExtent.
	result borderWidth: 1; borderColor: Color lightGray.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	self addMorph: result.
	result bounds: (14@25 corner: 257@84).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:23' prior: 16852887!
   initialize

	super initialize.
	self morphExtent: 271@121.
	responseUponCancel := ''
	! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:36' prior: 50336226!
                      addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w nameBackground |
	w _ self world ifNil: [ target world ].
	nameBackground _ RectangleMorph new
		borderWidth: 0;
		color: (Color lightBlue alpha: 0.9).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color magenta.
	self addMorph: nameBackground.
	self addMorph: nameMorph.
	namePosition _ outerRectangle bottomCenter - ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph morphPosition: (namePosition min: w viewBox bottomRight - nameMorph morphExtent y + 5).
	nameBackground bounds: (nameMorph bounds outsetBy: 2).
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:41' prior: 50335326!
          doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target bounds topLeft.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target morphExtent: newExtent.
	growHandle morphPosition: evt eventPosition - (growHandle extent // 2).
	self someSubmorphPositionOrExtentChanged
! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:43' prior: 50335347!
                            doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Color lightBlue]
		ifFalse: [rotHandle color: Color blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPosition: evt eventPosition - (rotHandle morphExtent // 2).
	self someSubmorphPositionOrExtentChanged! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:44' prior: 16864328!
                         strokeGrow: evt with: growHandle
	| dir |
	evt keyValue = 28 ifTrue:[dir _ -1@0].
	evt keyValue = 29 ifTrue:[dir _ 1@0].
	evt keyValue = 30 ifTrue:[dir _ 0@-1].
	evt keyValue = 31 ifTrue:[dir _ 0@1].
	dir ifNil:[^self].
	evt hand obtainHalo: self.
	evt hand newKeyboardFocus: growHandle.
	target morphExtent: target morphExtent + dir.
	self someSubmorphPositionOrExtentChanged.! !
!HandleMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:23' prior: 16865798!
          initialize
	"initialize the state of the receiver"
	super initialize.
	self morphExtent: 12 @ 12! !
!HoverHelpMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:23' prior: 16867385!
     contents: aString
	contents _ aString.
	paragraph _ Paragraph new.
	paragraph
		setModel: (TextModel withText: contents asText);
		extentForComposing: 9999999@9999999.
	paragraph composeAll.
	self morphExtent: paragraph usedExtent + 8! !
!ImageMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:33' prior: 16867769!
extent: aPoint
	"Do nothing; my extent is determined by my image Form."

	self validateNotSent.! !
!InnerPluggableMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:24' prior: 16869736!
  adjustExtent

	self submorphBounds ifNotNil: [ :r |
		self morphExtent: r bottomRight - bounds topLeft ]! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:24' prior: 50336284!
                  adjustExtent
	"And reposition submorphs"
	| w p0 h y |
	"make all items wide, so selection indicator is wide too"
	w _ self desiredWidth.
	p0 _ bounds topLeft..
	y _ 0.
	self submorphsDo: [ :m |
		h _ m morphHeight.
		m bounds: (p0 + (0@y) extent: w@h).
		y _ y + h ].
	self morphExtent: w@y! !
!InnerListMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:24' prior: 16869701!
   adjustExtent
	"Adjust our height to match the underlying list,
	but make it wider if neccesary to fill the available width in our PluggableListMorph
	(this is needed to make the selection indicator no narrower than the list)"
	self morphExtent:
		self desiredWidth @ ((listItems size max: 1) * font height)
! !
!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:24' prior: 16870247!
                   adjustExtent
	"This is just a suggestion. If we do wordwrap, the width will be honored.
	But the height is whatever is appropriate for the contents!!"
	self morphExtent: owner viewableBounds extent! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:24' prior: 16870331!
  extentForComposing
	self flag: #jmvVer2.	"like #extent ..."
	^wrapFlag
		ifTrue: [ bounds width @ 9999999 ]
		ifFalse: [ 9999999@9999999 ]! !
!MagnifierMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:25' prior: 16885073!
                      initialize
	super initialize.
	trackPointer _ true.
	magnification _ 2.
	lastPos _ self sourcePoint.
	self morphExtent: 128@128! !
!MagnifierMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28' prior: 16885080!
       borderWidth: anInteger
	"Grow outwards preserving innerBounds"
	| c |  
	c _ self referencePosition.
	super borderWidth: anInteger.
	super morphExtent: self defaultExtent.
	self referencePosition: c.! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 12/16/2011 10:25' prior: 16885148!
   chooseMagnification
	| result |
	result _ (SelectionMenu selections: #(1.5 2 4 8))
		startUpWithCaption: 'Choose magnification
(currently ', magnification printString, ')'.
	(result == nil or: [ result = magnification ]) ifTrue: [ ^ self ].
	magnification _ result.
	self morphExtent: bounds extent. "round to new magnification"
	self redrawNeeded. "redraw even if extent wasn't changed"! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 12/16/2011 10:28' prior: 16885187!
 magnification: aNumber
	| c |  
	magnification _ aNumber min: 8 max: 0.5.
	magnification _ magnification roundTo:
		(magnification < 3 ifTrue: [0.5] ifFalse: [1]).
	srcExtent _ srcExtent min: (512@512) // magnification. "to prevent accidents"
	c _ self referencePosition.
	super morphExtent: self defaultExtent.
	self referencePosition: c.! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:25' prior: 50335579!
                         adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p tl |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: (
			(each respondsTo: #minItemWidth)
				ifTrue: [each minItemWidth]
				ifFalse: [each morphWidth])].

	w _ w + 4.
	tl _ bounds topLeft.
	p _ tl + 5.
	submorphs do: [ :m |
		m morphWidth: w.
		m morphPosition: p.
		p _ m bounds bottomLeft +(0@1) ].
	
	self morphExtent: submorphs last bounds bottomRight - tl + 5! !
!MinimalStringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:25' prior: 16894905!
           fitContents

	| newBounds boundsChanged |
	newBounds _ self measureContents.
	boundsChanged _ bounds extent ~= newBounds.
	self morphExtent: newBounds.		"default short-circuits if bounds not changed"
	boundsChanged ifFalse: [ self redrawNeeded ]! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:25' prior: 16906283!
            fitContents

	| newBounds boundsChanged |
	newBounds _ self measureContents.
	boundsChanged _ bounds extent ~= newBounds.
	self morphExtent: newBounds.		"default short-circuits if bounds not changed"
	boundsChanged ifFalse: [ self redrawNeeded ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:32' prior: 50335632!
                   extent: aPoint

	self validateNotSent.
	self flag: #jmvVer2.
	bounds extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self validatePositionAndBounds.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:25' prior: 16913734!
                           initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	getStateSelector _ nil.
	actionSelector _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	actWhen _ #buttonUp.
	self morphExtent: 20 @ 15! !
!PolygonMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:32' prior: 16916744!
                 extent: newExtent 
	"Not really advisable, but we can preserve most of the geometry if we don't
	shrink things too small."
	| safeExtent center |
	self validateNotSent.
	center _ self referencePosition.
	safeExtent _ newExtent max: 20@20.
	self setVertices: (vertices collect:
		[:p | p - center * (safeExtent asFloatPoint / (bounds extent max: 1@1)) + center])! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:39' prior: 16923517!
                        initialize
	super initialize.
	self separation: 0.
	labelMorph _ StringMorph contents: '' font: AbstractFont default.
	subLabelMorph _ StringMorph contents: '' font: AbstractFont default.
	progress_ ProgressBarMorph new.
	progress morphExtent: 200 @ 15.
	self addMorph: labelMorph.
	self addMorph: subLabelMorph.
	self addMorph: progress fixedHeight: 15.! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:33' prior: 50335749!
         expandSlider
	"Compute the new size of the slider (use the old sliderThickness as a minimum)."
	| r |
	r _ self totalSliderArea.
	slider morphExtent: (bounds isWide
		ifTrue: [((r width * interval) asInteger max: 7) @ slider morphHeight]
		ifFalse: [slider morphWidth @ ((r height * interval) asInteger max: 7)])! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/10/2012 15:11' prior: 16934926!
                    extent: newExtent
	| newExtentToUse |
	self validateNotSent.
	newExtent = bounds extent ifTrue: [^ self].
	newExtentToUse _ bounds isWide
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = bounds extent ifTrue: [^ self].
	super extent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!SketchMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:26' prior: 16939955!
                            initializeWith: aForm

	super initialize.
	originalForm _ aForm.
	self morphExtent: originalForm extent.
! !
!Sonogram methodsFor: 'all' stamp: 'jmv 12/16/2011 10:26' prior: 16947359!
        extent: extent minVal: min maxVal: max scrollDelta: d
	minVal _ min.
	maxVal _ max.
	scrollDelta _ d.
	self morphExtent: extent.

" try following with scrolldelta = 1, 20, 200
	| s data |
	s _ Sonogram new extent: 200@50
				minVal: 0.0 maxVal: 1.0 scrollDelta: 20.
	World addMorph: s.
	data _ (1 to: 133) collect: [:i | 0.0].
	1 to: 300 do:
		[:i | data at: (i\\133)+1 put: 1.0.
		s plotColumn: data.
		data at: (i\\133)+1 put: 0.0.
		World doOneCycleNow].
	s delete	
"! !
!Sonogram methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:33' prior: 16947407!
                      extent: newExtent
	self validateNotSent.
	super image: (Form extent: newExtent depth: Display depth).
	lastX _ -1.
	columnForm _ Form extent: (32//image depth)@(image height) depth: image depth.
	pixValMap _ ((1 to: 256) collect:
			[ :i | columnForm pixelValueFor: (Color gray: (256-i)/255.0)])
		as: Bitmap.
! !
!StringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:26' prior: 16957368!
                  fitContents

	| newBounds boundsChanged |
	newBounds _ self measureContents.
	boundsChanged _ bounds extent ~= newBounds.
	self morphExtent: newBounds.		"default short-circuits if bounds not changed"
	boundsChanged ifFalse: [self redrawNeeded]! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 12/16/2011 10:48' prior: 50334108!
                      makeMeVisible 

	self world morphExtent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self isCollapsed
		ifTrue: [ self morphPosition: (RealEstateAgent assignCollapsePointFor: self)]
		ifFalse: [ self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: bounds extent world: self world) topLeft].

! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:26' prior: 50335762!
                    initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	isCollapsed _ false.
	
	self wantsLabel ifTrue: [self initializeLabelArea].
	self morphExtent: 300 @ 200.
	updatablePanes _ #().

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorph: m ].

	"by default"
	self beColumn! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:35' prior: 50336599!
                  initializeLabelArea
	"Initialize the label area (titlebar) for the window."

	| spacing box |
	spacing _ self boxExtent x + 2.

	box _ self createCloseBox.
	self addMorph: box.
	box morphPosition: 2@2.
	box morphExtent: self boxExtent.

	box _ self createCollapseBox.
	self addMorph: box.
	box morphPosition: spacing+2@2.
	box morphExtent: self boxExtent.

	box _ self createExpandBox.
	self addMorph: box.
	box morphPosition: spacing*2+2@2.
	box morphExtent: self boxExtent.

	box _ self createMenuBox.
	self addMorph: box.
	box morphPosition: spacing*3+2@2.
	box morphExtent: self boxExtent.! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 12/16/2011 10:41' prior: 50336631!
                     openInWorld: aWorld extent: extent
	"This msg and its callees result in the window being activeOnlyOnTop"
	aWorld addMorph: self.
	self morphPosition: (RealEstateAgent initialFrameFor: self world: aWorld) topLeft; morphExtent: extent.
	self activate.
	aWorld startSteppingSubmorphsOf: self.! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 12/16/2011 10:26' prior: 16969050!
                              buildMorphicWindow
	"TestRunner new openAsMorph"

	self layoutMorph
		addMorph: self buildUpperControls proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.75.
	self setLabel: 'SUnit Test Runner'.
	self refreshWindow.
	self morphExtent: 460 @ 400! !

FillInTheBlankMorph removeSelector: #morphExtent:!

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4205-extentFalsePolymorphism-jmv.4.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 3:16:49 pm'!
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/16/2011 15:24' prior: 50331909!
                               aboutToBeGrabbedBy: aHand
	"The receiver is being grabbed by a hand.
	Perform necessary adjustments (if any) and return the actual morph
	that should be added to the hand."

	^self "Grab me"! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/16/2011 15:23' prior: 16896895!
        justDroppedInto: aMorph event: anEvent 
	"This message is sent to a dropped morph after it has been dropped on -- and been accepted by -- a drop-sensitive morph"

	aMorph activateWindow.
	self isInWorld  ifTrue: [
		self world startSteppingSubmorphsOf: self ].
	"Note an unhappy inefficiency here:  the startStepping... call will often have already been called in the sequence leading up to entry to this method, but unfortunately the isPartsDonor: call often will not have already happened, with the result that the startStepping... call will not have resulted in the startage of the steppage."! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/16/2011 15:22' prior: 16896924!
                   rejectDropMorphEvent: evt
	"The receiver has been rejected, and must be put back somewhere. 
	Just keep it in the hand"

	^evt hand grabMorph: self! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/16/2011 14:58' prior: 16899514!
                removeAllMorphs
	| oldMorphs |
	submorphs isEmpty ifTrue: [ ^self ].
	self redrawNeeded.
	submorphs do: [ :m |
		m privateOwner: nil ].
	oldMorphs _ submorphs.
	submorphs _ #().
	oldMorphs do: [ :m |
		self removedMorph: m ].
	self someSubmorphPositionOrExtentChanged! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/16/2011 15:27' prior: 16899529!
                        removeAllMorphsIn: aCollection
	"greatly speeds up the removal of *lots* of submorphs"
	| set |
	aCollection isEmpty ifTrue: [ ^self ].
	set _ IdentitySet new: aCollection size * 4 // 3.
	aCollection do: [ :each | each owner == self ifTrue: [ set add: each ]].
	set isEmpty ifTrue: [ ^self ].
	self redrawNeeded.
	set do: [ :m | m privateOwner: nil ].
	submorphs _ submorphs reject: [ :each | set includes: each].
	set do: [ :m | self removedMorph: m ].
	self someSubmorphPositionOrExtentChanged! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/16/2011 15:24' prior: 50336252!
                   attachMorph: m
	"Position the center of the given morph under this hand, then grab it.
	This method is used to grab far away or newly created morphs."
	| delta |
	self releaseMouseFocus. "Break focus"
	self addMorphBack: m.
	delta _ m bounds extent // 2.
	m morphPosition: (self morphPosition - delta).
	targetOffset _ m morphPosition - self morphPosition.! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/16/2011 15:20' prior: 50332550!
                              dropMorph: aMorph event: anEvent
	"Drop the given morph which was carried by the hand"
	| event |
	(anEvent isMouseUp and:[aMorph shouldDropOnMouseUp not]) ifTrue: [ ^self ].
	event _ DropEvent new setPosition: self morphPosition contents: aMorph hand: self.
	self sendEvent: event.
	event wasHandled ifFalse: [ aMorph rejectDropMorphEvent: event ].
	self mouseOverHandler processMouseOver: anEvent! !
!MenuItemMorph methodsFor: 'grabbing' stamp: 'jmv 12/16/2011 15:24' prior: 16887044!
                         aboutToBeGrabbedBy: aHand
	"Don't allow the receiver to act outside a Menu"
	| menu box |
	(owner notNil and: [ owner submorphs size = 1]) ifTrue:[
		"I am a lonely menuitem already; just grab my owner"
		owner stayUp.
		^owner aboutToBeGrabbedBy: aHand ].
	box _ bounds.
	menu _ MenuMorph new defaultTarget: nil.
	menu addMorphFront: self.
	menu bounds: box.
	menu stayUp.
	self isSelected: false.
	^menu! !

Morph removeSelector: #formerOwner!

Morph removeSelector: #formerOwner!

Morph removeSelector: #formerOwner:!

Morph removeSelector: #formerOwner:!

Morph removeSelector: #formerPosition!

Morph removeSelector: #formerPosition!

Morph removeSelector: #formerPosition:!

Morph removeSelector: #formerPosition:!

Morph removeSelector: #slideBackToFormerSituation:!

Morph removeSelector: #slideBackToFormerSituation:!

Morph removeSelector: #vanishAfterSlidingTo:event:!

Morph removeSelector: #vanishAfterSlidingTo:event:!

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4206-Cleanup-jmv.3.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1261] on 10 April 2012 at 3:33:56 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:41'!
                         validateExtentAndBounds
	"To be removed. Just to check consistency"
	| answer1 answer2 |
	self flag: #jmvVer2.

"	answer1 _ owner
		ifNotNil: [ owner externalizeDistanceToWorld: extent ]
		ifNil: [ extent ]."
	answer1 _ extent.
	answer2 _ bounds extent.

	answer1 = answer2 ifFalse: [
		#validateExtentAndBounds print.
		answer1 print.
		answer2 print.
		thisContext printStack: 10 ]! !
!Morph methodsFor: 'change reporting' stamp: 'jmv 12/16/2011 15:54' prior: 16896355!
        privateInvalidateMorph: aMorph
	"Private. Invalidate the given morph after adding or removing.
	This method is private because a) we're invalidating the morph 'remotely'
	and b) it forces a fullBounds computation which should not be necessary
	for a general morph c) the morph may or may not actually invalidate
	anything (if it's not in the world nothing will happen) and d) the entire
	mechanism should be rewritten."

	"Is this needed at all?"
	self flag: #jmvVer2.
	aMorph layoutSubmorphsAndComputeFullBounds.

	aMorph redrawNeeded! !
!Morph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 16:39' prior: 16896621!
                         drawErrorOn: aCanvas
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	w _ 10.
	r _ bounds truncated.
	aCanvas
		frameAndFillRectangle: r
		fillColor: Color red
		borderWidth: w
		borderColor: Color yellow.
	aCanvas line: r topLeft +w to: r bottomRight -w width: w color: Color yellow.
	aCanvas line: r topRight + (w negated @ w) to: r bottomLeft + (w @ w negated) width: w color: Color yellow.! !
!Morph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 16:51' prior: 16896670!
   fullDrawOn: aCanvas
	"Draw the full Morphic structure on the given Canvas"

	self visible ifFalse: [^ self].
	(aCanvas isVisible: self fullBounds) ifFalse:[^self].		"Needs fullBounds 'in owner' if inside a scroller"
	self isKnownFailing ifTrue: [^self drawErrorOn: aCanvas].

	"Draw receiver itself"
	(aCanvas isVisible: bounds) ifTrue: [
		aCanvas clipBy: bounds during: [ :c | self drawOn: c ]].	"Needs bounds 'in owner' if inside a scroller"
	self drawSubmorphsOn: aCanvas.
	self drawDropHighlightOn: aCanvas.
	self drawMouseDownHighlightOn: aCanvas! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:54' prior: 50334968!
       basicExtent: aPoint

	self flag: #jmvVer2.
	"Lo dejo un rato porque se llama dde initialize... De ultima, es un problema? Es cierto que no se la escala aun..."
	"
	self validateOwnerNotNil.
	"
	
	"ver senders. Es en owner's o en world's ???"
	
	
	self validateExtentAndBounds.
	extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	bounds _ bounds topLeft extent: aPoint.
	extent _ aPoint.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:45' prior: 50336668!
           morphExtent
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	self validateExtentAndBounds.
	^ extent! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:50' prior: 50334577!
                     morphHeight

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self validateExtentAndBounds.
	^ extent y! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:47' prior: 50336893!
                   morphHeight: aNumber

"Ensure everybody wants owner's coordinates!!
Besides, #asInteger???"
	self flag: #jmvVer2.
	self morphExtent: self morphWidth@aNumber asInteger! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:42' prior: 50334590!
         morphPositionInOwner
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"

	self flag: #jmvVer2.
	self validateOwnerNotNil.
	self validatePositionAndBounds.
	self validateExtentAndBounds.

	^ position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:42' prior: 50336900!
      morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = bounds topLeft ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

	self validateOwnerNotNil.


"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.
	self validateExtentAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:43' prior: 50334639!
              morphPositionInWorld
	| answer1 answer2 |
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"


	self flag: #jmvVer2.
	self validateOwnerNotNil.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	
	answer1 _ owner
		ifNotNil: [ owner externalizeToWorld: position ]
		ifNil: [ position ].
	answer2 _ bounds topLeft.
	{ answer1 . answer2 }.

	^answer2! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:43' prior: 50336933!
  morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
"Quizas no un null change del todo... Es posible que bounds y position se desincronicen, al cambiar el owner (o cualquier owner en el medio). Todo esto es fulerote. espero sacarlo pronto!!"
		self privateFullMoveBy: newPositionInWorld - bounds topLeft.
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.
	self validateExtentAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:48' prior: 50334741!
                        morphWidth

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self validateExtentAndBounds.
	^ extent x! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:49' prior: 50337015!
                    morphWidth: aNumber

"Ensure everybody wants owner's coordinates!!
Besides, #asInteger???"
	self flag: #jmvVer2.
	self morphExtent: aNumber asInteger@self morphHeight! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:36' prior: 50336682!
         validateNotSent
	"To be removed. Just to check consistency"

	self flag: #jmvVer2.
"	Count ifNil: [ Count _ 0 ].
	Count _ Count + 1.
	Count < 10 ifTrue: ["
		'-----False polymorphism. Should not be sent!!-----' print.
		thisContext printStack: 10 
	"]"! !
!Morph methodsFor: 'geometry testing' stamp: 'jmv 12/16/2011 16:30' prior: 16897947!
           fullContainsPoint: aPoint
"
	This alternative implementation is included in this comment because it could be useful someday.
	If we start to rely heavily on the use of #ownShadowForm in #containsPoint, this could be cheaper.
	
	| shadow |
	self clipSubmorphs
		ifTrue: [ ^self containsPoint: aPoint ]
		ifFalse: [
			(self fullBounds containsPoint: aPoint) ifFalse: [^ false].
			(self containsPoint: aPoint) ifTrue: [^ true].
			shadow _ self shadowForm.
			^(shadow pixelValueAt: aPoint - shadow offset) > 0 ]
"
	
	self flag: #jmvVer2.
	"Is the comment relevant now?"
	
	(self fullBounds containsPoint: aPoint) ifFalse: [ ^ false ].  "quick elimination"
	(self containsPoint: aPoint) ifTrue: [ ^ true ].  "quick acceptance"
	submorphs do: [:m | (m fullContainsPoint: aPoint) ifTrue: [ ^ true ]].
	^ false
! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 16:42' prior: 50335202!
  initialize
	"initialize the state of the receiver"

	owner _ nil.
	submorphs _ #().
	
	self flag: #jmvVer2.
	"Ir convirtiendo todos los usos (no las asignaciones!!) a las vars nuevas.
	Despues eliminar las asignaciones y las propias ivars (bounds y fullBounds)"
	bounds _ self defaultBounds.

	position _ bounds topLeft.
	extent _ bounds extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	color _ self defaultColor! !
!Morph methodsFor: 'layout' stamp: 'jmv 12/16/2011 15:56' prior: 16898429!
                             computeFullBounds
	"Private. Compute the actual full bounds of the receiver"

	"Remove when removing fullBounds"
	self flag: #jmvVer2.

	(submorphs isEmpty or: [ self clipsSubmorphs ]) ifTrue: [ ^bounds ].
	^ bounds quickMerge: self submorphBounds! !
!Morph methodsFor: 'layout' stamp: 'jmv 12/16/2011 15:56' prior: 16898456!
                          layoutSubmorphsAndComputeFullBounds
	"Return self. Recompute the layout if necessary."

	"Check senders. Many many not be needed. Others might be just to compute fullBounds, that we hope to elliminate!! Keep those that really need layout. of submorphs"
	self flag: #jmvVer2.

	fullBounds ifNotNil: [ ^self ].

	"Errors at this point can be critical so make sure we catch 'em all right"
	[
		self layoutSubmorphs.
		fullBounds _ self computeFullBounds.
	] on: Exception do: [ :ex |
		"This should do it unless you don't screw up the bounds"
		fullBounds _ bounds.
		ex pass ]! !
!Morph methodsFor: 'layout' stamp: 'jmv 12/16/2011 16:31' prior: 16898480!
                   submorphBounds
	"Private. Compute the actual full bounds of the receiver"

	"Remove when removing fullBounds? Reimplement?"
	self flag: #jmvVer2.

	^submorphs inject: nil into: [ :prevBox :m |
		m visible
			ifTrue: [ m fullBounds quickMerge: prevBox ]
			ifFalse: [ prevBox ] ]! !
!Morph methodsFor: 'updating' stamp: 'jmv 12/16/2011 16:00' prior: 16899672!
                         redrawNeeded
	"Report that the area occupied by this morph should be redrawn."

	self flag: #jmvVer2.
	"Invalidate the appropriate display rectangle... Just ours, or include submorphs if we don't clip.
	Think about it. We don't to know about a specific rectangle... How do we notify our 'observers' (i.e. the possible canvases we end drawn upon)?"
	
	"This method is the only real use of ivar fullBounds, other than senders of #fullBounds"

	self invalidRect: (fullBounds ifNil: [ bounds ])! !
!Morph methodsFor: 'private' stamp: 'jmv 12/16/2011 17:07' prior: 50335241!
      privateOwner: aMorph
	"Private!! Should only be used by methods that maintain the ower/submorph invariant."

	| oldGlobalPosition prevOwner |
	self flag: #jmvVer2.
	"
	(aMorph notNil and: [
		bounds origin ~= self defaultBounds origin ]) ifTrue: [
			'                                ---------------- Nos mandan #privateOwner: , pero nos han mandado bounds antes (no necesariamente un problema!!!!!!!!!!)!!' print.
			thisContext printStack: 10 ].
	"

	self validatePositionAndBounds.
	self validateExtentAndBounds.
			
	self flag: #jmvVer2.
	"Is this the best behavior???"
	prevOwner _ owner.
	prevOwner
		ifNotNil: [
			"Had an owner. Maintain my global position..."
			oldGlobalPosition _ self morphPositionInWorld ].
	owner _ aMorph.
	owner
		ifNil: [
			"Won't have any owner. Keep local position, as it will be maintained in my new owner later"
			bounds _ position extent: extent.
			fullBounds _ nil.
			self validatePositionAndBounds.
			self validateExtentAndBounds.
			]
		ifNotNil: [
			prevOwner
				ifNil: [
					"Didn't have any owner. Assume my local position is to be maintained in my new owner"
					bounds _ (owner externalizeToWorld: position) extent: extent.
					fullBounds _ nil.
					self validatePositionAndBounds.
					self validateExtentAndBounds.
					]
				ifNotNil: [
					"Had an owner. Maintain my global position..."
					position _ owner internalizeFromWorld: oldGlobalPosition.
					self flag: #jmvVer2.
					"extent _ owner internalizeDistanceFromWorld: oldGlobalExtent" 	"or something like this!!"
					self validatePositionAndBounds.
					self validateExtentAndBounds.
					]]! !
!HaloHandleMorph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 17:09' prior: 16863547!
                        drawOn: aCanvas
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	aCanvas
		image: (self class circleForm: extent)
		multipliedBy: (color alpha: 0.57)
		at: bounds topLeft.! !
!HaloMorph methodsFor: 'stepping' stamp: 'jmv 12/16/2011 17:08' prior: 50332248!
                step
	| newBounds |
	target
		ifNil: [^ self].
	newBounds _ target isWorldMorph
				ifTrue: [target bounds]
				ifFalse: [target worldBoundsForHalo truncated].
	newBounds = bounds
		ifTrue: [^ self].
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newBounds extent = extent
		ifTrue: [^ self morphPosition: newBounds origin].
	growingOrRotating ifFalse: [
		submorphs size > 1
			ifTrue: [self addHandles]].
	"adjust halo bounds if appropriate"
	self bounds: newBounds! !
!HaloMorph methodsFor: 'updating' stamp: 'jmv 12/16/2011 17:09' prior: 16863947!
      redrawNeeded
	"Quicker to invalidate handles individually if target is large (especially the world)"

	self validatePositionAndBounds.
	self validateExtentAndBounds.
	extent > (200@200)
		ifTrue: [(target notNil and: [target ~~ self world]) ifTrue: [
					"Invalidate 4 outer strips first, thus subsuming separate damage."
					(self fullBounds areasOutside: target bounds) do:
						[ :r | self invalidRect: r ]].
				self submorphsDo: [:m | m redrawNeeded]]
		ifFalse: [ super redrawNeeded ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 17:09' prior: 50337098!
                               doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target bounds topLeft.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target morphExtent: newExtent.
	growHandle morphPosition: evt eventPosition - (growHandle morphExtent // 2).
	self someSubmorphPositionOrExtentChanged
! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 16:42' prior: 50335374!
                initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	bounds _ 0@0 extent: CursorWithMask normal extent.
	position _ 0@0.
	extent _ CursorWithMask normal extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!ImageMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 17:11' prior: 16867738!
      borderWidth: bw
	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent _ 2 * bw + image extent.
	extent = newExtent ifFalse: [
		self basicExtent: newExtent ]! !
!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 17:11' prior: 50336697!
     morphExtent: aPoint
	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	"Resist changing the extent if no wordwrap.. this should be checked."
	wrapFlag ifFalse: [ ^ self ].
	newExtent _ aPoint truncated max: self minimumExtent.
	
	"No change of wrap width"
	newExtent x = extent x ifTrue: [ ^ self ].

	super morphExtent: newExtent.
	
	self resetParagraph.
	self editor recomputeSelection.	
	self updateFromParagraph.! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 17:11' prior: 16870337!
          fit
	"Adjust my bounds to fit the text.
	Required after the text changes,
	or if wrapFlag is true and the user attempts to change the extent."

	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent _ (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).
	extent = newExtent ifFalse: [
		self basicExtent: newExtent.
		self redrawNeeded.	"Too conservative: only paragraph composition
								should cause invalidation."
		].

	owner innerHeight: newExtent y! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 12/16/2011 17:00' prior: 50337249!
              chooseMagnification
	| result |
	result _ (SelectionMenu selections: #(1.5 2 4 8))
		startUpWithCaption: 'Choose magnification
(currently ', magnification printString, ')'.
	(result == nil or: [ result = magnification ]) ifTrue: [ ^ self ].
	magnification _ result.
	self morphExtent: extent. "round to new magnification"
	self redrawNeeded. "redraw even if extent wasn't changed"! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 16:42' prior: 50335570!
         initialize
	super initialize.
	bounds _ 0@0 corner: 40@10.
	position _ 0@0.
	extent _ 40@10.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil
! !
!MinimalStringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 17:00' prior: 50337301!
                      fitContents

	| newExtent |
	newExtent _ self measureContents.
	self validateExtentAndBounds.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 17:11' prior: 50337312!
                fitContents

	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent _ self measureContents.
	self validateExtentAndBounds.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 17:10' prior: 50336720!
                       morphExtent: aPoint

	self flag: #jmvVer2.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self validatePositionAndBounds.
		self validateExtentAndBounds.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PasteUpMorph methodsFor: 'misc' stamp: 'jmv 12/16/2011 17:10' prior: 16911938!
      buildMagnifiedBackgroundImage
	| image old |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	old _ backgroundImage.
	backgroundImageData
		ifNil: [ backgroundImage _ nil ]
		ifNotNil: [ 
			image _ Form fromBinaryStream: backgroundImageData readStream.
			backgroundImage _ image magnifyTo: extent.
			self canvas ifNotNil: [ :c |
				(backgroundImage depth = 32 and: [ c depth < 32 ]) ifTrue: [
					backgroundImage _ backgroundImage orderedDither32To16 ]]
		].
	old == backgroundImage ifFalse: [
		self redrawNeeded ]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 12/16/2011 16:43' prior: 50335650!
           viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
"	super morphPosition: newViewBox topLeft."
	fullBounds _ bounds _ newViewBox.
	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].
	extent _ bounds extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 12/16/2011 15:45' prior: 16912487!
                          restoreMorphicDisplay
	DisplayScreen startUp.
	self
		morphExtent: Display extent;
		viewBox: Display boundingBox;
		handsDo: [ :h | h visible: true ];
		fullRepaintNeeded.
	WorldState addDeferredUIMessage: [ Cursor normal show ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 1/3/2012 16:22' prior: 16913500!
                              draw3DLookOn: aCanvas

	| w f center x y borderStyleSymbol c availableW l labelMargin |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: bounds
		colorOrInfiniteForm: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol.

	f _ self fontToUse.
	center _ bounds center.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ bounds width-labelMargin-labelMargin-1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ bounds left + labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 17:03' prior: 16913532!
  drawEmbossedLabelOn: aCanvas

	| availableW center colorForLabel f l labelMargin targetSize w x y |
	label ifNotNil: [
		colorForLabel _ Theme current buttonLabel.
		self isPressed
			ifFalse: [
				self mouseIsOver
					ifFalse: [ colorForLabel _ colorForLabel adjustSaturation: -0.10 brightness: 0.10 ]]
			ifTrue: [ colorForLabel _ colorForLabel adjustSaturation: 0.0 brightness: -0.07 ].
		f _ self fontToUse.
		center _ bounds center.
		labelMargin _ 3.
		w _ f widthOfString: label.
		availableW _ bounds width-labelMargin-labelMargin.
		availableW >= w
			ifTrue: [
				l _ label ]
			ifFalse: [
				x _ bounds left + labelMargin.
				targetSize _ label size * availableW // w.
				l _ label squeezedTo: targetSize.
				(f widthOfString: l) > availableW ifTrue: [
					targetSize _ targetSize - 1.
					l _ label squeezedTo: targetSize ]].
		
		w _ f widthOfString: l.
		x _ center x - (w // 2).
		y _ center y - (f height // 2).
		aCanvas
			drawStringEmbossed: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: colorForLabel ]! !
!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 17:03' prior: 16913780!
                               magnifiedIcon
	| b |
	magnifiedIcon ifNil: [
		magnifiedIcon _ icon.
		self isRoundButton
			ifFalse: [ ^ magnifiedIcon ].
		b _ extent x max: extent y.
		b < icon extent x ifTrue: [
			magnifiedIcon _ icon magnifyTo: b@b ].
		b /  icon extent x > 1.7
			ifTrue: [	
				b _ b * 3 // 4.
				magnifiedIcon _ icon magnifyTo: b @ b]].
	^magnifiedIcon! !
!PolygonMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 17:09' prior: 50336762!
              morphExtent: newExtent 
	"Not really advisable, but we can preserve most of the geometry if we don't
	shrink things too small."
	| safeExtent center |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	center _ self referencePosition.
	safeExtent _ newExtent max: 20@20.
	self setVertices: (vertices collect:
		[:p | p - center * (safeExtent asFloatPoint / (extent max: 1@1)) + center])! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 16:43' prior: 50335719!
                         computeBounds
	| oldBounds delta excludeHandles |

	self flag: #jmvVer2.
	vertices ifNil: [^ self].

	self redrawNeeded.
	oldBounds _ bounds.
	self releaseCachedState.
	bounds _ self curveBounds truncated.
	self arrowForms do: [ :f |
		bounds _ bounds merge: (f offset extent: f extent)].
	handles ifNotNil: [ self updateHandles ].

	"since we are directly updating bounds, see if any ordinary submorphs exist and move them accordingly"
	(oldBounds notNil and: [(delta _ bounds origin - oldBounds origin) ~= (0@0)]) ifTrue: [
		excludeHandles _ IdentitySet new.
		handles ifNotNil: [excludeHandles addAll: handles].
		self submorphsDo: [ :each |
			(excludeHandles includes: each) ifFalse: [
				each morphPosition: each morphPosition + delta ] ] ].
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded.! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 4/10/2012 15:31' prior: 16917386!
                              filledForm
	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."
	| bb origin |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	closed ifFalse: [^ filledForm _ nil].
	filledForm ifNotNil: [^ filledForm].
	filledForm _ ColorForm extent: extent+2.

	"Draw the border..."
	bb _ (BitBlt current toForm: filledForm) sourceForm: nil; fillColor: Color black;
			combinationRule: Form over; width: 1; height: 1.
	origin _ bounds topLeft asIntegerPoint-1.
	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin
										to: p2 asIntegerPoint-origin].

	"Fill it in..."
	filledForm _ ColorForm mappingWhiteToTransparentFrom: filledForm anyShapeFill.

	borderColor mightBeTranslucent ifTrue: [
		"If border is stored as a form, then erase any overlap now."
		filledForm
			copy: self borderForm boundingBox
			from: self borderForm
			to: 1@1
			rule: Form erase ].

	^ filledForm! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/10/2012 15:31' prior: 50336775!
                      morphExtent: newExtent

	| newExtentToUse |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent = extent ifTrue: [^ self].
	newExtentToUse _ bounds isWide
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = extent ifTrue: [^ self].
	super morphExtent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!StringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 16:56' prior: 50337452!
                           fitContents

	| newExtent |
	newExtent _ self measureContents.
	self validateExtentAndBounds.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 12/16/2011 17:04' prior: 50337463!
                        makeMeVisible 

	self world morphExtent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self isCollapsed
		ifTrue: [ self morphPosition: (RealEstateAgent assignCollapsePointFor: self)]
		ifFalse: [ self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: extent world: self world) topLeft].

! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 12/16/2011 17:04' prior: 50336807!
 morphExtent: aPoint 
	"Set the receiver's extent to value provided. Respect my minimumExtent."

	| newExtent |
	newExtent _ self isCollapsed
		ifTrue: [aPoint]
		ifFalse: [aPoint max: self minimumExtent].
	newExtent = extent ifTrue: [^ self].

	isCollapsed
		ifTrue: [super morphExtent: newExtent x @ (self labelHeight + 2)]
		ifFalse: [super morphExtent: newExtent].
	isCollapsed
		ifTrue: [collapsedFrame _ bounds]
		ifFalse: [fullFrame _ bounds]! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 12/16/2011 15:50' prior: 16965787!
          layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| bl br h thickness tl tr w cornerExtent |
	thickness _ 4.
	cornerExtent _ 20.
	tl _ bounds topLeft.
	tr _ bounds topRight.
	bl _ bounds bottomLeft.
	br _ bounds bottomRight.
	w _ bounds width - cornerExtent - cornerExtent.
	h _ bounds height - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) bounds: (tl + (cornerExtent@0) extent: w@thickness).
	(adjusters at: #bottomAdjuster) bounds: (bl+ (cornerExtent @ thickness negated) extent: w@thickness).
	(adjusters at: #leftAdjuster) bounds: (tl+ (0@cornerExtent) extent: thickness@h).
	(adjusters at: #rightAdjuster) bounds: (tr + (thickness negated@ cornerExtent) extent: thickness@h).
	(adjusters at: #topLeftAdjuster) bounds: (tl extent: cornerExtent@cornerExtent).
	(adjusters at: #bottomLeftAdjuster) bounds: (bl-(0@cornerExtent) extent: cornerExtent@cornerExtent).
	(adjusters at: #topRightAdjuster) bounds: (tr+(cornerExtent negated@0) extent: cornerExtent@cornerExtent).
	(adjusters at: #bottomRightAdjuster) bounds: (br-cornerExtent extent: cornerExtent@cornerExtent).

	layoutMorph ifNotNil: [
		layoutMorph bounds: self layoutBounds ]! !
!TranscriptMorph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 17:10' prior: 16978408!
                              drawOn: aCanvas
	"
	Transcript
		showOnDisplay: true;
		bounds: bounds;
		displayOn: aCanvas form.
	"
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	Transcript
		showOnDisplay: true;
		bounds: (0@0 extent: extent);
		displayOn: form;
		bounds: bounds.
	aCanvas image: form at: bounds origin! !

TranscriptMorph removeSelector: #extent:!

TranscriptMorph removeSelector: #extent:!

SystemWindow removeSelector: #extent:!

SystemWindow removeSelector: #extent:!

Sonogram removeSelector: #extent:!

Sonogram removeSelector: #extent:!

ScrollBar removeSelector: #extent:!

ScrollBar removeSelector: #extent:!

PolygonMorph removeSelector: #extent:!

PolygonMorph removeSelector: #extent:!

LimitedHeightTextMorph removeSelector: #extent:!

LimitedHeightTextMorph removeSelector: #extent:!

PluggableScrollPane removeSelector: #extent:!

PluggableScrollPane removeSelector: #extent:!

PluggableButtonMorph removeSelector: #extent:!

PluggableButtonMorph removeSelector: #extent:!

PasteUpMorph removeSelector: #extent:!

PasteUpMorph removeSelector: #extent:!

MagnifierMorph removeSelector: #extent:!

MagnifierMorph removeSelector: #extent:!

InnerTextMorph removeSelector: #extent:!

InnerTextMorph removeSelector: #extent:!

ImageMorph removeSelector: #extent:!

ImageMorph removeSelector: #extent:!

Morph removeSelector: #extent!

Morph removeSelector: #extent!

Morph removeSelector: #extent:!

Morph removeSelector: #extent:!

Morph removeSelector: #height!

Morph removeSelector: #height!

Morph removeSelector: #height:!

Morph removeSelector: #height:!

Morph removeSelector: #width!

Morph removeSelector: #width!

Morph removeSelector: #width:!

Morph removeSelector: #width:!

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4207-StartUsingNewIvars-jmv.4.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1261] on 10 April 2012 at 3:48:51 pm'!
!CodeProvider methodsFor: 'categories' stamp: 'jmv 1/2/2012 14:32' prior: 16813859!
                    methodCategoryChanged
	self triggerEvent: #annotationChanged! !
!CodeProvider methodsFor: 'contents' stamp: 'jmv 1/2/2012 14:31' prior: 16813872!
              acceptedContentsChanged

	self changed: #acceptedContents.
	self changed: #decorateButtons.
	self triggerEvent: #annotationChanged! !
!Browser methodsFor: 'accessing' stamp: 'jmv 1/2/2012 14:31' prior: 16793751!
            contents: input notifying: aController
	"The retrieved information has changed and its source must now be
	 updated. The information can be a variety of things, depending on
	 the list selections (such as templates for class or message definition,
	 methods) or the user menu commands (such as definition, comment,
	 hierarchy).  Answer the result of updating the source."

	| aString aText theClass |
	aString _ input asString.
	aText _ input asText.
	editSelection == #editSystemCategories ifTrue: [ ^ self changeSystemCategories: aString ].
	editSelection == #editClass | (editSelection == #newClass) ifTrue: [ ^ self defineClass: aString notifying: aController ].
	editSelection == #editComment
		ifTrue: [
			theClass _ self selectedClass.
			theClass
				ifNil: [
					self inform: 'You must select a class
before giving it a comment.'.
					^ false].
			theClass comment: aText stamp: Utilities changeStamp.
			self changed: #classCommentText.
			^ true].
	editSelection == #hierarchy ifTrue: [ ^ true ].
	editSelection == #editMessageCategories ifTrue: [ ^ self changeMessageCategories: aString ].
	editSelection == #editMessage | (editSelection == #newMessage)
		ifTrue: [
			^ self okayToAccept
				ifFalse:[ false ]
				ifTrue: [
					(self compileMessage: aText notifying: aController)
						ifTrue: [ self triggerEvent: #annotationChanged ];
						yourself ]].
	editSelection == #none
		ifTrue: [
			self inform: 'This text cannot be accepted
in this part of the browser.'.
			^ false].
	self error: 'unacceptable accept'! !
!Browser methodsFor: 'initialize-release' stamp: 'jmv 1/2/2012 14:32' prior: 16794358!
       methodCategoryChanged
	self changed: #messageCategoryList.
	self changed: #messageList.
	self triggerEvent: #annotationChanged.
	self messageListIndex: 0! !
!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 1/4/2012 19:01' prior: 16861541!
   buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	"

	| resizeFactor outerBox arrowMorph resizedForm f |
	resizeFactor _ 4.
	outerBox _ RectangleMorph new.
	outerBox
		extent: finalSizeInteger asPoint * resizeFactor;
		borderWidth: 0;
		color: Color transparent.
	
	arrowMorph _ self buildArrowIn: outerBox bounds.
	outerBox addMorphFront: arrowMorph.
	arrowMorph morphPosition: outerBox bounds center - (arrowMorph morphExtent // 2).
	
	f _ outerBox imageForm: 32.
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotateBy: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotateBy: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotateBy:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !
!MessageSet methodsFor: 'message functions' stamp: 'jmv 1/2/2012 14:33' prior: 16890744!
                   methodCategoryChanged
	self triggerEvent: #annotationChanged! !
!MessageSet methodsFor: 'private' stamp: 'jmv 1/2/2012 14:34' prior: 16890886!
                 contents: aString notifying: aController 
	"Compile the code in aString. Notify aController of any syntax errors. 
	Answer false if the compilation fails. Otherwise, if the compilation 
	created a new method, deselect the current selection. Then answer true."

	| category selector class oldSelector |
	self okayToAccept ifFalse: [^ false].
	self setClassAndSelectorIn: [:c :os | class _ c.  oldSelector _ os].
	class ifNil: [^ false].
	(oldSelector notNil and: [oldSelector first isUppercase]) ifTrue:
		[oldSelector == #Comment ifTrue:
			[class comment: aString stamp: Utilities changeStamp.
			self triggerEvent: #annotationChanged.
 			self changed: #clearUserEdits.
			^ false].
		oldSelector == #Definition ifTrue:
			["self defineClass: aString notifying: aController."
			class subclassDefinerClass
				evaluate: aString
				notifying: aController
				logged: true.
			self changed: #clearUserEdits.
 			^ false].
		oldSelector == #Hierarchy ifTrue:
			[self inform: 'To change the hierarchy, edit the class definitions'. 
			^ false]].
	"Normal method accept"
	category _ class organization categoryOfElement: oldSelector.
	selector _ class compile: aString
				classified: category
				notifying: aController.
	selector
		ifNil: [^ false].
	selector == oldSelector ifFalse: [
		self reformulateListNoting: selector].
	self triggerEvent: #annotationChanged.
	^ true! !
!Morph methodsFor: 'geometry' stamp: 'jmv 1/2/2012 15:13' prior: 50337710!
                  validateExtentAndBounds
	"To be removed. Just to check consistency"
	| answer1 answer2 |
	self flag: #jmvVer2.

"	answer1 _ owner
		ifNotNil: [ owner externalizeDistanceToWorld: extent ]
		ifNil: [ extent ]."
	answer1 _ extent.
	answer2 _ bounds extent.

	answer1 = answer2 rounded ifFalse: [
		#validateExtentAndBounds print.
		answer1 print.
		answer2 print.
		thisContext printStack: 10 ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 1/1/2012 23:28' prior: 50334754!
          validateOwnerNotNil
	"To be removed. Just to check consistency"

	self flag: #jmvVer2.
"
	owner ifNil: [
		'-----Still no owner, but this stuff kind of requires it!!-----' print.
		thisContext printStack: 10 ]
	"! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 1/4/2012 18:59' prior: 16783547!
                 resetMenu
	| w f |
	firstVisible _ 1.
	self selected: 1.
	w _ 120.
	f _ self class listFont.
	1
		to: completer entryCount
		do: [ :index |
			w _ w max: (f widthOfString: (completer entries at: index) asString)].
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w + ScrollBar scrollbarThickness ].
	self morphExtent: w + 4 @ (self visibleItemsCount * self itemHeight+2)! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 1/2/2012 14:31' prior: 16814856!
      buildMorphicAnnotationsPane

	| aTextMorph |
	aTextMorph _ TextModelMorph
		textProvider: model
		textGetter: #annotation.
	model when: #annotationChanged send: #redrawNeeded to: aTextMorph.
	aTextMorph
		askBeforeDiscardingEdits: false;
		hideScrollBarsIndefinitely.
	^aTextMorph! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 1/2/2012 13:46' prior: 50332742!
          mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].
	self handleInteraction: [ editor mouseMove: (evt translatedBy: bounds topLeft negated)].
	(evt eventPosition y between: owner bounds top and: owner bounds bottom) ifFalse: [
		owner scrollSelectionIntoView: evt ]! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 1/2/2012 13:09' prior: 16870415!
                               updateFromParagraph
	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be released, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, and current typing emphasis."

	paragraph ifNotNil: [
		editor storeSelectionInParagraph.
		self fit.
	].

	owner
		updateScrollBarsBounds;
		setScrollDeltas! !
!LayoutAdjustingMorph methodsFor: 'testing' stamp: 'jmv 1/3/2012 14:10' prior: 16879830!
        isOpaqueMorph
	"Any submorph that answers true to #isOrthoRectangularMorph (to optimize #containsPoint:)
	but is not an opaque rectangle covering bounds MUST answer false to this message"
	color mightBeTranslucent ifTrue: [
		^false ].
	^true! !
!MessageSetWindow methodsFor: 'top window' stamp: 'jmv 1/2/2012 15:36' prior: 16891448!
                  activateAndSendTopToBack: aBoolean
	super activateAndSendTopToBack: aBoolean.
	self isCollapsed 
		ifFalse: [
			(model messageListIndex = 0 and: [ model messageList notEmpty ])
				ifTrue: [	
					"Not really pretty... Cleanup some day"
					model messageListIndex: 1.
					model autoSelectString ifNotNil: [
						[ model acceptedContentsChanged ]
							forkAt: Processor userBackgroundPriority  ]
				]]! !
!PluggableButtonMorph class methodsFor: 'example' stamp: 'jmv 1/3/2012 16:40' prior: 16913899!
      example
	"PluggableButtonMorph example openInWorld"

	| s1 s2 s3 b1 b2 b3 row |
	s1 _ Switch new.
	s2 _ Switch new turnOn.
	s3 _ Switch new.
	s2 onAction: [s3 turnOff].
	s3 onAction: [s2 turnOff].
	b1 _ (PluggableButtonMorph model: s1 stateGetter: #isOn action: #switch) label: 'S1'.
	b2 _ (PluggableButtonMorph model: s2 stateGetter: #isOn action: #turnOn) label: 'S2'.
	b3 _ (PluggableButtonMorph model: s3 stateGetter: #isOn action: #turnOn) label: 'S3'.
	b1 color: Color lightRed.
	b2 color: Color lightRed.
	b3 color: Color lightRed.
	row _ LayoutMorph newRow
		addMorphs: (Array with: b1 with: b2 with: b3);
		morphExtent: 120@35.
	^ row
! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 1/4/2012 19:00' prior: 50336743!
                               morphExtent: newExtent
	
	| minH minW |
	"Figure out the minimum width and height for this pane so that scrollbars will appear"
	minH _ self scrollBarClass scrollbarThickness * 2.
	minW _ minH.
	super morphExtent: (newExtent max: (minW@minH)).

	"Now reset widget sizes"
	scroller adjustExtent.
	self updateScrollBarsBounds.
	self setScrollDeltas! !
!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 1/2/2012 13:49' prior: 16914420!
         selectionIndex: index
	"Called internally to select the index-th item."
	| row |
	self unhighlightSelection.
	row _ index ifNil: [ 0 ].
	row _ row min: self getListSize.  "make sure we don't select past the end"
	self listMorph selectedRow: row.
	self highlightSelection.
	self scrollSelectionIntoView! !
!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 1/2/2012 13:49' prior: 50334293!
                      scrollSelectionIntoView: event
	"Scroll my text into view if necessary and return true, else return false"
	| selRects rectToTest cpHere |
	selRects _ self textMorph selectionRects.
	selRects isEmpty ifTrue: [ ^ self ].
	rectToTest _ selRects first merge: selRects last.
	event ifNotNil: [  "Check for autoscroll"
		cpHere _ event eventPosition.
		cpHere y <= bounds top
			ifTrue:  [ rectToTest _ selRects first topLeft extent: 2@2 ]
			ifFalse: [
				cpHere y >= bounds bottom
					ifTrue: [ rectToTest _ selRects last bottomRight extent: 2@2 ]
					ifFalse: [ ^ self ]]].
	^ self scrollToShow: rectToTest! !

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4208-LottaFixes-jmv.10.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1261] on 10 April 2012 at 3:51:44 pm'!
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 1/6/2012 15:31' prior: 50338274!
 fit
	"Adjust my bounds to fit the text.
	Required after the text changes,
	or if wrapFlag is true and the user attempts to change the extent."

	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent _ (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).
	extent = newExtent ifFalse: [
		self basicExtent: newExtent ].

	self redrawNeeded.	"Too conservative: only paragraph composition
							should cause invalidation."
	owner innerHeight: newExtent y! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 1/6/2012 14:52' prior: 50339044!
            morphExtent: newExtent
	
	| minH minW |
	"Figure out the minimum width and height for this pane so that scrollbars will appear"
	minH _ self vIsScrollbarShowing
		ifTrue: [self scrollBarClass scrollbarThickness * 2]
		ifFalse: [0].
	minW _ self hIsScrollbarShowing
		ifTrue: [self scrollBarClass scrollbarThickness * 2]
		ifFalse: [0].
	super morphExtent: (newExtent max: (minW@minH)).

	"Now reset widget sizes"
	scroller adjustExtent.
	self updateScrollBarsBounds.
	self setScrollDeltas! !

StringMorph removeSelector: #setWidth:!

StringMorph removeSelector: #setWidth:!

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4209-AccountForLaterCuis4Changes-jmv.5.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4209] on 11 April 2012 at 9:35:50 pm'!
!HandMorph methodsFor: 'private events' stamp: 'jmv 4/11/2012 21:35' prior: 16865561!
                   generateMouseEvent: evtBuf 
	"Generate the appropriate mouse event for the given raw event buffer"

	| pos buttons modifiers type trail stamp oldButtons |
	stamp := evtBuf second.
	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ].
	pos := evtBuf third @ evtBuf fourth.
	buttons := evtBuf fifth.
	modifiers := evtBuf sixth.
	type := buttons = 0 
		ifTrue: [
			lastEventBuffer fifth = 0 ifTrue: [#mouseMove] ifFalse: [#mouseUp]]
		ifFalse: [
			lastEventBuffer fifth = 0 
						ifTrue: [#mouseDown]
						ifFalse: [#mouseMove]].
	buttons := buttons bitOr: (modifiers bitShift: 3).
	oldButtons := lastEventBuffer fifth 
				bitOr: (lastEventBuffer sixth bitShift: 3).
	lastEventBuffer := evtBuf.
	type == #mouseMove 
		ifTrue: [
			trail := self mouseTrailFrom: evtBuf.
			^MouseMoveEvent new 
				setType: type
				startPoint: trail first
				endPoint: trail last
				trail: trail
				buttons: buttons
				hand: self
				stamp: stamp].
	^MouseButtonEvent new 
		setType: type
		position: pos
		which: (oldButtons bitXor: buttons)
		buttons: buttons
		hand: self
		stamp: stamp! !

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4210-CleanAShadowedVar-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4209] on 11 April 2012 at 10:01:23 pm'!
!CodeProvider methodsFor: 'commands' stamp: 'jmv 4/11/2012 21:54' prior: 16813947!
                             hierarchyBrowser
	"Create and schedule a new hierarchy browser on the currently selected class or meta."

	| newBrowser aSymbol aBehavior messageCatIndex selectedClassOrMetaClass |
	(selectedClassOrMetaClass _ self selectedClassOrMetaClass)
		ifNil: [^ nil].
	newBrowser _ HierarchyBrowser new initHierarchyForClass: selectedClassOrMetaClass.
	((aSymbol _ self selectedMessageName) notNil and: [(MessageSet isPseudoSelector: aSymbol) not])
		ifTrue: [
			aBehavior _ selectedClassOrMetaClass.
			messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.
			messageCatIndex = 0 ifFalse: [
				newBrowser messageCategoryListIndex: messageCatIndex + 1.
				newBrowser messageListIndex:
					((aBehavior organization listAtCategoryNumber: messageCatIndex) indexOf: aSymbol) ]].
	^newBrowser! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/11/2012 21:56' prior: 16861019!
  drawString: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: c
	| font |
	port colorMap: nil.
	font _ fontOrNil ifNil: [StrikeFont default].
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: (origin + aPoint)
		strikeFont: font
		kern: font baseKern negated! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/11/2012 21:56' prior: 16861037!
               drawString: aString from: firstIndex to: lastIndex in: bounds font: fontOrNil color: c
	| font portRect |
	port colorMap: nil.
	portRect _ port clipRect.
	port clipByX1: bounds left + origin x 
		y1: bounds top + origin y 
		x2: bounds right + origin x 
		y2: bounds bottom + origin y.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [port clipRect: portRect. ^self].
	port clipWidth = 0 ifTrue: [port clipRect: portRect. ^self].
	font _ fontOrNil ifNil: [StrikeFont default].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: (bounds topLeft + origin)
		strikeFont: font
		kern: font baseKern negated.
	port clipRect: portRect! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/11/2012 21:58' prior: 16861070!
                   drawStringEmbossed: aString from: firstIndex to: lastIndex in: bounds font: fontOrNil color: aColor
	| font portRect insideColor |
	port colorMap: nil.
	portRect _ port clipRect.
	port clipByX1: bounds left + origin x 
		y1: bounds top + origin y 
		x2: bounds right + origin x 
		y2: bounds bottom + origin y.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	font _ fontOrNil ifNil: [StrikeFont default].
	insideColor _ shadowColor ifNil: [ aColor ].
	insideColor = Color black ifFalse: [ | topColor |
		topColor _ insideColor alphaMixed: 0.25 with: Color black.
		port installStrikeFont: font foregroundColor: topColor.
		port
			displayString: aString asString
			from: firstIndex
			to: lastIndex
			at: (bounds topLeft + origin)
			strikeFont: font
			kern: font baseKern negated ].
	insideColor = Color white ifFalse: [ | bottomColor |
		bottomColor _ insideColor alphaMixed: 0.22 with: Color white.
		port installStrikeFont: font foregroundColor: bottomColor.
		port
			displayString: aString asString
			from: firstIndex
			to: lastIndex
			at: (bounds topLeft + origin + (0@2))
			strikeFont: font
			kern: font baseKern negated ].
	port installStrikeFont: font foregroundColor: insideColor.
	port
		displayString: aString asString
		from: firstIndex
		to: lastIndex
		at: (bounds topLeft + origin + (0@1))
		strikeFont: font
		kern: font baseKern negated.
	port clipRect: portRect! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 4/11/2012 21:51' prior: 16900483!
           displayBulletParagraphTopLeft: paragraphTopLeft number: bulletNumber
	| pattern i c j s bullet bulletPos bulletSize prefix |
	pattern _ paragraphStyle listBulletPattern.
	bullet _ pattern.
	(i _ pattern indexOf: $%) > 0
		ifTrue: [ bullet _ bulletNumber asString]
		ifFalse: [
			(i _ pattern indexOf: $z) > 0
				ifTrue: [ bullet _ (Character value: 96 + bulletNumber) asString ]
				ifFalse: [
					(i _ pattern indexOf: $Z) > 0
						ifTrue: [ bullet _ (Character value: 64 + bulletNumber) asString ]]].
	prefix _ 0.
	i > 0 ifTrue: [
		c _ pattern at: i.
		j _ i.
		s _ pattern size.
		[ j <= s and: [ (pattern at: j) = c ] ] whileTrue: [ j _ j + 1 ].
		j _ j - 1.
		bulletSize _ j-i+1.
		prefix _ bulletSize - bullet size max: 0.
		bullet size > bulletSize ifTrue: [
			bullet _ bullet copyFrom: bullet size - bulletSize + 1 to: bullet size ].
		bullet _ (pattern copyFrom: 1 to: i-1), bullet, (pattern copyFrom: j+1 to: pattern size) ].
	bulletPos _ paragraphStyle firstIndent + paragraphTopLeft x + ((font widthOf: $9) * prefix)@destY.
	canvas grafPort displayString: bullet from: 1 to: bullet size at: bulletPos strikeFont: font kern: kern! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 4/11/2012 21:56' prior: 16900521!
             displayLine: textLine paragraphTopLeft: paragraphTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."
	| done stopCondition nowLeftInRun startIndex string lastPos priorFont |

	line _ textLine.
	paraTopLeft _ paragraphTopLeft + canvas origin.
	lineY _ line top + paraTopLeft y.
	lineHeight _ line lineHeight.
	rightMargin _ line rightMargin + paraTopLeft x.
	lastIndex _ line first.
	leftInRun <= 0 ifTrue: [self setStopConditions].
	leftMargin _ (line leftMarginForAlignment: alignment) + paraTopLeft x.
	destX _ runX _ leftMargin.
	destY _ lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: [ :ps |
			ps = paragraphStyle ifFalse: [
				""
				foregroundColor _ paragraphColor.
				priorFont _ font.
				self setActualFont: ps font.
				ps color ifNotNil: [ :color | self textColor: color ].
				alignment _ ps alignment.
				paragraphStyle _ ps.
				priorFont ifNotNil: [ destX _ destX + priorFont descentKern ].
				destX _ destX - font descentKern.
				kern _ 0 - font baseKern.
				spaceWidth _ font widthOf: Character space.
				xTable _ font xTable.
				map _ font characterToGlyphMap.
				stopConditions _ DefaultStopConditions.
				canvas grafPort installStrikeFont: font foregroundColor: foregroundColor.
				text ifNotNil: [ destY _ lineY + line baseline - font ascent ]
				""
			]
		].
		self displayBulletIfAppropriateFor: textLine paragraphTopLeft: paraTopLeft.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine paragraphTopLeft: paraTopLeft.

	lastIndex _ line first.
	leftInRun <= 0
		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun _ leftInRun].
	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount _ 0.
	done _ false.
	string _ text string.

	self placeEmbeddedObject.
	[ done ] whileFalse: [
		startIndex _ lastIndex.
		lastPos _ destX@destY.
		stopCondition _ self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions
			kern: kern.
		lastIndex >= startIndex ifTrue: [
			canvas grafPort 
				displayString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				strikeFont: font
				kern: kern ].
		"see setStopConditions for stopping conditions for displaying."
		done _ self perform: stopCondition ].
	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !
!MorphicScanner methodsFor: 'private' stamp: 'jmv 4/11/2012 21:57' prior: 16900633!
             setFont 
	foregroundColor _ paragraphColor.
	super setFont.  "Sets font and emphasis bits, and maybe foregroundColor"
	canvas grafPort installStrikeFont: font foregroundColor: foregroundColor.
	text ifNotNil: [ destY _ lineY + line baseline - font ascent ]! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 4/11/2012 21:57' prior: 16978297!
   displayOn: aForm
	"
	Transcript displayOn: Display
	"
	| font port count i string x y fh f bw r |
	bw _ self borderWidth  .
	r _ innerRectangle outsetBy: bw + self padding.
	aForm border: r width: bw. 
	aForm fill: r fillColor: Color white.
	port _ BitBlt toForm: aForm.
	port clipWidth: innerRectangle right.
	font _ StrikeFont default.
	port installStrikeFont: font foregroundColor: Color veryDarkGray.
	
	fh _ font height.
	count _ innerRectangle height // fh-1.
	x _ innerRectangle left.
	y _ innerRectangle top.
	f _ firstIndex-1.
	firstIndex > lastIndex ifTrue: [ f _ f - self maxEntries ].
	i _ (lastIndex - count max: f) \\ self maxEntries + 1.
	[
		string _ entries at: i.	
		port displayString: string from: 1 to: string size at: x@y strikeFont: font kern: font baseKern negated.
		y _ y + fh.
		i = lastIndex
	] whileFalse: [ i _ i \\ self maxEntries + 1 ].

	string _ unfinishedEntry contents.	
	port displayString: string from: 1 to: string size at: x@y strikeFont: font kern: font baseKern negated.! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 4/11/2012 21:57' prior: 16978340!
               displayUnfinishedEntryOn: aForm

	| font port count string x y fh |
	port _ BitBlt toForm: aForm.
	port clipWidth: innerRectangle right.
	font _ StrikeFont default.
	port installStrikeFont: font foregroundColor: Color black.
	
	fh _ font height.
	count _ innerRectangle height // fh-1.
	x _ innerRectangle left.

	string _ unfinishedEntry contents.
	y _ ((lastIndex - firstIndex \\ self maxEntries) min: count-1) + 1 * font height + innerRectangle top.
	port displayString: string from: 1 to: string size at: x@y strikeFont: font kern: font baseKern negated.! !

StrikeFont removeSelector: #characters:in:displayAt:clippedBy:rule:fillColor:!

StrikeFont removeSelector: #characters:in:displayAt:clippedBy:rule:fillColor:!

StrikeFont removeSelector: #displayLine:at:!

StrikeFont removeSelector: #displayLine:at:!

StrikeFont removeSelector: #displayString:on:from:to:at:kern:!

StrikeFont removeSelector: #displayString:on:from:to:at:kern:!

StrikeFont removeSelector: #installOn:foregroundColor:!

StrikeFont removeSelector: #installOn:foregroundColor:!

AbstractFont removeSelector: #displayString:on:from:to:at:kern:!

AbstractFont removeSelector: #displayString:on:from:to:at:kern:!

AbstractFont removeSelector: #installOn:foregroundColor:!

AbstractFont removeSelector: #installOn:foregroundColor:!

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4211-SmallTextRenderCleanup-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 7:55:17 am'!
!Theme class methodsFor: 'user interface' stamp: 'jmv 4/12/2012 07:54' prior: 16976584!
                          changeTheme

	| themes set menu result |
		themes _ Theme allSubclasses copyWith: Theme.
		set _ themes collect: [ :i | { i asString . i } ].
		menu _ SelectionMenu fromArray: set asArray.
		result _ menu startUpWithCaption: 'Choose a theme'.

	result ifNotNil: [
		result beCurrent ]! !

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4212-ThemeSelectionWalkbackFix-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 8:28:36 am'!
!HaloMorph methodsFor: 'private' stamp: 'jmv 4/12/2012 08:02' prior: 50336187!
                          addHandle: handleSpec on: eventName send: selector to: recipient 
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint iconName colorToUse icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle bounds: (Rectangle center: aPoint extent: HandleSize asPoint).
	(iconName _ handleSpec iconSymbol) ifNotNil: [
			| form |
			form _ Icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon.
				icon morphPositionInOwner: 0@0 ]].
	handle 
		on: #mouseUp
		send: #endInteraction
		to: self.
	handle 
		on: eventName
		send: selector
		to: recipient.
	handle 
		setBalloonText: (target balloonHelpTextForHandle: handle).
	^handle! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 4/12/2012 08:11' prior: 50336333!
                   popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem
	"Present this menu at the given point under control of the given hand."

	| delta tryToPlace selectedOffset |
	hand world startSteppingSubmorphsOf: self.
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition - self morphPosition.
	sourceItem owner owner addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self fullBounds amountToTranslateWithin: sourceItem world bounds.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPoint first value: false;
		value: rightOrLeftPoint last - (self morphWidth @ 0) value: false;
		value: rightOrLeftPoint first value: true! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 4/12/2012 08:24' prior: 16920783!
                           cuisDefaults
	"
	Preferences cuisDefaults
	"
	self setPreferencesFrom:

	#(
		(balloonHelpEnabled true)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds false)
		(checkForSlips true)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic false)
		(menuKeyboardControl true)
		(optionalButtons true)
		(extraDebuggerButtons true)
		(simpleMenus false)
		(smartUpdating true)
		(subPixelRenderFonts true)
		(thoroughSenders true)
	)! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 4/12/2012 08:24' prior: 16920802!
                             slowMachine

	self setPreferencesFrom: #(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic true)
		(menuKeyboardControl false)
		(optionalButtons false)
		(simpleMenus false)
		(smartUpdating false)
		(subPixelRenderFonts false)
		(thoroughSenders false)
	).
	ClassicTheme beCurrent! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 4/12/2012 08:24' prior: 16920820!
                              smalltalk80
	"A traditional monochrome Smalltalk-80 look and feel, clean and austere, and lacking many features added to Squeak in recent years. Caution: this theme removes the standard Squeak flaps, turns off the 'smartUpdating' feature that keeps multiple browsers in synch, and much more."

	self setPreferencesFrom:

	#(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(simpleMenus false)
		(smartUpdating false)
		(thoroughSenders false)
	)! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/12/2012 08:08' prior: 50331732!
                               morphPosition: newPos

	super morphPosition: newPos.

	self flag: #jmvVer2. "Maybe this would be better done in methods storing in #bounds...
	Better yet would be to remove this crap"
	isCollapsed
		ifTrue: [ collapsedFrame _ bounds ]
		ifFalse: [ fullFrame _ bounds ]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:25' prior: 16965536!
                      collapse

	| cf |
		
	self isCollapsed ifFalse: [

		"Collapse -- remove panes from morphics structure"

		isCollapsed _ true.
		fullFrame _ bounds.

		"First save latest fullFrame"
		layoutMorph ifNotNil: [ layoutMorph hide ].
		cf := RealEstateAgent assignCollapseFrameFor: self.
		collapsedFrame ifNil: [
			collapsedFrame _ cf].
		self bounds: cf.
	
		Taskbar visible ifTrue: [ Taskbar minimize: self ]
	]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:24' prior: 16965573!
         expand
	self isCollapsed
		ifTrue: [
		
			"Expand -- restore panes to morphics structure"
	
			isCollapsed _ false.
			self activate.  "Bring to front first"

			collapsedFrame _ bounds.

			self bounds: fullFrame.
			layoutMorph ifNotNil: [ layoutMorph show ].
			
			Taskbar visible ifTrue: [ Taskbar restore: self. ]
		]! !

SystemWindow removeSelector: #getCollapsedFrame!

SystemWindow removeSelector: #getCollapsedFrame!

Preferences class removeSelector: #collapseWindowsInPlace!

Preferences class removeSelector: #collapseWindowsInPlace!

PasteUpMorph removeSelector: #morphPosition:!

PasteUpMorph removeSelector: #morphPosition:!

HaloMorph removeSelector: #morphPosition:!

HaloMorph removeSelector: #morphPosition:!

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4213-SimplifyWindowCollapse-jmv.3.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 8:42:41 am'!

!classDefinition: #SystemWindow category: #'Morphic-Views for Models'!
PluggableMorph subclass: #SystemWindow
	instanceVariableNames: 'labelString collapsedFrame fullFrame isCollapsed updatablePanes widgetsColor layoutMorph adjusters'
	classVariableNames: 'TopWindow'
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

PluggableMorph subclass: #SystemWindow
	instanceVariableNames: 'labelString collapsedFrame fullFrame isCollapsed updatablePanes widgetsColor layoutMorph adjusters '
	classVariableNames: 'TopWindow '
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 4/12/2012 08:36' prior: 50338606!
                 makeMeVisible 

	self world morphExtent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: extent world: self world) topLeft! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/12/2012 08:39' prior: 50334127!
                    justDroppedInto: aMorph event: anEvent
	isCollapsed
		ifTrue: [
			self morphPosition: (self morphPosition max: 0@0) ]
		ifFalse: [
			TopWindow ~~ self ifTrue: [self activate]].
	^super justDroppedInto: aMorph event: anEvent! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/12/2012 08:39' prior: 50338625!
        morphExtent: aPoint 
	"Set the receiver's extent to value provided. Respect my minimumExtent."

	| newExtent |
	newExtent _ self isCollapsed
		ifTrue: [aPoint]
		ifFalse: [aPoint max: self minimumExtent].
	newExtent = extent ifTrue: [^ self].

	isCollapsed
		ifTrue: [super morphExtent: newExtent x @ (self labelHeight + 2)]
		ifFalse: [super morphExtent: newExtent]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:41' prior: 50339696!
                    collapse
		
	self isCollapsed ifFalse: [

		"Collapse -- remove panes from morphics structure"

		isCollapsed _ true.
		layoutMorph ifNotNil: [ layoutMorph hide ].
		self morphExtent: 400@(self labelHeight + 2).
	
		Taskbar visible ifTrue: [ Taskbar minimize: self ]
	]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:33' prior: 50339712!
                     expand
	self isCollapsed
		ifTrue: [
		
			"Expand -- restore panes to morphics structure"
	
			isCollapsed _ false.
			self activate.  "Bring to front first"

			self morphExtent: 400@300.

			layoutMorph ifNotNil: [ layoutMorph show ].
			
			Taskbar visible ifTrue: [ Taskbar restore: self. ]
		]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:38' prior: 16965590!
                       expandBoxHit
	"The full screen expand box has been hit"

	isCollapsed ifTrue: [
		self hide.
		self collapseOrExpand.
		self fullScreen.
		^ self show].
	self fullScreen! !

SystemWindow removeSelector: #collapsedExtent!

SystemWindow removeSelector: #collapsedExtent!

SystemWindow removeSelector: #collapsedFrame!

SystemWindow removeSelector: #collapsedFrame!

SystemWindow removeSelector: #morphPosition:!

SystemWindow removeSelector: #morphPosition:!

SystemWindow removeSelector: #unexpandedFrame!

SystemWindow removeSelector: #unexpandedFrame!

SystemWindow removeSelector: #unexpandedFrame:!

SystemWindow removeSelector: #unexpandedFrame:!

!classDefinition: #SystemWindow category: #'Morphic-Views for Models'!
PluggableMorph subclass: #SystemWindow
	instanceVariableNames: 'labelString isCollapsed updatablePanes widgetsColor layoutMorph adjusters'
	classVariableNames: 'TopWindow'
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

PluggableMorph subclass: #SystemWindow
	instanceVariableNames: 'labelString isCollapsed updatablePanes widgetsColor layoutMorph adjusters'
	classVariableNames: 'TopWindow'
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

RealEstateAgent class removeSelector: #assignCollapseFrameFor:!

RealEstateAgent class removeSelector: #assignCollapseFrameFor:!

RealEstateAgent class removeSelector: #assignCollapsePointFor:!

RealEstateAgent class removeSelector: #assignCollapsePointFor:!

RealEstateAgent class removeSelector: #initialFrameFor:!

RealEstateAgent class removeSelector: #initialFrameFor:!

RealEstateAgent class removeSelector: #initialFrameFor:initialExtent:!

RealEstateAgent class removeSelector: #initialFrameFor:initialExtent:!

RealEstateAgent class removeSelector: #standardPositions!

RealEstateAgent class removeSelector: #standardPositions!

RealEstateAgent class removeSelector: #strictlyStaggeredInitialFrameFor:initialExtent:!

RealEstateAgent class removeSelector: #strictlyStaggeredInitialFrameFor:initialExtent:!

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4214-AdditionalCollapseSimplification-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 8:58:08 am'!
!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 4/12/2012 08:56' prior: 50338816!
           buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	"

	| resizeFactor outerBox arrowMorph resizedForm f |
	resizeFactor _ 4.
	outerBox _ RectangleMorph new.
	outerBox
		morphExtent: finalSizeInteger asPoint * resizeFactor;
		borderWidth: 0;
		color: Color transparent.
	
	arrowMorph _ self buildArrowIn: outerBox bounds.
	outerBox addMorphFront: arrowMorph.
	arrowMorph morphPositionInOwner: 12@8.	"not a clue why these numbers work..."
	
	
	f _ outerBox imageForm: 32.
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotateBy: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotateBy: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotateBy:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4215-SmallCleanup-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 9:04:10 am'!
!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 4/12/2012 09:01' prior: 50336482!
       addToScroller: aMorph

	scroller addMorph: aMorph.
	aMorph morphPositionInOwner: 0@0! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 4/12/2012 09:03' prior: 50333511!
              scrollerOffset: newOffset
	| delta |
	delta _ borderWidth + self xtraBorder.
	scroller morphPositionInOwner: delta@delta - newOffset! !

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4216-SmallCleanup2-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 9:15:45 am'!
!Morph methodsFor: 'geometry' stamp: 'jmv 4/12/2012 09:11' prior: 50331977!
 align: aPoint1 with: aPoint2
	"Translate by aPoint2 - aPoint1."

	^ self morphPositionInOwner: self morphPositionInOwner + (aPoint2 - aPoint1)! !
!Morph methodsFor: 'geometry' stamp: 'jmv 4/12/2012 09:12' prior: 50336832!
  bounds: newBounds
	| oldExtent newExtent |

	"remove senders and implementors"
	self flag: #jmvVer2.
		
	oldExtent _ bounds extent.
	newExtent _ newBounds extent.
	"Moving stuff around is most likely the most common operation.
	Optimize it"
	oldExtent = newExtent ifTrue: [
		^self morphPositionInWorld: newBounds topLeft ].
	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[
		"We're growing. First move then resize."
		self morphPositionInWorld: newBounds topLeft; morphExtent: newExtent.
	] ifFalse: [
		"We're shrinking. First resize then move."
		self morphExtent: newExtent; morphPositionInWorld: newBounds topLeft.
	].! !
!Morph methodsFor: 'geometry eToy' stamp: 'jmv 4/12/2012 09:13' prior: 16897917!
                            referencePosition
	"Return the current reference position of the receiver"
	"a rather ugly way to say #center . At least, we avoid false polymorphism"
	"remove some day"
	self flag: #jmvVer2.
	^bounds center! !
!Morph methodsFor: 'geometry eToy' stamp: 'jmv 4/12/2012 09:13' prior: 50335176!
                            referencePosition: aPoint
	"a rather ugly way to say #center: . Just for consistency with #referencePosition"
	"remove some day"
	self flag: #jmvVer2.
	self morphPositionInWorld: aPoint - (bounds extent // 2)! !
!SketchMorph methodsFor: 'accessing' stamp: 'jmv 4/12/2012 09:14' prior: 50333919!
                         form: aForm
	"Set the receiver's form"

	| oldForm |
	oldForm _ originalForm.
	originalForm _ aForm.
	self basicExtent: originalForm extent.

	oldForm ifNotNil: [ self morphPositionInOwner: self morphPositionInOwner + (oldForm extent - aForm extent // 2) ]! !
!StarMorph methodsFor: 'editing' stamp: 'jmv 4/12/2012 09:14' prior: 50334086!
             dragVertex: label event: evt fromHandle: handle
	| ext oldR pt center |
	label == #center ifTrue: [
		self morphPositionInOwner: self morphPositionInOwner + (evt eventPosition - handle referencePosition)].

	label == #outside ifTrue: [
		center _ handles first referencePosition.
		pt _ center - evt eventPosition.
		ext _ pt r.
		oldR _ ext.
		vertices _ (0 to: 359 by: (360//vertices size)) collect: [ :angle |
			(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse: [ext])
					degrees: angle + pt degrees)
				+ center].
		handle align: handle referencePosition with: evt eventPosition ].

	self computeBounds.
! !

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4217-SmallCleanup3-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 10:41:12 am'!
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 10:38'!
    freeSliderRoom
	"Answer the length or height of the free slider area, i.e. substract the slider itself"

	^ (self isHorizontal
		ifTrue: [ self morphExtent x - slider morphExtent x]
		ifFalse: [ self morphExtent y - slider morphExtent y])
			- (borderWidth * 2) - (self buttonExtent * 2).! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 10:38'!
                            totalSliderRoom
	"Answer the length or height of the slider area"

	^ (self isHorizontal
		ifTrue: [ self morphExtent x ]
		ifFalse: [ self morphExtent y ])
			- (borderWidth * 2) - (self buttonExtent * 2).! !
!ScrollBar methodsFor: 'testing' stamp: 'jmv 4/12/2012 09:51'!
               isHorizontal
	| e |
	e _ self morphExtent.
	^e x > e y! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 10:27' prior: 50333899!
                      computeSlider

	| delta |
	delta _ self buttonExtent + (self freeSliderRoom * value) asInteger.
	self isHorizontal
		ifTrue: [
			slider morphPositionInOwner: borderWidth +  delta @ borderWidth ]
		ifFalse: [
			slider morphPositionInOwner: borderWidth @ (borderWidth + delta) ] ! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 10:20' prior: 50337385!
                     expandSlider
	"Compute the new size of the slider (use the old sliderThickness as a minimum)."

	| e |
	e _ (self totalSliderRoom * interval) asInteger max: 7.
	slider morphExtent: (self isHorizontal
		ifTrue: [ e @ self buttonExtent ]
		ifFalse: [ self buttonExtent @ e ])! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 09:52' prior: 50338579!
                           morphExtent: newExtent

	| newExtentToUse |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent = extent ifTrue: [^ self].
	newExtentToUse _ self isHorizontal
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = extent ifTrue: [^ self].
	super morphExtent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 4/12/2012 09:57' prior: 16934969!
                         initializeDownButton
	"initialize the receiver's downButton"

	| e |
	e _ self buttonExtent.
	downButton _ self buttonClass new.
	downButton model: self.
	self addMorph: downButton.
	downButton
		morphPositionInOwner: self morphExtent - borderWidth - e;
		morphExtent: e.
	self isHorizontal
		ifTrue: [ downButton updateRightButtonImage ]
		ifFalse: [ downButton updateDownButtonImage ]! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 4/12/2012 10:02' prior: 16934983!
        initializeSlider
	"initialize the receiver's slider"

	sliderShadow _ RectangleMorph new.
	sliderShadow borderWidth: 0.
	self addMorph: sliderShadow.
	sliderShadow hide.
		
	slider _ self sliderClass new.
	slider model: self.
	slider grabSelector: #sliderGrabbed.
	slider dragSelector: #scrollAbsolute:.
	slider action: #sliderReleased.
	self addMorph: slider.

	self computeSlider! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 4/12/2012 09:56' prior: 16935000!
             initializeUpButton
	"initialize the receiver's upButton"

	upButton _ self buttonClass new.
	upButton model: self.
	self addMorph: upButton.
	upButton
		morphPositionInOwner: borderWidth@borderWidth;
		morphExtent: self buttonExtent.
	self isHorizontal
		ifTrue: [ upButton updateLeftButtonImage ]
		ifFalse: [ upButton updateUpButtonImage ].! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 4/12/2012 10:38' prior: 16935039!
                     scrollAbsolute: aPoint
	| relativePoint v |
	relativePoint _ aPoint - bounds topLeft.
	v _ (self isHorizontal
		ifTrue: [ relativePoint x ]
		ifFalse: [ relativePoint y ])
			- borderWidth - self buttonExtent * 1.0
				/ self freeSliderRoom.
	self setValue: v! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 4/12/2012 09:53' prior: 50333909!
        setNextDirectionFromEvent: event

	nextPageDirection _ self isHorizontal
		ifTrue: [ event eventPosition x >= slider referencePosition x ]
		ifFalse: [ event eventPosition y >= slider referencePosition y ]! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 4/12/2012 09:30' prior: 16935086!
                              sliderGrabbed

	| delta e |
	sliderShadow
		morphPositionInOwner: slider morphPositionInOwner;
		morphExtent: slider morphExtent;
		show! !

ScrollBar removeSelector: #freeSliderSpace!

ScrollBar removeSelector: #roomToMove!

ScrollBar removeSelector: #roomToMove!

ScrollBar removeSelector: #sliderExtent!

ScrollBar removeSelector: #sliderExtent!

ScrollBar removeSelector: #totalSliderArea!

ScrollBar removeSelector: #totalSliderArea!

ScrollBar removeSelector: #totalSliderHeight!

ScrollBar removeSelector: #totalSliderSpace!

ScrollBar removeSelector: #totalSliderWidth!

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4218-ScrollBarCleanup-jmv.7.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4218] on 20 April 2012 at 2:50:57 pm'!
!Morph methodsFor: 'meta-actions' stamp: 'jmv 4/20/2012 14:45'!
                dismissMorph
	| w |
	w _ self world ifNil:[^self].
	w deleteAllHalos; stopStepping: self.
	self delete
! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 4/20/2012 14:46'!
                     resizeMorph
	| handle |
	handle := HandleMorph new 
				forEachPointDo: [:newPoint | self morphExtent: newPoint - bounds topLeft].
	self activeHand attachMorph: handle.
	handle startStepping! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 4/20/2012 14:46' prior: 16898960!
              resizeFromMenu
	"Commence an interaction that will resize the receiver"

	self resizeMorph! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 4/20/2012 14:45' prior: 16899493!
          dismissViaHalo
	"The user has clicked in the delete halo-handle.  This provides a hook in case some concomitant action should be taken, or if the particular morph is not one which should be put in the trash can, for example."

	^ self dismissMorph! !
!HandMorph methodsFor: 'event handling' stamp: 'jmv 4/20/2012 14:47' prior: 16864966!
               processEvents
	"Process user input events from the local input devices."

	| evt evtBuf type hadAny |

	hadAny := false.
	[ (evtBuf := Sensor nextEvent) isNil ] whileFalse: [
		evt := nil.	"for unknown event types"
		type := evtBuf first.
		type = EventSensor eventTypeMouse
			ifTrue: [ evt := self generateMouseEvent: evtBuf ].
		type = EventSensor eventTypeKeyboard 
			ifTrue: [ evt := self generateKeyboardEvent: evtBuf ].
		type = EventSensor eventTypeWindow
			ifTrue: [ evt _ self generateWindowEvent: evtBuf ].
		"All other events are ignored"
		evt
			ifNil: [
				^hadAny]
			ifNotNil: [
				"Finally, handle it"
				self handleEvent: evt.
				hadAny := true.
				"For better user feedback, return immediately after a mouse event has been processed."
				evt isMouse ifTrue: [ ^hadAny ]]].
	"note: if we come here we didn't have any mouse events"
	mouseClickState 
		ifNotNil: [ 
			"No mouse events during this cycle. Make sure click states time out accordingly"
			mouseClickState
				handleEvent: (lastMouseEvent asMouseMove: (Time millisecondClockValue - lastMouseEventTime max: 0))
				from: self ].
	^hadAny! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 4/20/2012 14:47' prior: 16865656!
  sendEvent: anEvent
	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."

	^owner processEvent: anEvent! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 4/20/2012 14:48' prior: 16865666!
                    sendFocusEvent: anEvent to: focusHolder in: world
	"Send the event to focusHolder, the morph currently holding the focus"
	| result |
	world becomeActiveDuring: [
		ActiveHand _ self.
		result _ focusHolder handleFocusEvent: anEvent ].
	^result! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 4/20/2012 14:48' prior: 16879952!
                        layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableWidth sumOfFixed normalizationFactor availableForPropWidth widths l usableHeight boundsTop boundsRight r t b |
	xSep _ self xSeparation.
	ySep _ self ySeparation.
	usableWidth _ boundsForLayout width - ((submorphs size + 1) * xSep).
	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedWidth ].
	availableForPropWidth _ usableWidth - sumOfFixed.
	padding ifNil: [	"shrink"
		availableForPropWidth = 0 ifFalse: [
			self flag: #jmvVer2.
			self width: self width - availableForPropWidth.
			^ self layoutSubmorphsAndComputeFullBounds ]].
	normalizationFactor _ self proportionalWidthNormalizationFactor.
	availableForPropWidth _ availableForPropWidth * normalizationFactor.
	widths _ submorphs collect: [ :m | m layoutSpec widthFor: availableForPropWidth ].
	l _ ((usableWidth - widths sum) * (padding ifNil: [0]) + xSep max: 0) +  boundsForLayout left.
	usableHeight _ boundsForLayout height - (2*ySep) max: 0.
	boundsTop _ boundsForLayout top.	
	boundsRight _ boundsForLayout right.
	submorphs size to: 1 by: -1 do: [ :index | | m w h ls |
		m _ submorphs at: index.
		w _ widths at: index.
		"major direction"
		r _ l + w min: boundsRight.
		"minor direction"
		ls _ m layoutSpec.
		h _ (ls heightFor: usableHeight) min: usableHeight.
		t _ (usableHeight - h) * ls minorDirectionPadding + ySep + boundsTop.
		b _ t + h.
		"Set bounds and adjust major direction for next step"
		m bounds: (l rounded @ t rounded corner: r rounded @ b rounded).
		w > 0 ifTrue: [
			l _ r + xSep min: boundsRight ]]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 4/20/2012 14:48' prior: 16880005!
                     layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableHeight sumOfFixed normalizationFactor availableForPropHeight heights t usableWidth boundsLeft boundsBottom b l r |
	xSep _ self xSeparation.
	ySep _ self ySeparation.
	usableHeight _ boundsForLayout height - ((submorphs size + 1) * ySep).
	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedHeight ].
	availableForPropHeight _ usableHeight - sumOfFixed.
	padding ifNil: [	"shrink"
		availableForPropHeight = 0 ifFalse: [
			self flag: #jmvVer2.
			self height: self height - availableForPropHeight.
			^ self layoutSubmorphsAndComputeFullBounds ]].
	normalizationFactor _ self proportionalHeightNormalizationFactor.
	availableForPropHeight _ availableForPropHeight * normalizationFactor.
	heights _ submorphs collect: [ :m | m layoutSpec heightFor: availableForPropHeight ].
	t _ ((usableHeight - heights sum) * (padding ifNil: [0]) + ySep max: 0) +  boundsForLayout top.
	usableWidth _ boundsForLayout width - (2*xSep) max: 0.
	boundsLeft _ boundsForLayout left.	
	boundsBottom _ boundsForLayout bottom.
	submorphs size to: 1 by: -1 do: [ :index | | m h w ls |
		m _ submorphs at: index.
		h _ heights at: index.
		"major direction"
		b _ t + h min: boundsBottom.
		"minor direction"
		ls _ m layoutSpec.
		w _ (ls widthFor: usableWidth) min: usableWidth.
		l _ (usableWidth - w) * ls minorDirectionPadding + xSep + boundsLeft.
		r _ l + w.
		"Set bounds and adjust major direction for next step"
		m bounds: (l rounded @ t rounded corner: r rounded @ b rounded).
		h > 0 ifTrue: [
			t _ b + ySep min: boundsBottom ]]! !
!PasteUpMorph methodsFor: 'initialization' stamp: 'jmv 4/20/2012 14:49' prior: 16911793!
                        becomeActiveDuring: aBlock
	"Make the receiver the ActiveWorld during the evaluation of aBlock.
	Note that this method does deliberately *not* use #ensure: to prevent
	re-installation of the world on project switches."
	| priorWorld priorHand |
	priorWorld _ ActiveWorld.
	priorHand _ ActiveHand.
	ActiveWorld _ self.
	ActiveHand _ self hands first. "default"
	aBlock
		on: Error
		do: [:ex | 
			ActiveWorld _ priorWorld.
			ActiveHand _ priorHand.
			ex pass]! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 4/20/2012 14:50' prior: 16912464!
                         install
	owner := nil.	"since we may have been inside another world previously"
	ActiveWorld := self.
	ActiveHand := self hands first.	"default"
	submorphs do: [:ss | ss owner ifNil: [ss privateOwner: self]].
	"Transcript that was in outPointers and then got deleted."
	self viewBox: Display boundingBox.
	Sensor flushAllButDandDEvents.
	worldState handsDo: [:h | h initForEvents].
	self borderWidth: 0.	"default"
	SystemWindow noteTopWindowIn: self.
	self displayWorldSafely! !
!ProjectX class methodsFor: 'as yet unclassified' stamp: 'jmv 4/20/2012 14:50' prior: 16923664!
 interruptNameX: labelString
	"Create a Notifier on the active scheduling process with the given label."
	| preemptedProcess projectProcess |
	
	ActiveHand ifNotNil:[ActiveHand interrupted].
	ActiveWorld _ World. "reinstall active globals"
	ActiveHand _ World activeHand.
	ActiveHand interrupted. "make sure this one's interrupted too"

	projectProcess _ ProjectX uiProcessX.	"we still need the accessor for a while"
	preemptedProcess _ Processor preemptedProcess.
	"Only debug preempted process if its priority is >= projectProcess' priority"
	preemptedProcess priority < projectProcess priority ifTrue:[
		projectProcess suspend.
		preemptedProcess _ projectProcess.
	] ifFalse:[
		preemptedProcess suspend.
	].
	Debugger openInterrupt: labelString onProcess: preemptedProcess
! !

Morph removeSelector: #dismissMorph:!

Morph removeSelector: #dismissMorph:!

Morph removeSelector: #resizeMorph:!

Morph removeSelector: #resizeMorph:!

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4219-KillActiveEvent-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #4219] on 11 May 2012 at 3:17:29 pm'!
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 4/27/2012 16:38' prior: 50335668!
                       bringWindowsFullOnscreen
	"Make ever SystemWindow on the desktop be totally on-screen, whenever possible."
	
	(SystemWindow windowsIn: self satisfying: [:w | true]) do: [ :each |
		each makeMeFullyVisible ]! !

----End fileIn of I:\Cuis\CambiosParaIrAMorphic3\4220-CuisCore-JuanVuletich-2012May11-15h11m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1260] on 25 April 2012 at 10:29:12 am'!

!classDefinition: #ChangeSet category: #'Tools-Changes'!
Object subclass: #ChangeSet
	instanceVariableNames: 'name preamble postscript changeRecords structures superclasses isForBaseSystem hasUnsavedChanges'
	classVariableNames: 'CurrentBaseCSNumber Installing'
	poolDictionaries: ''
	category: 'Tools-Changes'!

Object subclass: #ChangeSet
	instanceVariableNames: 'name preamble postscript changeRecords structures superclasses isForBaseSystem hasUnsavedChanges '
	classVariableNames: 'CurrentBaseCSNumber Installing '
	poolDictionaries: ''
	category: 'Tools-Changes'!
!ChangeSet methodsFor: 'accessing' stamp: 'jmv 4/25/2012 09:46'!
            hasUnsavedChanges

	^hasUnsavedChanges! !
!ChangeSet methodsFor: 'accessing' stamp: 'jmv 4/25/2012 09:46'!
                     hasUnsavedChanges: aBoolean

	hasUnsavedChanges _ aBoolean.
	self triggerEvent: #dirtyFlagChanged! !
!ChangeSet methodsFor: 'accessing' stamp: 'jmv 4/25/2012 10:18'!
                          isForBaseSystem: aBoolean

	isForBaseSystem _ aBoolean! !
!ChangeSorter class methodsFor: 'enumerating' stamp: 'jmv 4/25/2012 10:24'!
                          existingOrNewChangeSetNamed: aName forBaseSystem: aBoolean

	| newSet |

	^(self changeSetNamed: aName)
		ifNotNil: [ :existing |
			existing assert: existing isForBaseSystem = aBoolean ]
		ifNil: [
			newSet _ ChangeSet basicNewNamed: aName.
			newSet isForBaseSystem: aBoolean.
			AllChangeSets add: newSet.
			newSet ]! !
!CodePackage class methodsFor: 'packages access' stamp: 'jmv 4/25/2012 09:34'!
            named: aString createIfAbsent: neverAnswerNil registerIfNew: doRegisterIfJustCreated
	"Answer the instance with name aString.
	If there's no package named aString, answer nil or a new instance as requested.
	If a new instance is created, register it or not as requested.
	CodePackage named: 'Morphic' createIfAbsent: false registerIfNew: false
	CodePackage named: 'Morphic' createIfAbsent: true registerIfNew: false
	CodePackage named: 'XXXXXTest' createIfAbsent: true registerIfNew: true
	"

	| answer newInstance |
	answer _ InstalledPackages
		at: aString
		ifAbsent: [
			neverAnswerNil ifTrue: [ 
				newInstance _ self new packageName: aString.
				doRegisterIfJustCreated ifTrue: [ self register: newInstance ].
				newInstance ]].
	^ answer! !
!ChangeSet methodsFor: 'initialize-release' stamp: 'jmv 4/25/2012 10:24' prior: 16799784!
                      clear 
	"Reset the receiver to be empty.  "

	changeRecords _ Dictionary new.
	preamble _ nil.
	postscript _ nil.
	self hasUnsavedChanges: false.
	self isForBaseSystem: true 	"Not a great default, but at least some Boolean"! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:50' prior: 16799811!
       noteAddClass: class
	"Include indication that a new class was created."

	class wantsChangeSetLogging ifFalse: [^ self].
	self atClass: class add: #new.
	self atClass: class add: #change.
	self addCoherency: class name.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:52' prior: 16799821!
             noteChangeClass: class from: oldClass
	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."

	class wantsChangeSetLogging ifFalse: [^ self].
	class isMeta 
		ifFalse: [self atClass: class add: #change]	"normal"
		ifTrue: [((self classChangeAt: class theNonMetaClass name) includes: #add) 
			ifTrue: [self atClass: class add: #add] 	"When a class is defined, the metaclass
				is not recorded, even though it was added.  A further change is
				really just part of the original add."
			ifFalse: [self atClass: class add: #change]].
	self addCoherency: class name.
	(self changeRecorderFor: class) notePriorDefinition: oldClass.
	self noteClassStructure: oldClass.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:56' prior: 16799847!
      noteClassMoveToOtherPackage: class
	"The class is about to be moved to some other package, who will hold it.
	Adjust the receiver to reflect that fact."

	class wantsChangeSetLogging ifFalse: [^ self].
	self atClass: class add: #movedToOtherPackage.
	changeRecords removeKey: class class name ifAbsent: nil.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:56' prior: 16799859!
                     noteMethodMoveToOtherPackage: selector forClass: class

	class wantsChangeSetLogging ifFalse: [^ self].
	(self changeRecorderFor: class)
		noteMethodMoveToOtherPackage: selector.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:54' prior: 16799867!
                      noteNewMethod: newMethod forClass: class selector: selector priorMethod: methodOrNil

	class wantsChangeSetLogging ifFalse: [^ self].
	(self changeRecorderFor: class)
		noteNewMethod: newMethod selector: selector priorMethod: methodOrNil.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 10:10' prior: 16799877!
                          noteRemoveSelector: selector class: class priorMethod: priorMethod lastMethodInfo: info
	"Include indication that a method has been forgotten.
	info is a pair of the source code pointer and message category
	for the method that was removed."

	class wantsChangeSetLogging ifFalse: [^ self].
	(self changeRecorderFor: class)
		noteRemoveSelector: selector priorMethod: priorMethod lastMethodInfo: info.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:54' prior: 16799892!
                       noteRenameClass: class as: newName 
	"Include indication that a class has been renamed."

	| recorder |
	(recorder _ self changeRecorderFor: class)
		noteChangeType: #rename;
		noteNewName: newName asSymbol.
		
	"store under new name (metaclass too)"
	changeRecords at: newName put: recorder.
	changeRecords removeKey: class name.
	self noteClassStructure: class.

	recorder _ changeRecords at: class class name ifAbsent: [nil].
	recorder ifNotNil: [
		changeRecords at: (newName, ' class') put: recorder.
		changeRecords removeKey: class class name.
		recorder noteNewName: newName , ' class' ].

	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'accessing' stamp: 'jmv 4/25/2012 10:18' prior: 16800026!
                        isForBaseSystem

	^isForBaseSystem! !
!ChangeSet methodsFor: 'method changes' stamp: 'jmv 4/25/2012 10:07' prior: 16800128!
    removeSelectorChanges: selector class: class 
	"Remove all memory of changes associated with the argument, selector, in 
	this class."

	| chgRecord |
	(chgRecord _ changeRecords at: class name ifAbsent: [^ self])
		removeSelector: selector.
	chgRecord hasNoChanges ifTrue: [changeRecords removeKey: class name].
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 4/25/2012 09:56' prior: 16800245!
                 noteClassForgotten: className
	"Remove from structures if class is not a superclass of some other one we are remembering"

	structures ifNil: [^ self].
	Smalltalk at: className ifPresent: [:cls |
		cls subclasses do: [:sub | (structures includesKey: sub) ifTrue: [
			^ self]]].  "No delete"
	structures removeKey: className ifAbsent: nil.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 4/25/2012 09:51' prior: 16800290!
                      noteCommentClass: class 
	"Include indication that a class comment has been changed."

	class wantsChangeSetLogging ifFalse: [^ self].
	self atClass: class add: #comment.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 4/25/2012 09:52' prior: 16800298!
                               noteRemovalOf: class
	"The class is about to be removed from the system.
	Adjust the receiver to reflect that fact."

	class wantsChangeSetLogging ifFalse: [^ self].
	(self changeRecorderFor: class)
		noteChangeType: #remove fromClass: class.
	changeRecords removeKey: class class name ifAbsent: nil.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 4/25/2012 09:54' prior: 16800310!
                             noteReorganizeClass: class 
	"Include indication that a class was reorganized."

	self atClass: class add: #reorganize.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 10:01' prior: 16800575!
                     assurePreambleExists
	"Make sure there is a TextModel holding the preamble; if it's found to have reverted to empty contents, put up the template"

	(preamble == nil or: [preamble actualContents isEmptyOrNil])
		ifTrue: [
			preamble _ TextModel withText: self preambleTemplate.	
			self hasUnsavedChanges: true ]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 10:02' prior: 16800715!
                 fileOut
	"File out the receiver, to a file whose name is a function of the  
	change-set name and either of the date & time or chosen to have a  
	unique numeric tag, depending on the preference  
	'changeSetVersionNumbers'"
	| slips nameToUse |
	self checkForConversionMethods.
	nameToUse := Preferences changeSetVersionNumbers
				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name coda: '-', Utilities authorInitials extension: 'cs']
				ifFalse: [(self name , FileDirectory dot , Utilities dateTimeSuffix , FileDirectory dot , 'cs') asFileName].
	Cursor write
		showWhile: [
			| file |
			file := self defaultChangeSetDirectory newFileNamed: nameToUse.
			[
				file timeStamp.
				self fileOutPreambleOn: file.
				self fileOutOn: file.
				self fileOutPostscriptOn: file]
					ensure: [file close]].
	
	self hasUnsavedChanges: false.
	Preferences checkForSlips
		ifFalse: [^ self].
	slips := self checkForSlips.
	(slips size > 0
			and: [(PopUpMenu withCaption: 'Methods in this fileOut have halts
or references to the Transcript
or other ''slips'' in them.
Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')
					= 2])
		ifTrue: [Smalltalk browseMessageList: slips name: 'Possible slips in ' , name]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 10:25' prior: 16800921!
                       objectForDataStream: refStrm
	"I am about to be written on an object file.  Write a path to me in the other system instead."

	"try to write reference for me"
	^ DiskProxy 
		global: #ChangeSorter
		selector: #existingOrNewChangeSetNamed:forBaseSystem:
		args: (Array with: self name with: self isForBaseSystem)
"===
	refStrm replace: self with: nil.
	^ nil
==="
! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 09:58' prior: 16800942!
                               postscriptString: aString

	postscript _ TextModel withText: aString.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 09:58' prior: 16800954!
       preambleString: aString
	"Establish aString as the new contents of the preamble.  "

	preamble _ TextModel withText: aString.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'system change notifications' stamp: 'jmv 4/25/2012 09:52' prior: 16801090!
                              classRecategorized: aClass from: oldCategory to: newCategory

	"
	self hasUnsavedChanges: true
	"! !
!CodePackage methodsFor: 'saving' stamp: 'jmv 4/25/2012 09:41' prior: 16812828!
           save
	| nameToUse |
	fullFileName ifNil: [
		fullFileName _
			(ChangeSet defaultChangeSetDirectory pathName, FileDirectory slash, 
			self packageName, FileDirectory dot, 'pck')
				asFileName ].
	nameToUse _ fullFileName.
"	nameToUse _ Preferences changeSetVersionNumbers
		ifTrue: [
			ChangeSet defaultChangeSetDirectory
				nextNameFor: self packageName coda: '-', Utilities authorInitials
				extension: 'pck' ]
		ifFalse: [ (self packageName , FileDirectory dot , Utilities dateTimeSuffix , FileDirectory dot , 'pck') asFileName ]."
	Cursor write
		showWhile: [
			| file |
			file _ ChangeSet defaultChangeSetDirectory forceNewFileNamed: nameToUse.
			[
				file timeStamp.
				self writeOnStream: file ]
					ensure: [ file close ]].
	self hasUnsavedChanges: false.
	ChangeSorter removeChangeSet: (ChangeSet changeSetForPackage: self)! !
!CodePackage class methodsFor: 'packages access' stamp: 'jmv 4/25/2012 09:40' prior: 16812988!
                  register: aCodePackage
	"
	Usually call #named:createIfAbsent:registerIfNew: instead
	CodePackage register: (CodePackage newNamed: 'Tests-Files')
	"
	InstalledPackages at: aCodePackage packageName put: aCodePackage.
	self triggerEvent: #installedPackagesChanged! !
!CodePackageFile methodsFor: 'initialize' stamp: 'jmv 4/25/2012 09:35' prior: 16813067!
                               buildFileStream: aFileStream packageName: pkName fullName: fullFileName
	"Just build the PackageFile object. Don't install the code."

	| classesDefined classesExtended classesToDeleteButCant classesToReallyDelete packageInMemory |
	packageName _pkName.
	fullName _fullFileName.
	"Don't register a package!!"
	packageInMemory _ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: false.
	self buildFrom: aFileStream.
	"Compute stuff no longer in package: Should be removed from system."
	classesDefined _ Set new.
	classesExtended _ Set new.
	self classes do: [ :pseudoClass |
		pseudoClass hasDefinition
			ifTrue: [ classesDefined add: pseudoClass name ]
			ifFalse: [ classesExtended add: pseudoClass name ]].
	classesToRemove _ (packageInMemory classes asSet collect: [ :each | each name ]) difference: classesDefined.
	"Add here:
		- classes in classesToDelete, that #allCallsOn answers selectors that aren't in classesToDelete or methodsToRemove
		- classes with #subclasses that aren't in classesToDelete.
		- classes with existing instances (#instanceCount)? Not really sure... Maybe sole instance referenced from classVar or such...
		- something else I forgot?
	Warning: This search for stuff that can't be removed must be iterated again until it doesn't find any more."
	classesToDeleteButCant _ classesToRemove intersection: classesExtended.
	classesToReallyDelete _ classesToRemove difference: classesToDeleteButCant.
	"Methods. Could also mean classes that can't be deleted!! (include in the iteration)
	Warn if deleting last implementor of sent messages?"
	methodsToRemove _ packageInMemory methods asSet difference: self allMethodReferences.
	methodsToRemove _ methodsToRemove reject: [ :methodReference | classesToReallyDelete includes: methodReference classSymbol ].

"
	'=============' print.
	('classesToRemove: ', classesToRemove printString) print.
	('classesToDeleteButCant: ', classesToDeleteButCant printString) print.
	('classesToReallyDelete: ', classesToReallyDelete printString) print.
	'=============' print.
	'methodsToRemove: ' print.
	methodsToRemove do: [ :methodReference | methodReference print ].
	'=============' print.
"! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 4/25/2012 09:36' prior: 16813537!
                            createPackage

	| pkName |
	pkName_ FillInTheBlank request: 'Name for new package?'.
	CodePackage
		named: pkName
		createIfAbsent: true
		registerIfNew: true! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 4/25/2012 10:11' prior: 16961957!
                              okayToDiscardUnsavedCodeSaving: wouldSave
	"Answer true unless the user cancels quitting because of some warning given.
	Smalltalk okayToDiscardUnsavedCodeSaving: true
	Smalltalk okayToDiscardUnsavedCodeSaving: false
	"

	| baseCSdirty dirtyPackages |
	baseCSdirty _ ChangeSorter allChangeSets anySatisfy: [ :any | any isForBaseSystem and: [ any isEmpty hasUnsavedChanges ]].
	dirtyPackages _ CodePackage installedPackages anySatisfy: [ :pck | pck hasUnsavedChanges ].

	baseCSdirty & dirtyPackages ifTrue: [
		wouldSave ifTrue: [
			^self confirm: 'There are both unsaved Packages', String newLineString,
				'      (would need to be saved on next run), ', String newLineString,
				'and unsaved Changes to Cuis core', String newLineString,
				'      (they would be lost as a separate ChangeSet).', String newLineString,
				'Continue?' ]
		ifFalse: [
			^self confirm: 'There are both unsaved Packages', String newLineString,
				'and unsaved Changes to Cuis core.', String newLineString,
				'If you continue, they will all be lost.', String newLineString,
				'Continue?' ]].

	baseCSdirty ifTrue: [
		^self confirm: 'Some ChangeSet for Cuis core might have unsaved changes.', String newLineString,
			'If you continue, they would be lost.', String newLineString,
			'Continue?' ].

	dirtyPackages ifTrue: [
		wouldSave ifTrue: [
			^self confirm: 'There are unsaved Packages.', String newLineString,
				'If you continue, they will need to be saved on next run.', String newLineString,
				'Continue?' ]
		ifFalse: [
			^self confirm: 'There are unsaved Packages.', String newLineString,
				'If you continue, they will all be lost.', String newLineString,
				'Continue?' ]].

	^true! !

!classDefinition: #ChangeSet category: #'Tools-Changes'!
Object subclass: #ChangeSet
	instanceVariableNames: 'name preamble postscript changeRecords structures superclasses hasUnsavedChanges isForBaseSystem'
	classVariableNames: 'CurrentBaseCSNumber Installing'
	poolDictionaries: ''
	category: 'Tools-Changes'!

Object subclass: #ChangeSet
	instanceVariableNames: 'name preamble postscript changeRecords structures superclasses hasUnsavedChanges isForBaseSystem'
	classVariableNames: 'CurrentBaseCSNumber Installing'
	poolDictionaries: ''
	category: 'Tools-Changes'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
| name |
ChangeSet allInstancesDo: [ :each |
	each hasUnsavedChanges: each isEmpty not.
	name _ each name.
	each isForBaseSystem: ((name at: 1) isDigit
		and: [ (name at: 1) isDigit
			and: [ (name at: 1) isDigit
				and: [ (name at: 1) isDigit
					and: [ name is: '-CuisCore-' substingAt: 5 ]]]])]!

----End fileIn of I:\Cuis\CuisUpdates1261-1270\1261-CuisCore-JuanVuletich-2012Apr25-09h17m-jmv.9.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1261] on 25 April 2012 at 9:58:57 pm'!
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 4/25/2012 10:26' prior: 16801492!
   changeSetForBaseSystem

	| csName numberToUse |
	Installing

		ifNil: [
			numberToUse _ self currentBaseCSNumber.
			ChangeSorter allChangeSets
				detect: [ :any | any name initialIntegerOrNil = numberToUse ]
				ifFound: [ :existing | ^existing ]
				ifNone: [
					csName _ (self baseSystemNameFor: numberToUse),
						(String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ]).
					^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: true ]]

		ifNotNil: [
			csName _ 'Affects-BaseSystem--Install-', Installing.
			^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false
			"Changes are for the base system, but are not user's own changes..." ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 4/25/2012 10:25' prior: 16801513!
    changeSetForPackage: aCodePackage

	| csName |
	aCodePackage ifNil: [
		^self changeSetForBaseSystem ].
	csName _ Installing
		ifNil: [ 'UnsavedChangesTo-', aCodePackage name ]
		ifNotNil: [
			Installing = aCodePackage packageName
				ifTrue: [ 'Install-', Installing ]
				ifFalse: [ 'Affects-', aCodePackage name, '--Install-', Installing ]].
	^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false! !
!CodeFileBrowserWindow class methodsFor: 'services' stamp: 'jmv 4/25/2012 09:37' prior: 16812113!
                         installPackageStream: aStream

	| fullName pkName existing |
	fullName _ aStream name.
	pkName _ CodePackageFile packageNameFrom: fullName.
	existing _ CodePackage named: pkName createIfAbsent: false registerIfNew: false.
	(existing isNil
		or: [ existing hasUnsavedChanges not
			or: [ self confirm: 'If you install this package, there are unsaved changes that will be lost.', String newLineString, 'Continue?' ]]) ifTrue: [
		Cursor wait showWhile: [
			CodePackageFile
				installFileStream: aStream
				packageName: pkName
				fullName: fullName ]]! !
!CodePackageFile methodsFor: 'services' stamp: 'jmv 4/25/2012 09:36' prior: 16813151!
                              install: aFileStream
	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."
	| localName newCodePackage |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].
	
	"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"

	"Crear, instalar y devolver una instancia de PackageInfo"
	newCodePackage_ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: true.
	newCodePackage
		fullFileName: fullName;
		sourceSystem: sourceSystem;
		description: description.

	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"
	"These were created in #fromFileStream: ... reuse?"
	localName _ FileDirectory localNameFor: fullName.
	ChangeSet installing: newCodePackage packageName do: [
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ]].
	newCodePackage hasUnsavedChanges: false.
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	"Tirar undeclared al transcript. warning si quedaron undeclared
	Es feo que tire an transcript undeclareds que despues no lo son..."
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	"Descartar la instancia de CodePackageFile"
	^newCodePackage! !

CodePackage class removeSelector: #named:!

CodePackage class removeSelector: #named:!

CodePackage class removeSelector: #newNamed:!

CodePackage class removeSelector: #newNamed:!

CodePackage removeSelector: #register!

CodePackage removeSelector: #register!

ChangeSorter class removeSelector: #existingOrNewChangeSetNamed:!

ChangeSorter class removeSelector: #existingOrNewChangeSetNamed:!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

| name |
ChangeSet allInstancesDo: [ :each |
	each hasUnsavedChanges: each isEmpty not.
	name _ each name.
	each isForBaseSystem: ((name at: 1) isDigit
		and: [ (name at: 1) isDigit
			and: [ (name at: 1) isDigit
				and: [ (name at: 1) isDigit
					and: [ name is: '-CuisCore-' substingAt: 5 ]]]])]!

----End fileIn of I:\Cuis\CuisUpdates1261-1270\1262-CuisCore-JuanVuletich-2012Apr25-21h56m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1260] on 23 April 2012 at 11:21:55 pm'!
!CodePackage methodsFor: 'saving' stamp: 'JMG 4/23/2012 23:21' prior: 50340852!
          save
	| nameToUse |
	fullFileName ifNil: [
		fullFileName _
			ChangeSet defaultChangeSetDirectory fullNameFor: (self packageName, FileDirectory dot, 'pck')].
	nameToUse _ fullFileName.
"	nameToUse _ Preferences changeSetVersionNumbers
		ifTrue: [
			ChangeSet defaultChangeSetDirectory
				nextNameFor: self packageName coda: '-', Utilities authorInitials
				extension: 'pck' ]
		ifFalse: [ (self packageName , FileDirectory dot , Utilities dateTimeSuffix , FileDirectory dot , 'pck') asFileName ]."
	Cursor write
		showWhile: [
			| file |
			file _ ChangeSet defaultChangeSetDirectory forceNewFileNamed: nameToUse.
			[
				file timeStamp.
				self writeOnStream: file ]
					ensure: [ file close ]].
	self hasUnsavedChanges: false.
	ChangeSorter removeChangeSet: (ChangeSet changeSetForPackage: self)! !

----End fileIn of I:\Cuis\CuisUpdates1261-1270\1263-CuisCore-JeffGonis-2012Apr23-23h19m-JMG.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1262] on 25 April 2012 at 10:52:28 am'!
!TextProvider methodsFor: 'testing' stamp: 'jmv 4/25/2012 10:50'!
                    refusesToAccept
	"This method must answer false if we usually accept text from a PluggableTextModel (i.e. we understand its textSetter), but are not accepting text right now."

	^ false! !
!PluggableTextModel methodsFor: 'testing' stamp: 'jmv 4/25/2012 10:52' prior: 16915463!
           wantsFrameAdornments

	^textSetter notNil! !

----End fileIn of I:\Cuis\CuisUpdates1261-1270\1264-CuisCore-JuanVuletich-2012Apr25-10h29m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1262] on 25 April 2012 at 11:01:04 am'!
!SocketStream commentStamp: '<historical>' prior: 16946165!
                   SocketStream is a wrapper for class Socket making it easy to write networking code by giving the programmer a stream-like protocol. A Socket is a two way communication link with two logically separate channels - input and output. The Socket class is the lowest level in Squeak for network communication and using it directly can be difficult and bug prone.

A SocketStream can be in binary or ascii mode, ascii is the default which means you are transmitting and receiving Strings. Most Internet protocols are in clear text ascii, like for example HTTP. Another setting is what timeout you want to use - default is the standardTimeout from Socket. More settings can be found in the method category 'configuration'.

Simplest example of connecting, sending/receiving and closing:

| stream result |
stream := SocketStream openConnectionToHostNamed: 'www.squeak.org' port: 80.
[[stream nextPutAll: 'GET / HTTP/1.0'; newLine; newLine; flush.
result := stream upToEnd. "Give us all data until the socket is closed."
Transcript show: result withCuisLineEndings; newLine.]
	ensure: [stream close]]
		on: ConnectionTimedOut
		do: [:ex | Transcript show: ex asString; newLine. ex resume]

There are two important things to note above:
	- The methods in category "stream in" can signal two exceptions (unless turned off with #shouldSignal:):
		ConnectionClosed and ConnectionTimedOut
	- We close the stream using #ensure:, that is to make sure it isn't left opened.
	- We use #on:do: to catch any signal. In this case we do not need to catch ConnectionClosed since #upToEnd does that for us intrinsically.

----------------
SocketStream (below called SS) is a reimplementation of 'Old'-SocketStream (below called OSS) - the class that originates from the original Comanche implementation but now is included in standard Squeak. SS has the same protocol as OSS and is meant to replace it. SS is faster, more flexible, is better documented and adds a few features:

1. #shouldSignal:, which decides if SS should signal low level Socket exceptions (true) or if it should swallow them like original OSS did. Default is true. The only reason I added this is for backwards compatibility - not signalling causes problems - see bug 4 below.

2. #nextAllInBuffer, #nextInBuffer:, #skip:, #receiveData:, #nextPutAllFlush: and #recentlyRead are new additions to the public protocol.


It also fixes various bugs:

1. #isDataAvailable could theoretically answer false, when there actually is some in the buffer in OSS. If #receiveDataIfAvailable reads the last byte then the following "socket dataAvailable" would answer false. So the last byte would be sitting in the inStream missed.

2. #upToAll: in OSS has several problems, for example - #positionOfSubCollection:ifAbsent: which was introduced answers one position too low. This was compensated in upToAll:, but only in the pushBack: call, not the actual result being returned which was cut short 1 byte. Amusingly this makes KomHttpServer not use "Keep-Alive" since the last $e in 'Alive' was cut short. :)

3. SS doesn't inherit from PositionableStream since that just breaks various inherited messages, like for example #skip:. OSS should IMHO be changed to inherit from Object - or of course, replaced in full with SS. :)

4. Since SocketStream by default signals closes and timeouts the SocketStreamTest now passes. The reason for SocketStream to fail is that while it does timeout on a low level (#SocketStream>>receiveData doesn't hang forever) - the callers of #receiveData sometimes loop - like in #next:, and thus eliminates the timeout. SS warns about some methods (in their method comments) not honouring timeouts if shouldSignal is false, I really don't know what they should do in that case:
	#next:, #upTo:, #upToAll: and #upToEnd (and #receiveData:)


The primary reason for the SS implementation is optimal performance. The main differences in implementation with the old OSS are:

1. SS uses two buffers directly (inBuffer and outBuffer) with pointers marking start and stop within the buffer. OSS instead uses two regular streams, a ReadStream and a WriteStream. Using internal buffers makes it possible to avoid copying and reallocation in various ways, it also makes SS be able to have specialized growing/buffer moving behaviour.

2. #upTo:, #upToAll: and #peekForAll: uses selectged String messages that in turn uses fast primitives for searching. OSS used other messages that fell back on byte per byte reading.

3. #receiveData in OSS creates a temporary buffer stream for each call!! During a long read operation, like say #upToAll: (which for example is used when uploading files using HTTP POST forms), this is devastating - especially since the default size is only 2000 bytes - and leads to a very high number of low level read operations on the Socket, typically 100 times more calls than with OSS. The buffer in OSS is held in an instvar (not recreated for each call), is larger from the start and above all - grows dynamically by doubling. OSS can also avoid a grow/reallocation by doing a "move down" if data has been read from the SS as it comes in and through that making room in the lower part of the inBuffer. The net result is that upToAll: for large files is about 10 times faster.

4. The implementation of upTo: and upToAll: tries to avoid doing unnecessary find operations in the buffer and is greedy by default, which means it favors reading more data - if available - before searching for the stop sequence. If we had #findString:startingAt:stoppingAt: this wouldn't have to be greedy and we wouldn't be needlessly scanning dead buffer area. VM hackers? Also, while you are at it - make it work for ByteArrays too. :)


SS can not be run unbuffered, since that seems unneeded. The option to autoFlush is still available, with it set to true SocketStream (just like OSS) will flush on its own on each nextPut:/nextPutAll:, otherwise flushing it will have to be done manually but is done on close.

The first performance tests shows that, as noted above, receiving large amounts of data using #upToAll: is greatly improved - factor of 10. Serving HTTP with small payloads seemed at first not be faster at all - but this is due to the high overhead of Socket connect/close and other things. Increasing payloads show a difference and especially with keep alive on - where the new SS roughly doubles the throughput!!!
!String methodsFor: 'converting' stamp: 'jmv 4/25/2012 10:59' prior: 16956235!
                         withCuisLineEndings
	"assume the string is textual, and that CR, LF, and CRLF are all 
	valid line endings.  Replace each occurence with a single Lf
	('aLine', String crlfString, 'anotherOne') withCuisLineEndings
	"

	^ self withLineEndings: String newLineString! !

----End fileIn of I:\Cuis\CuisUpdates1261-1270\1265-CuisCore-JuanVuletich-2012Apr25-10h52m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1262] on 25 April 2012 at 11:22:21 am'!
!CodeProvider methodsFor: 'testing' stamp: 'jmv 4/25/2012 11:20'!
                isRefusingToAccept
	"Answer whether receiver, given its current contentsSymbol, could accept code happily if asked to"

	^ (#(byteCodes documentation) includes: self contentsSymbol)! !
!PluggableTextModel methodsFor: 'testing' stamp: 'jmv 4/25/2012 11:18' prior: 16915459!
               refusesToAccept
	^textProvider is: #refusingToAccept! !
!CodeProvider methodsFor: 'testing' stamp: 'jmv 4/25/2012 11:20' prior: 16814766!
                      is: aSymbol
	aSymbol = #refusingToAccept
		ifTrue: [ ^self isRefusingToAccept ].
	^(#(CodeProvider #ShoutEnabled) pointsTo: aSymbol)
		or: [ super is: aSymbol ]! !

CodeProvider removeSelector: #refusesToAccept!

CodeProvider removeSelector: #refusesToAccept!

TextProvider removeSelector: #refusesToAccept!

TextProvider removeSelector: #refusesToAccept!

----End fileIn of I:\Cuis\CuisUpdates1261-1270\1266-CuisCore-JuanVuletich-2012Apr25-11h11m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1262] on 25 April 2012 at 11:49:14 am'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 4/25/2012 11:49' prior: 50340975!
                        okayToDiscardUnsavedCodeSaving: wouldSave
	"Answer true unless the user cancels quitting because of some warning given.
	Smalltalk okayToDiscardUnsavedCodeSaving: true
	Smalltalk okayToDiscardUnsavedCodeSaving: false
	"

	| baseCSdirty dirtyPackages |
	baseCSdirty _ ChangeSorter allChangeSets anySatisfy: [ :any | any isForBaseSystem and: [ any hasUnsavedChanges ]].
	dirtyPackages _ CodePackage installedPackages anySatisfy: [ :pck | pck hasUnsavedChanges ].

	baseCSdirty & dirtyPackages ifTrue: [
		wouldSave ifTrue: [
			^self confirm: 'There are both unsaved Packages', String newLineString,
				'      (would need to be saved on next run), ', String newLineString,
				'and unsaved Changes to Cuis core', String newLineString,
				'      (they would be lost as a separate ChangeSet).', String newLineString,
				'Continue?' ]
		ifFalse: [
			^self confirm: 'There are both unsaved Packages', String newLineString,
				'and unsaved Changes to Cuis core.', String newLineString,
				'If you continue, they will all be lost.', String newLineString,
				'Continue?' ]].

	baseCSdirty ifTrue: [
		^self confirm: 'Some ChangeSet for Cuis core might have unsaved changes.', String newLineString,
			'If you continue, they would be lost.', String newLineString,
			'Continue?' ].

	dirtyPackages ifTrue: [
		wouldSave ifTrue: [
			^self confirm: 'There are unsaved Packages.', String newLineString,
				'If you continue, they will need to be saved on next run.', String newLineString,
				'Continue?' ]
		ifFalse: [
			^self confirm: 'There are unsaved Packages.', String newLineString,
				'If you continue, they will all be lost.', String newLineString,
				'Continue?' ]].

	^true! !

----End fileIn of I:\Cuis\CuisUpdates1261-1270\1267-CuisCore-JuanVuletich-2012Apr25-11h22m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1267] on 28 April 2012 at 11:38:12 am'!
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 4/28/2012 11:34'!
     popUpOwner
	^popUpOwner! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 4/27/2012 16:37'!
   makeMeFullyVisible 

	self world extent > (0@0) ifFalse: [^ self].

	(self position >= (0@0) and: [ self position < (self world extent-self extent)]) ifTrue: [
		^ self "OK -- visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self isCollapsed
		ifTrue: [self position: (RealEstateAgent assignCollapsePointFor: self)]
		ifFalse: [self position: (RealEstateAgent initialFrameFor: self initialExtent: bounds extent world: self world) topLeft].

! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 4/28/2012 11:38' prior: 16886998!
                    mouseEnter: evt
	"The mouse entered the receiver"
	owner popUpOwner ifNotNil: [ :parentItem |
		parentItem removeAlarm: #deselectTimeOut: ].
	owner ifNil: [ ^self ].
	owner selectItem: self event: evt! !
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 4/27/2012 16:38' prior: 50340484!
                               bringWindowsFullOnscreen
	"Make ever SystemWindow on the desktop be totally on-screen, whenever possible."
	
	(SystemWindow windowsIn: self satisfying: [:w | true]) do: [ :each |
		each makeMeFullyVisible ]! !

MenuMorph removeSelector: #staysUp!

MenuMorph removeSelector: #staysUp!

----End fileIn of I:\Cuis\CuisUpdates1261-1270\1268-CuisCore-JuanVuletich-2012Apr28-11h36m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1267] on 30 April 2012 at 12:10:30 am'!
!CodePackage commentStamp: 'jmv 4/30/2012 00:03' prior: 16812140!
                              A CodePackage is a package that is currently loaded in the system. If saved (.pck), then it is stored in a file that can be dealt with as an instance of PackageFile. As the code is already in the system, all we need to know is the packageName. Implementation is originally based on PackageInfo, but has diverged.

CodePackage instances are usually created when installing CodePackageFiles. These instances track the code for that package, that we'll need to save if we don't want to lose changes. These instances are held in the InstalledPackages class variable.

We can also create 'transient' instances with whatever name (and classes and extension methods) we chose, like
	(CodePackage named: 'Collections' createIfAbsent: true registerIfNew: false) inspect; save
This won't mean the system is actually partitioned in such way.

(CodePackage named: 'TestPackage' createIfAbsent: true registerIfNew: false) inspect; save!

----End fileIn of I:\Cuis\CuisUpdates1261-1270\1269-CuisCore-JuanVuletich-2012Apr30-00h01m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1269] on 30 April 2012 at 9:30:39 pm'!
!CodePackageFile class methodsFor: 'services' stamp: 'jmv 4/30/2012 21:29'!
                     monticelloPackageNameFrom: fullName
	| localName |
	localName _ FileDirectory localNameFor: fullName.
	^(localName prefixAndSuffix: $-)
		ifNotNil: [ :ary | ary first ]
		ifNil: [ localName sansPeriodSuffix ].! !
!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 4/30/2012 21:29' prior: 16799128!
                  browseMCZContents: aStream
	"Browse the selected file."
	| unzipped changeList fullName packageFile pkName |
	
	"For Monticello packages we do as we do with our own .pck files: Instead of just browsing
	contents, also include what is no longer part of the package (and should therefore be removed on install)
	See #browsePackageContents:
	However, this was never tested to run!!"
	self flag: #jmvVer.

	fullName _ aStream name.
	pkName _ CodePackageFile monticelloPackageNameFrom: fullName.
	unzipped _ aStream asUnZippedStream: 'snapshot/source.st'.
	unzipped ascii.
	Cursor read showWhile: [
		changeList _ self new scanFile: unzipped from: 0 to: unzipped size.
		aStream reset.
		packageFile _ CodePackageFile
			buildFileStream: unzipped
			packageName: pkName
			fullName: fullName ].
	"Add deletions of methods and classes that are in the PackageInfo (i.e., active in the system)
	but are no longer in the PackageFile being viewed."
	packageFile methodsToRemove do: [ :methodReference |
		changeList
			addItem: (MethodDeletionChangeRecord new methodReference: methodReference)
			text: 'method no longer in package: ', methodReference asStringOrText ].
	packageFile classesToRemove do: [ :clsName |
		changeList
			addItem: (ClassDeletionChangeRecord new clsName: clsName)
			text: 'class no longer in package: ', clsName ].
	changeList clearSelections.
	ChangeListWindow open: changeList label: aStream name! !
!CodeFileBrowserWindow class methodsFor: 'services' stamp: 'jmv 4/30/2012 21:29' prior: 16812099!
                   installMonticelloPackageStream: aStream
	
	| stream fullName pkName |
	fullName _ aStream name.
	pkName _ CodePackageFile monticelloPackageNameFrom: fullName.
	stream _ aStream asUnZippedStream: 'snapshot/source.st'.
	stream ascii.
	Cursor wait showWhile: [
		CodePackageFile
			installFileStream: stream
			packageName: pkName
			fullName: fullName ]! !
!CodePackageFile class methodsFor: 'services' stamp: 'jmv 4/30/2012 21:30' prior: 16813274!
 packageNameFrom: fullName

	^(FileDirectory localNameFor: fullName) sansPeriodSuffix! !

----End fileIn of I:\Cuis\CuisUpdates1261-1270\1270-CuisCore-JuanVuletich-2012Apr30-21h29m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1270] on 2 May 2012 at 6:42:19 pm'!
!TestRunner methodsFor: 'processing' stamp: 'gsa 5/2/2012 18:39'!
      runProfiledTests
	| suite |
	Cursor execute showWhile: [
		suite _ TestSuite new name: 'TestRunner Suite'.
		self selectedTests do: [ :ea | self addTestsFor: ea toSuite: suite ].
		self runSuiteProfiled: suite.
	]
! !
!TestRunner methodsFor: 'processing' stamp: 'gsa 5/2/2012 18:40'!
    runSuiteProfiled: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ MessageTally spyOn: [suite run] ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
	      priority: Processor userBackgroundPriority;
	      resume.
! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'gsa 5/2/2012 18:06'!
         buildRunProfiledButton
	| runProfiledButton |
	runProfiledButton := PluggableButtonMorph 
				model: model
				stateGetter: #runButtonState
				action: #runProfiledTests
				label: 'Run Profiled'.
	runProfiledButton
		color: self runButtonColor.
	^runProfiledButton! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'gsa 5/2/2012 18:34' prior: 16969110!
                         buildUpperControls
	| refreshButton filterButton stopButton runOneButton runButton runProfiledButton row column1 column2 column3 theTestsList |

	refreshButton _ self buildRefreshButton.
	filterButton _ self buildFilterButton.
	stopButton _ self buildStopButton.
	column1 _ LayoutMorph newColumn.
	column1 addMorphs: { refreshButton . filterButton . stopButton }.

	theTestsList _ PluggableListMorphOfMany
				model: model
				listGetter: #tests
				primarySelectionGetter: #selectedSuite
				primarySelectionSetter: #selectedSuite:
				listSelectionGetter: #listSelectionAt:
				listSelectionSetter: #listSelectionAt:put:
				mainView: self
				menuGetter: #listMenu
				keystrokeAction: nil.
	theTestsList autoDeselect: false.
	theTestsList color: Color veryVeryLightGray.
	column2 _ LayoutMorph newColumn.
	column2
		addMorph: theTestsList proportionalHeight: 1;
		addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight.

	runOneButton _ self buildRunOneButton.
	runButton _ self buildRunButton.
	runProfiledButton := self buildRunProfiledButton.	
	column3 _ LayoutMorph newColumn.
	column3 addMorphs: { runOneButton . runButton . runProfiledButton }.
	
	row _ LayoutMorph newRow.
	row
		addMorph: column1 fixedWidth: 80;
		addMorph: column2 proportionalWidth: 1;
		addMorph: column3 fixedWidth: 120.

	^row

! !

----End fileIn of I:\Cuis\1271-CuisCore-GermanArduino-2012May02-17h58m-gsa.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1271] on 7 May 2012 at 9:35:44 am'!

!classDefinition: #SystemConsistencyTest category: #'System-Tests'!
TestCase subclass: #SystemConsistencyTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Tests'!

TestCase subclass: #SystemConsistencyTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Tests'!
!SystemConsistencyTest commentStamp: '<historical>' prior: 0!
                            General system - wide image health tests.!
!SystemConsistencyTest methodsFor: 'testing' stamp: 'jmv 5/7/2012 09:35'!
           testMethodsWithUnboundGlobals
	"
	SystemConsistencyTest new testMethodsWithUnboundGlobals
	"
	self assert: Smalltalk methodsWithUnboundGlobals isEmpty! !
!SystemDictionary methodsFor: 'query' stamp: 'jmv 5/6/2012 19:26'!
   methodsWithUnboundGlobals
	"Get all methods that use undeclared global objects that are not listed in Undeclared. For a clean image the result should be empty."
	"
	self assert: Smalltalk methodsWithUnboundGlobals isEmpty
	"
	^ self allSelect: [ :m |
		m literals anySatisfy: [ :l |
			l isVariableBinding and: [
				l key isSymbol and: [
					"avoid class-side methodClass literals"
					(m methodClass bindingOf: l key)
						ifNil: [
							(Undeclared
								associationAt: l key
								ifAbsent: [ ]) ~~ l ]
						ifNotNil: [ :b |
							b ~~ l ]]]]]! !

----End fileIn of I:\Cuis\1272-MethodsWithUnboundGlobals-JuanVuletich-2012May07-09h32m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1271] on 7 May 2012 at 9:38:15 am'!
!MessageTally class methodsFor: 'spying' stamp: 'jmv 5/7/2012 09:36' prior: 16892238!
                             spyAllOn: aBlock
	"Spy on all the processes in the system
	
	[1000 timesRepeat: [3.14159 printString. Processor yield]] fork.
	[1000 timesRepeat: [20 factorial. Processor yield]] fork.
	[1000 timesRepeat: [20 factorial. Processor yield]] fork.
	MessageTally spyAllOn: [ (Delay forMilliseconds: 100) wait]
	
	"
	| node result |
	node _ self new.
	node reportOtherProcesses: true.	"Irrelevant in this case. All processes will be reported on their own."
	result _ node spyAllEvery: self defaultPollPeriod on: aBlock.
	SystemWindow
		editText: (Workspace withText: (String streamContents: [:s | node report: s]))
		label: 'Spy Results'
		wrap: false.
	^ result! !
!MessageTally class methodsFor: 'spying' stamp: 'jmv 5/7/2012 09:36' prior: 16892275!
                      spyOn: aBlock reportOtherProcesses: aBoolean
	"
	Spy on aBlock, in the current process. Can include or not statistics on other processes in the report.
	[1000 timesRepeat: [
		100 timesRepeat: [120 factorial].
		(Delay forMilliseconds: 10) wait
		]] forkAt: 45 named: '45'.
	MessageTally spyOn: [10000 timesRepeat: [1.23 printString]] reportOtherProcesses: true
	"
	| node result |
	node _ self new.
	node reportOtherProcesses: aBoolean.
	result _ node spyEvery: self defaultPollPeriod on: aBlock.
	SystemWindow
		editText: (Workspace withText: (String streamContents: [:s | node report: s]))
		label: 'Spy Results'
		wrap: false.
	^ result! !
!MessageTally class methodsFor: 'spying' stamp: 'jmv 5/7/2012 09:37' prior: 16892331!
      spyOnProcess: aProcess forMilliseconds: msecDuration reportOtherProcesses: aBoolean
	"
	Spy on aProcess for a certain amount of time
	| p1 p2 |  
	p1 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.  
	p2 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.
	p1 resume.
	p2 resume.  
	(Delay forMilliseconds: 100) wait.  
	MessageTally spyOnProcess: p1 forMilliseconds: 1000 reportOtherProcesses: true
	"
	| node |
	node _ self new.
	node reportOtherProcesses: aBoolean.
	node
		spyEvery: self defaultPollPeriod
		onProcess: aProcess
		forMilliseconds: msecDuration.
	SystemWindow
		editText: (Workspace withText: (String streamContents: [:s | node report: s]))
		label: 'Spy Results'
		wrap: false! !
!MessageTally class methodsFor: 'spying' stamp: 'jmv 5/7/2012 09:37' prior: 16892381!
                            tallySendsTo: receiver inBlock: aBlock showTree: treeOption
	"
	MessageTally tallySends: [3.14159 printString]
	"
	"This method uses the simulator to count the number of calls on each method
	invoked in evaluating aBlock. If receiver is not nil, then only sends
	to that receiver are tallied.
	Results are presented as leaves, sorted by frequency,
	preceded, optionally, by the whole tree."
	| prev tallies startTime totalTime |
	startTime _ Time millisecondClockValue.
	tallies _ MessageTally new class: aBlock receiver class method: aBlock method.
	tallies reportOtherProcesses: true.	"Do NOT filter nodes with nil process"
	prev _ aBlock.
	thisContext sender
		runSimulated: aBlock
		contextAtEachStep: [ :current |
			current == prev ifFalse: [ "call or return"
				prev sender ifNotNil: [ "call only"
					(receiver == nil or: [ current receiver == receiver ])
						ifTrue: [ tallies tally: current by: 1 ]].
				prev _ current]].

	totalTime _ Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.
	SystemWindow
		editText: (Workspace withText: (String streamContents: [ :s |
			s nextPutAll: 'This simulation took ' , totalTime printString, ' seconds.'; newLine.
			treeOption
				ifTrue: [ tallies fullPrintExactOn: s ]
				ifFalse: [ tallies leavesPrintExactOn: s ]]))
		label: 'Spy Results'
		wrap: false! !

----End fileIn of I:\Cuis\1273-MessageTallyOpensWorkspace-JuanVuletich-2012May07-09h35m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1271] on 7 May 2012 at 9:41:05 am'!
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 5/7/2012 09:40' prior: 16861123!
                              paragraph: aParagraph bounds: boundsInWorld color: c selectionColor: sc
	| displayScanner leftInRun line |

	self setPaintColor: c.

	displayScanner _ MorphicScanner new 
		text: aParagraph paragraphText
		foreground: (shadowColor ifNil: [ c ])
		ignoreColorChanges: self isShadowDrawing.
	displayScanner canvas: self.

	leftInRun _ 0.
	"Take clipRect into account. Extrememly fast scrolls and redraws of huge files (like .sources)"
	(aParagraph lineIndexForPoint: (0@0 max: clipRect origin- boundsInWorld origin))
		to: (aParagraph lineIndexForPoint: (boundsInWorld extent min: clipRect corner - boundsInWorld origin))
		do: [ :i |
			line _ aParagraph lines at: i.
			aParagraph
				displaySelectionInLine: line
				on: self
				paragraphTopLeft: boundsInWorld topLeft
				selectionColor: sc.
			leftInRun _ displayScanner displayLine: line paragraphTopLeft: boundsInWorld topLeft leftInRun: leftInRun  ]! !

----End fileIn of I:\Cuis\1274-SuperFastHugeTextDraw-JuanVuletich-2012May07-09h38m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1271] on 7 May 2012 at 9:58:06 am'!
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 5/7/2012 09:56' prior: 16821805!
     endPC
	"Answer the index of the last bytecode."
	| size flagByte |
	"Can't create a zero-sized CompiledMethod so no need to use last for the errorEmptyCollection check.
	 We can reuse size."
	size := self size.
	flagByte := self at: size.
	flagByte = 0 ifTrue: [
		"If last byte = 0, may be either 0, 0, 0, 0 or just 0"
		1 to: 3 do: [:i | (self at: size - i) = 0 ifFalse: [^size - i]].
		^size - 4].
	flagByte < 252 ifTrue: [
		"Magic sources (temp names encoded in last few bytes)"
		^flagByte <= 127
			ifTrue: [size - flagByte - 1]
			ifFalse: [size - (flagByte - 128 * 128) - (self at: size - 1) - 2]].
	"Normal 4-byte source pointer"
	^size - 4! !

----End fileIn of I:\Cuis\1275-endPCfix-JuanVuletich-2012May07-09h41m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1275] on 7 May 2012 at 1:44:24 pm'!
!BreakPoint commentStamp: '<historical>' prior: 16793543!
             This exception is raised on executing a breakpoint.

"BreakPoint signal" is called from "Object>>break".!
!BreakpointManager commentStamp: '<historical>' prior: 16793556!
                     This class manages methods that include breakpoints.
It has several class methods to install and uninstall breakpoints.

Evaluating "BreakpointManager clear" will remove all installed breakpoints in the system.

Known issues:
- currently, only break-on-entry type of breakpoints are supported
- emphasis change not implemented for MVC browsers
- uninstalling the breakpoint doesn't auto-update other browsers
- uninstalling a breakpoint while debugging should restart-simulate the current method

Ernest Micklei, 2002

Send comments to emicklei@philemonworks.com!
!ConnectionClosed commentStamp: '<historical>' prior: 16826045!
            Signals a prematurely closed connection.!
!ConnectionTimedOut commentStamp: '<historical>' prior: 16826325!
                    Signals that a connection attempt timed out.!
!ExceptionAboutToReturn commentStamp: '<historical>' prior: 16846364!
            This class is private to the EHS implementation.  Its use allows for ensured execution to survive code such as:

[self doThis.
^nil]
	ensure: [self doThat]

Signaling or handling this exception is not recommended.  Not even slightly.!
!ExternalSemaphoreTable commentStamp: '<historical>' prior: 16847198!
               By John M McIntosh johnmci@smalltalkconsulting.com
This class was written to mange the external semaphore table. When I was writing a Socket test server I discovered various race conditions on the access to the externalSemaphore table. This new class uses class side methods to restrict access using a mutex semaphore. It seemed cleaner to deligate the reponsibility here versus adding more code and another class variable to SystemDictionary 

Note that in Smalltalk recreateSpecialObjectsArray we still directly play with the table.!
!IdentityBag commentStamp: '<historical>' prior: 16867422!
             Like a Bag, except that items are compared with #== instead of #= .

See the comment of IdentitySet for more information.!
!InvalidSocketStatusException commentStamp: '<historical>' prior: 16878188!
                         Signals if an operation on a Socket found it in a state invalid for that operation.!
!NetNameResolver commentStamp: '<historical>' prior: 16901704!
            This class implements TCP/IP style network name lookup and translation facilities.

Attempt to keep track of whether there is a network available.
HaveNetwork	true if last attempt to contact the network was successful.
LastContact		Time of that contact (totalSeconds).
haveNetwork	returns true, false, or #expired.  True means there was contact in the last 30 minutes.  False means contact failed or was false last time we asked.  Get out of false state by making contact with a server in some way (FileList or updates).!
!NoNetworkError commentStamp: '<historical>' prior: 16902223!
                        Signals that no network was found. This could happen, e.g., on dial-up connection when no connection was established when Squeak tried to access it.!
!SoundService commentStamp: '<historical>' prior: 16949962!
              This is the AppRegistry class for the sound system.

A sound system offers a small protocol for playing sounds and making beeps and works like a facade towards the rest of Squeak. A sound system is registered in this registry and can be accessed by "SoundService default". This way we decouple the sound system from the rest of Squeak and make it pluggable. It also is a perfect spot to check for the Preference class>>soundsEnabled.!
!Transcript commentStamp: '<historical>' prior: 16978076!
                   A new implementation of Transcript.
- Thread safe.
- Very fast.
- Independent of Morphic or any other UI framework.
- Immediate feedback.
- Can log to file.
- Not an editor. Only used for output.
- All protocol is on the Class side!
!UnloadedSound commentStamp: '<historical>' prior: 16980518!
                          Instances of me, which are really just FMSounds, are used placeholders for sounds that have been unloaded from this image but which may be re-loaded later.!

----End fileIn of I:\Cuis\1276-FixCrs-JuanVuletich-2012May07-13h41m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1275] on 7 May 2012 at 2:00:31 pm'!

!classDefinition: #SHTextStyler category: #'Shout-Styling'!
Object subclass: #SHTextStyler
	instanceVariableNames: 'sem backgroundProcess monitor formattedText textModel mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Shout-Styling'!

Object subclass: #SHTextStyler
	instanceVariableNames: 'sem backgroundProcess monitor formattedText textModel mutex '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Shout-Styling'!
!SHTextStyler methodsFor: 'private' stamp: 'jmv 5/7/2012 13:57'!
                            mutex
	mutex
		ifNil: [ mutex := Mutex new ].
	^mutex! !
!SHTextStyler methodsFor: 'styling' stamp: 'jmv 5/7/2012 13:57' prior: 16931250!
                      styleInBackgroundProcess
	"Do the styling on a copy of the provided text (and in a separate process).
	After finishing, send it to the model, via #stylerStyled:checkForChanges:
	The the model should grab the TextAttributes we added to the copy, as appropriate."
	self terminateBackgroundStylingProcess.

	formattedText _ textModel actualContents copy.
	self mutex critical: [
		
		"This part, running at current priority, and fired by sem, is for events to be triggered at current priority"
		sem _ Semaphore new. 
		[
			sem ifNotNil: [
				sem wait.
				textModel stylerStyled: formattedText checkForChanges: true ]
		] forkAt: Processor activePriority.

		"This part runs at low priority, and signals sem when finished"
		backgroundProcess _  [
			textModel privateStyleWith: self.
			sem signal] newProcess.
		backgroundProcess priority: Processor userBackgroundPriority.
		backgroundProcess resume
	]! !
!SHTextStyler methodsFor: 'private' stamp: 'jmv 5/7/2012 13:58' prior: 16931288!
  terminateBackgroundStylingProcess
	self mutex critical: [
		backgroundProcess 
			ifNotNil: [
				backgroundProcess terminate.
				backgroundProcess := nil].
		sem 
			ifNotNil:[
				sem terminateProcess.
				sem := nil].	
	]		! !

SHTextStyler removeSelector: #monitor!

SHTextStyler removeSelector: #monitor!

!classDefinition: #SHTextStyler category: #'Shout-Styling'!
Object subclass: #SHTextStyler
	instanceVariableNames: 'sem backgroundProcess formattedText textModel mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Shout-Styling'!

Object subclass: #SHTextStyler
	instanceVariableNames: 'sem backgroundProcess formattedText textModel mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Shout-Styling'!

----End fileIn of I:\Cuis\1277-UseMutexInShout-JuanVuletich-2012May07-13h44m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1277] on 7 May 2012 at 2:40:53 pm'!
!Mutex commentStamp: 'jmv 5/7/2012 14:40' prior: 16901598!
                A Mutex is a light-weight MUTual EXclusion object being used when two or more processes need to access a shared resource concurrently. A Mutex grants ownership to a single process and will suspend any other process trying to aquire the mutex while in use. Waiting processes are granted access to the mutex in the order the access was requested.

Nested (or recursive) calls to #critical: from a single process are allowed, and the process is not blocked for this: access is granted immediately. For this reason instances of Mutex should be used for resources that support this form of multiple access (i.e. multiple simultaneous access from within a single Process). Resources that don't support this, like access to private state that changes for each call, should use a Semaphore. See Semaphore's class comment

Instance variables:
	semaphore		<Semaphore>		The (primitive) semaphore used for synchronization.
	owner			<Process>			The process owning the mutex.!
!Semaphore commentStamp: 'jmv 5/7/2012 14:39' prior: 16935436!
                              I provide synchronized communication of a single bit of information (a "signal") between Processes. A signal is sent by sending the message signal and received by sending the message wait. If no signal has been sent when a wait message is sent, the sending Process will be suspended until a signal is sent.

Beware that if a process calls 'aSemaphore critical: []' while already in a critical section for that semaphore, it will enter a deadlock. In some cases, a Mutex can be used instead. Refer to the Mutex class comment.!

----End fileIn of I:\Cuis\1278-MutexAndSemaphoreComments-JuanVuletich-2012May07-14h03m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1278] on 7 May 2012 at 10:10:48 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/7/2012 22:09'!
           contributorInitialsAndNames
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk contributorInitialsAndNames collect: [ :pair | pair first ]) asSet.
self assert: all = ok

initials         name"
^ #(
	#('ab' 					'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 					'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 					'Andreas Raab')
	#('asm' 				'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('bf' 					'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 				'Bolot Kerimbaev')
	#('bp' 					'Bernhard Pieber')
	#('BP' 					'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'					'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 				'Chris Muller')
	#('crl' 					'Craig Latta')
	#('cwp' 				'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 					'Damien Cassou')
	#('dew' 				'Doug Way')
	#('dgd' 				'Diego Gomez Deck')
	#('dhhi' 				'Dan Ingalls')
	#('di' 					'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DSM' 				'Duane Maxwell')
	#('dtl' 					'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 				'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 					'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 	'Fernando Olivero')
	#('FernanodOlivero' 	'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gh' 					'Goran Krampe (nee Hultgren)')
	#('gk' 					'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 					'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('hmm' 				'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 					'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 					'Joern Eyrich')
	#('jf' 					'Julian Fitzell')
	#('JF' 					'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jlb' 					'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 				'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 					'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 				'Kurt Thams')
	#('laza' 				'Alexander Lazarevic')
	#('LC' 					'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lr' 					'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 					'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 				'Mike Rutenberg')
	#('mga' 				'Markus Galli')
	#('mha' 				'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 				'Michael Hewner')
	#('mpw' 				'Marcel Weiher')
	#('MPW' 				'Marcel Weiher')
	#('mrm' 				'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 					'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 					'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 					'Nathanael Schaerli')
	#('panda' 				'Michael Rueger')
	#('PHK' 				'Peter Keeler')
	#('Pmm' 				'Philippe Marschall')
	#('pnm' 				'Paul McDonough')
	#('r++' 				'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 				'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 					'Robert Hirschfeld')
	#('rr' 					'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 					'Robert Withers')
	#('rww' 				'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 				'Stephan B. Wessels')
	#('sd' 					'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 				'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sr' 					'Stephan Rudlof')
	#('SSS' 				'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 				'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 					'Torge Husfeldt')
	#('tk' 					'Ted Kaehler')
	#('tlk' 					'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 					'Levente Uzonyi')
	#('vb' 					'Vassili Bykov')
	#('ward' 				'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 				'Bill Dargel')
	#('yo' 					'Yoshiki Ohshima')
	#('zz' 					'Serge Stinckwich'))! !
!AdditionalMethodState methodsFor: 'testing' stamp: 'jmv 5/7/2012 16:16' prior: 16781057!
                              hasLiteralSuchThat: aBlock
	"Answer true if litBlock returns true for any literal in this array, even if embedded in further array structure.
	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"
	1 to: self basicSize do: [:i |
		| propertyOrPragma "<Association|Pragma>" |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
			ifTrue: [(aBlock value: propertyOrPragma key)
					or: [(aBlock value: propertyOrPragma value)
					or: [propertyOrPragma value isArray
						and: [propertyOrPragma value hasLiteralSuchThat: aBlock]]]]
			ifFalse: [propertyOrPragma hasLiteralSuchThat: aBlock]) ifTrue: [^true]].
	^false! !
!AdditionalMethodState methodsFor: 'accessing' stamp: 'jmv 5/7/2012 21:34' prior: 16781171!
at: aKey put: aValue
	"Replace the property value or pragma associated with aKey."

	| keyAlreadyExists |
	keyAlreadyExists _ false.
	
	1 to: self basicSize do: [ :i |
		| propertyOrPragma "<Association|Pragma>" |
		(propertyOrPragma _ self basicAt: i) key == aKey ifTrue: [
			keyAlreadyExists _ true.
			propertyOrPragma isVariableBinding
				ifTrue: [ propertyOrPragma value: aValue ]
				ifFalse: [ self basicAt: i put: aValue ]]].
	
	keyAlreadyExists ifFalse: [
		method propertyValueAt: aKey put: aValue ].
	
	^ aValue! !
!Color methodsFor: 'transformations' stamp: 'jmv 5/7/2012 15:05' prior: 16817497!
                              twiceDarker
	"Answer a significantly darker shade of this color."

	^ self adjustSaturation: 0.076 brightness: -0.15! !
!DateAndTime methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:26' prior: 16832510!
                noon
	"Answer a DateAndTime starting at noon"

	^ self dayMonthYearDo: [ :d :m :y |
		self class year: y month: m day: d hour: 12 minute: 0 second: 0 ]! !
!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:25' prior: 16832895!
       epoch
	"Answer a DateAndTime representing the Squeak epoch: 1 January 1901"

	^ self julianDayNumber: SqueakEpoch! !
!ExceptionSet methodsFor: 'private' stamp: 'jmv 5/7/2012 21:38' prior: 16846393!
                          add: anException

	^exceptions add: anException! !
!ExceptionTester methodsFor: 'tests' stamp: 'jmv 5/7/2012 21:38' prior: 16846949!
                           simpleNoTimeoutTest

	[ self doSomething ]
		valueWithin: 1 days onTimeout:
			[ self doSomethingElse ]! !
!FloatTest methodsFor: 'IEEE 754' stamp: 'jmv 5/7/2012 15:15' prior: 16856078!
      testInfinity3
	self assert:
		(Float infinity negated asIEEE32BitWord
			printPaddedWith: $0
			to: 32
			base: 2) = '11111111100000000000000000000000'.
	self assert:
		(Float fromIEEE32Bit:
			(Integer
				readFrom: '11111111100000000000000000000000' readStream
				base: 2)) = Float infinity negated! !
!FloatTest methodsFor: 'IEEE 754' stamp: 'jmv 5/7/2012 15:15' prior: 16856112!
testZero2
	self assert:
		(Float negativeZero asIEEE32BitWord
			printPaddedWith: $0
			to: 32
			base: 2) = '10000000000000000000000000000000'.
	self assert:
		(Float fromIEEE32Bit:
			(Integer
				readFrom: '10000000000000000000000000000000' readStream
				base: 2)) = Float negativeZero! !
!Heap methodsFor: 'removing' stamp: 'jmv 5/7/2012 21:54' prior: 16866021!
                 removeAll

	array atAllPut: nil.
	tally _ 0! !
!Integer methodsFor: 'bit manipulation' stamp: 'jmv 5/7/2012 15:09' prior: 16873686!
                            >> shiftAmount  "right shift"
	shiftAmount < 0 ifTrue: [self error: 'negative arg'].
	^ self bitShift: shiftAmount negated! !
!MethodContext methodsFor: 'printing' stamp: 'jmv 5/7/2012 20:25' prior: 16893289!
               printString
	"Answer an emphasized string in case of a breakpoint method"
	(self method notNil and: [ self method hasBreakpoint ])
		ifFalse: [ ^ super printString ].
	^ super printString , ' [break]' asText allBold! !
!ParserNotification methodsFor: 'as yet unclassified' stamp: 'jmv 5/7/2012 16:20' prior: 16911486!
  setName: aString

	name _ aString! !
!Process methodsFor: 'accessing' stamp: 'jmv 5/7/2012 16:16' prior: 16921330!
             isTerminated

	self isActiveProcess ifTrue: [^ false].
	^suspendedContext isNil
	  or: ["If the suspendedContext is the bottomContext it is the block in Process>>newProcess.
		   If so, and the pc is greater than the startpc, the bock has alrteady sent and returned
		   from value and there is nothing more to do."
		suspendedContext isBottomContext
		and: [
			suspendedContext pc > suspendedContext startpc]]! !
!SmallIntegerTest methodsFor: 'testing - basic' stamp: 'jmv 5/7/2012 21:35' prior: 16941097!
    testEven
	
	self assert: (SmallInteger minVal even).
	self deny: (SmallInteger maxVal even).
	
	self deny: ((SmallInteger minVal + 1) even).
	self assert: ((SmallInteger maxVal - 1) even).
	
	self deny: (1 even).
	self deny: (-1 even).
	
	self assert: (2 even).
	self assert: (-2 even).
	
	self assert: (0 even)! !
!SmallIntegerTest methodsFor: 'testing - basic' stamp: 'jmv 5/7/2012 21:35' prior: 16941110!
        testOdd
	
	self deny: (SmallInteger minVal odd).
	self assert: (SmallInteger maxVal odd).
	
	self assert: ((SmallInteger minVal + 1) odd).
	self deny: ((SmallInteger maxVal - 1) odd).
	
	self assert: (1 odd).
	self assert: (-1 odd).
	
	self deny: (2 odd).
	self deny: (-2 odd).
	
	self deny: (0 odd)! !
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/7/2012 15:19' prior: 16959983!
                       allContributors
"
	Smalltalk allContributors
"
	| bag author |
	bag _ Bag new.
	Smalltalk allBehaviorsDo: [ :behavior |
		behavior methodsDo: [ :compiledMethod |
			author _ compiledMethod author.
			author notEmpty ifTrue: [
				bag add: author ]]].
	^bag! !
!SystemDictionary class methodsFor: 'copyright' stamp: 'jmv 5/7/2012 14:49' prior: 16964558!
                               copyright
	"The Smalltalk copyright.
	Parts are copyright of many contributors to Squeak and Cuis projects."

	^
'Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982.
Copyright (c) Apple Computer, Inc. 1985-1996.
Copyright (c) Contributors to Squeak and Cuis projects. 1997-2012.'! !
!Time class methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:26' prior: 16977361!
      hour: hour minute: minute second: second nanoSecond: nanoCount
	"Answer a Time"

	^ self 
		seconds: (hour * SecondsInHour) + (minute * SecondsInMinute) + second 
		nanoSeconds: nanoCount! !
!Time class methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:27' prior: 16977375!
          noon

	^ self seconds: (SecondsInDay / 2)! !
!UndefinedVariable methodsFor: 'as yet unclassified' stamp: 'jmv 5/7/2012 16:19' prior: 16980327!
                 openMenuIn: aBlock
	| labels caption index |
	labels _ #('yes' 'no' ).
	caption _ name , ' appears to be 
undefined at this point.
Proceed anyway?'.
	index _ aBlock
		value: labels
		value: #()
		value: caption.
	^ self resume: index = 1! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:25' prior: 16985838!
                        startDay
	^ StartDay ifNil: [ StartDay _ DayNames first ]! !

Utilities class removeSelector: #reportSenderCountsFor:!

Utilities class removeSelector: #reportSenderCountsFor:!

SystemDictionary removeSelector: #agreedContributors!

SystemDictionary removeSelector: #agreedContributors!

SystemDictionary removeSelector: #missingAuthorsWithMethods!

SystemDictionary removeSelector: #missingAuthorsWithMethods!

SystemDictionary removeSelector: #newContributors!

SystemDictionary removeSelector: #newContributors!

SystemDictionary removeSelector: #okContributors!

SystemDictionary removeSelector: #okContributors!

SystemDictionary removeSelector: #relicenseEffortStartDate!

SystemDictionary removeSelector: #relicenseEffortStartDate!

SystemDictionary removeSelector: #returnedSignatories!

SystemDictionary removeSelector: #returnedSignatories!

BlockContext removeSelector: #argumentCount!

BlockContext removeSelector: #argumentCount!

----End fileIn of I:\Cuis\1279-AuthorNamesTweaks-JuanVuletich-2012May07-18h42m-jmv.3.cs----!

self size!

self size!

self at: 13!

self initialPC!

self initialPC!

self initialPC!

self initialPC!
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 5/11/2012 15:37' prior: 50342083!
                   endPC
	"Answer the index of the last bytecode."
	| size flagByte |
	"Can't create a zero-sized CompiledMethod so no need to use last for the errorEmptyCollection check.
	 We can reuse size."
	size := self size.
	flagByte := self at: size.
	flagByte = 0 ifTrue: [
		"If last byte = 0, may be either 0, 0, 0, 0 or just 0"
		1 to: 3 do: [:i | 
			(self at: size - i) = 0 ifFalse: [^size - i]].
		^size - 4].
	flagByte < 252 ifTrue: [
		"Magic sources (temp names encoded in last few bytes)"
		^flagByte <= 127
			ifTrue: [size - flagByte - 1]
			ifFalse: [size - (flagByte - 128 * 128) - (self at: size - 1) - 2]].
	"Normal 4-byte source pointer"
	^size - 4! !
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 5/11/2012 15:38' prior: 50342815!
                        endPC
	"Answer the index of the last bytecode."
	| size flagByte |
	"Can't create a zero-sized CompiledMethod so no need to use last for the errorEmptyCollection check.
	 We can reuse size."
	size := self size.
	flagByte := self at: size.
	flagByte = 0 ifTrue: [
		"If last byte = 0, may be either 0, 0, 0, 0 or just 0"
		1 to: 3 do: [:i |
			size-i < self initialPC ifTrue: [ ^ size - i ].
			(self at: size - i) = 0 ifFalse: [ ^ size - i ]].
		^size - 4].
	flagByte < 252 ifTrue: [
		"Magic sources (temp names encoded in last few bytes)"
		^flagByte <= 127
			ifTrue: [size - flagByte - 1]
			ifFalse: [size - (flagByte - 128 * 128) - (self at: size - 1) - 2]].
	"Normal 4-byte source pointer"
	^size - 4! !

self initialPC!

self endPC!
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 5/11/2012 15:40' prior: 50342839!
     endPC
	"Answer the index of the last bytecode."
	| size flagByte |
	"Can't create a zero-sized CompiledMethod so no need to use last for the errorEmptyCollection check.
	 We can reuse size."
	size := self size.
	flagByte := self at: size.
	flagByte = 0 ifTrue: [
		"If last byte = 0, may be either 0, 0, 0, 0 or just 0"
		size-1 to: size-3 by: -1 do: [ :i |
			i < self initialPC ifTrue: [ ^ i ].
			(self at: i) = 0 ifFalse: [ ^ i ]].
		1 to: 3 do: [:i |
			size-i < self initialPC ifTrue: [ ^ size - i ].
			(self at: size - i) = 0 ifFalse: [ ^ size - i ]].
		^size - 4].
	flagByte < 252 ifTrue: [
		"Magic sources (temp names encoded in last few bytes)"
		^flagByte <= 127
			ifTrue: [size - flagByte - 1]
			ifFalse: [size - (flagByte - 128 * 128) - (self at: size - 1) - 2]].
	"Normal 4-byte source pointer"
	^size - 4! !
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 5/11/2012 15:40' prior: 50342865!
               endPC
	"Answer the index of the last bytecode."
	| size flagByte |
	"Can't create a zero-sized CompiledMethod so no need to use last for the errorEmptyCollection check.
	 We can reuse size."
	size := self size.
	flagByte := self at: size.
	flagByte = 0 ifTrue: [
		"If last byte = 0, may be either 0, 0, 0, 0 or just 0"
		size-1 to: size-3 by: -1 do: [ :i |
			i < self initialPC ifTrue: [ ^ i ].
			(self at: i) = 0 ifFalse: [ ^ i ]].
		^size - 4].
	flagByte < 252 ifTrue: [
		"Magic sources (temp names encoded in last few bytes)"
		^flagByte <= 127
			ifTrue: [size - flagByte - 1]
			ifFalse: [size - (flagByte - 128 * 128) - (self at: size - 1) - 2]].
	"Normal 4-byte source pointer"
	^size - 4! !

self endPC!

self initialPC!

----QUIT/NOSAVE----#(11 May 2012 3:45:07 pm) Cuis4.0.image priorSource: 434!

----STARTUP----#(12 May 2012 7:32:54 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0.image!


'From Cuis 4.0 of 21 April 2012 [latest update: #1260] on 25 April 2012 at 10:29:12 am'!

!classDefinition: #ChangeSet category: #'Tools-Changes'!
Object subclass: #ChangeSet
	instanceVariableNames: 'name preamble postscript changeRecords structures superclasses isForBaseSystem hasUnsavedChanges'
	classVariableNames: 'CurrentBaseCSNumber Installing'
	poolDictionaries: ''
	category: 'Tools-Changes'!

Object subclass: #ChangeSet
	instanceVariableNames: 'name preamble postscript changeRecords structures superclasses isForBaseSystem hasUnsavedChanges '
	classVariableNames: 'CurrentBaseCSNumber Installing '
	poolDictionaries: ''
	category: 'Tools-Changes'!
!ChangeSet methodsFor: 'accessing' stamp: 'jmv 4/25/2012 09:46'!
           hasUnsavedChanges

	^hasUnsavedChanges! !
!ChangeSet methodsFor: 'accessing' stamp: 'jmv 4/25/2012 09:46'!
                     hasUnsavedChanges: aBoolean

	hasUnsavedChanges _ aBoolean.
	self triggerEvent: #dirtyFlagChanged! !
!ChangeSet methodsFor: 'accessing' stamp: 'jmv 4/25/2012 10:18'!
                          isForBaseSystem: aBoolean

	isForBaseSystem _ aBoolean! !
!ChangeSorter class methodsFor: 'enumerating' stamp: 'jmv 4/25/2012 10:24'!
                          existingOrNewChangeSetNamed: aName forBaseSystem: aBoolean

	| newSet |

	^(self changeSetNamed: aName)
		ifNotNil: [ :existing |
			existing assert: existing isForBaseSystem = aBoolean ]
		ifNil: [
			newSet _ ChangeSet basicNewNamed: aName.
			newSet isForBaseSystem: aBoolean.
			AllChangeSets add: newSet.
			newSet ]! !
!CodePackage class methodsFor: 'packages access' stamp: 'jmv 4/25/2012 09:34'!
            named: aString createIfAbsent: neverAnswerNil registerIfNew: doRegisterIfJustCreated
	"Answer the instance with name aString.
	If there's no package named aString, answer nil or a new instance as requested.
	If a new instance is created, register it or not as requested.
	CodePackage named: 'Morphic' createIfAbsent: false registerIfNew: false
	CodePackage named: 'Morphic' createIfAbsent: true registerIfNew: false
	CodePackage named: 'XXXXXTest' createIfAbsent: true registerIfNew: true
	"

	| answer newInstance |
	answer _ InstalledPackages
		at: aString
		ifAbsent: [
			neverAnswerNil ifTrue: [ 
				newInstance _ self new packageName: aString.
				doRegisterIfJustCreated ifTrue: [ self register: newInstance ].
				newInstance ]].
	^ answer! !
!ChangeSet methodsFor: 'initialize-release' stamp: 'jmv 4/25/2012 10:24' prior: 16799784!
                      clear 
	"Reset the receiver to be empty.  "

	changeRecords _ Dictionary new.
	preamble _ nil.
	postscript _ nil.
	self hasUnsavedChanges: false.
	self isForBaseSystem: true 	"Not a great default, but at least some Boolean"! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:50' prior: 16799811!
       noteAddClass: class
	"Include indication that a new class was created."

	class wantsChangeSetLogging ifFalse: [^ self].
	self atClass: class add: #new.
	self atClass: class add: #change.
	self addCoherency: class name.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:52' prior: 16799821!
             noteChangeClass: class from: oldClass
	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."

	class wantsChangeSetLogging ifFalse: [^ self].
	class isMeta 
		ifFalse: [self atClass: class add: #change]	"normal"
		ifTrue: [((self classChangeAt: class theNonMetaClass name) includes: #add) 
			ifTrue: [self atClass: class add: #add] 	"When a class is defined, the metaclass
				is not recorded, even though it was added.  A further change is
				really just part of the original add."
			ifFalse: [self atClass: class add: #change]].
	self addCoherency: class name.
	(self changeRecorderFor: class) notePriorDefinition: oldClass.
	self noteClassStructure: oldClass.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:56' prior: 16799847!
      noteClassMoveToOtherPackage: class
	"The class is about to be moved to some other package, who will hold it.
	Adjust the receiver to reflect that fact."

	class wantsChangeSetLogging ifFalse: [^ self].
	self atClass: class add: #movedToOtherPackage.
	changeRecords removeKey: class class name ifAbsent: nil.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:56' prior: 16799859!
                     noteMethodMoveToOtherPackage: selector forClass: class

	class wantsChangeSetLogging ifFalse: [^ self].
	(self changeRecorderFor: class)
		noteMethodMoveToOtherPackage: selector.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:54' prior: 16799867!
                      noteNewMethod: newMethod forClass: class selector: selector priorMethod: methodOrNil

	class wantsChangeSetLogging ifFalse: [^ self].
	(self changeRecorderFor: class)
		noteNewMethod: newMethod selector: selector priorMethod: methodOrNil.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 10:10' prior: 16799877!
                          noteRemoveSelector: selector class: class priorMethod: priorMethod lastMethodInfo: info
	"Include indication that a method has been forgotten.
	info is a pair of the source code pointer and message category
	for the method that was removed."

	class wantsChangeSetLogging ifFalse: [^ self].
	(self changeRecorderFor: class)
		noteRemoveSelector: selector priorMethod: priorMethod lastMethodInfo: info.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 4/25/2012 09:54' prior: 16799892!
                       noteRenameClass: class as: newName 
	"Include indication that a class has been renamed."

	| recorder |
	(recorder _ self changeRecorderFor: class)
		noteChangeType: #rename;
		noteNewName: newName asSymbol.
		
	"store under new name (metaclass too)"
	changeRecords at: newName put: recorder.
	changeRecords removeKey: class name.
	self noteClassStructure: class.

	recorder _ changeRecords at: class class name ifAbsent: [nil].
	recorder ifNotNil: [
		changeRecords at: (newName, ' class') put: recorder.
		changeRecords removeKey: class class name.
		recorder noteNewName: newName , ' class' ].

	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'accessing' stamp: 'jmv 4/25/2012 10:18' prior: 16800026!
                        isForBaseSystem

	^isForBaseSystem! !
!ChangeSet methodsFor: 'method changes' stamp: 'jmv 4/25/2012 10:07' prior: 16800128!
    removeSelectorChanges: selector class: class 
	"Remove all memory of changes associated with the argument, selector, in 
	this class."

	| chgRecord |
	(chgRecord _ changeRecords at: class name ifAbsent: [^ self])
		removeSelector: selector.
	chgRecord hasNoChanges ifTrue: [changeRecords removeKey: class name].
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 4/25/2012 09:56' prior: 16800245!
                 noteClassForgotten: className
	"Remove from structures if class is not a superclass of some other one we are remembering"

	structures ifNil: [^ self].
	Smalltalk at: className ifPresent: [:cls |
		cls subclasses do: [:sub | (structures includesKey: sub) ifTrue: [
			^ self]]].  "No delete"
	structures removeKey: className ifAbsent: nil.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 4/25/2012 09:51' prior: 16800290!
                      noteCommentClass: class 
	"Include indication that a class comment has been changed."

	class wantsChangeSetLogging ifFalse: [^ self].
	self atClass: class add: #comment.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 4/25/2012 09:52' prior: 16800298!
                               noteRemovalOf: class
	"The class is about to be removed from the system.
	Adjust the receiver to reflect that fact."

	class wantsChangeSetLogging ifFalse: [^ self].
	(self changeRecorderFor: class)
		noteChangeType: #remove fromClass: class.
	changeRecords removeKey: class class name ifAbsent: nil.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 4/25/2012 09:54' prior: 16800310!
                             noteReorganizeClass: class 
	"Include indication that a class was reorganized."

	self atClass: class add: #reorganize.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 10:01' prior: 16800575!
                     assurePreambleExists
	"Make sure there is a TextModel holding the preamble; if it's found to have reverted to empty contents, put up the template"

	(preamble == nil or: [preamble actualContents isEmptyOrNil])
		ifTrue: [
			preamble _ TextModel withText: self preambleTemplate.	
			self hasUnsavedChanges: true ]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 10:02' prior: 16800715!
                 fileOut
	"File out the receiver, to a file whose name is a function of the  
	change-set name and either of the date & time or chosen to have a  
	unique numeric tag, depending on the preference  
	'changeSetVersionNumbers'"
	| slips nameToUse |
	self checkForConversionMethods.
	nameToUse := Preferences changeSetVersionNumbers
				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name coda: '-', Utilities authorInitials extension: 'cs']
				ifFalse: [(self name , FileDirectory dot , Utilities dateTimeSuffix , FileDirectory dot , 'cs') asFileName].
	Cursor write
		showWhile: [
			| file |
			file := self defaultChangeSetDirectory newFileNamed: nameToUse.
			[
				file timeStamp.
				self fileOutPreambleOn: file.
				self fileOutOn: file.
				self fileOutPostscriptOn: file]
					ensure: [file close]].
	
	self hasUnsavedChanges: false.
	Preferences checkForSlips
		ifFalse: [^ self].
	slips := self checkForSlips.
	(slips size > 0
			and: [(PopUpMenu withCaption: 'Methods in this fileOut have halts
or references to the Transcript
or other ''slips'' in them.
Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')
					= 2])
		ifTrue: [Smalltalk browseMessageList: slips name: 'Possible slips in ' , name]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 10:25' prior: 16800921!
                       objectForDataStream: refStrm
	"I am about to be written on an object file.  Write a path to me in the other system instead."

	"try to write reference for me"
	^ DiskProxy 
		global: #ChangeSorter
		selector: #existingOrNewChangeSetNamed:forBaseSystem:
		args: (Array with: self name with: self isForBaseSystem)
"===
	refStrm replace: self with: nil.
	^ nil
==="
! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 09:58' prior: 16800942!
                               postscriptString: aString

	postscript _ TextModel withText: aString.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/25/2012 09:58' prior: 16800954!
       preambleString: aString
	"Establish aString as the new contents of the preamble.  "

	preamble _ TextModel withText: aString.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'system change notifications' stamp: 'jmv 4/25/2012 09:52' prior: 16801090!
                              classRecategorized: aClass from: oldCategory to: newCategory

	"
	self hasUnsavedChanges: true
	"! !
!CodePackage methodsFor: 'saving' stamp: 'jmv 4/25/2012 09:41' prior: 16812828!
           save
	| nameToUse |
	fullFileName ifNil: [
		fullFileName _
			(ChangeSet defaultChangeSetDirectory pathName, FileDirectory slash, 
			self packageName, FileDirectory dot, 'pck')
				asFileName ].
	nameToUse _ fullFileName.
"	nameToUse _ Preferences changeSetVersionNumbers
		ifTrue: [
			ChangeSet defaultChangeSetDirectory
				nextNameFor: self packageName coda: '-', Utilities authorInitials
				extension: 'pck' ]
		ifFalse: [ (self packageName , FileDirectory dot , Utilities dateTimeSuffix , FileDirectory dot , 'pck') asFileName ]."
	Cursor write
		showWhile: [
			| file |
			file _ ChangeSet defaultChangeSetDirectory forceNewFileNamed: nameToUse.
			[
				file timeStamp.
				self writeOnStream: file ]
					ensure: [ file close ]].
	self hasUnsavedChanges: false.
	ChangeSorter removeChangeSet: (ChangeSet changeSetForPackage: self)! !
!CodePackage class methodsFor: 'packages access' stamp: 'jmv 4/25/2012 09:40' prior: 16812988!
                  register: aCodePackage
	"
	Usually call #named:createIfAbsent:registerIfNew: instead
	CodePackage register: (CodePackage newNamed: 'Tests-Files')
	"
	InstalledPackages at: aCodePackage packageName put: aCodePackage.
	self triggerEvent: #installedPackagesChanged! !
!CodePackageFile methodsFor: 'initialize' stamp: 'jmv 4/25/2012 09:35' prior: 16813067!
                               buildFileStream: aFileStream packageName: pkName fullName: fullFileName
	"Just build the PackageFile object. Don't install the code."

	| classesDefined classesExtended classesToDeleteButCant classesToReallyDelete packageInMemory |
	packageName _pkName.
	fullName _fullFileName.
	"Don't register a package!!"
	packageInMemory _ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: false.
	self buildFrom: aFileStream.
	"Compute stuff no longer in package: Should be removed from system."
	classesDefined _ Set new.
	classesExtended _ Set new.
	self classes do: [ :pseudoClass |
		pseudoClass hasDefinition
			ifTrue: [ classesDefined add: pseudoClass name ]
			ifFalse: [ classesExtended add: pseudoClass name ]].
	classesToRemove _ (packageInMemory classes asSet collect: [ :each | each name ]) difference: classesDefined.
	"Add here:
		- classes in classesToDelete, that #allCallsOn answers selectors that aren't in classesToDelete or methodsToRemove
		- classes with #subclasses that aren't in classesToDelete.
		- classes with existing instances (#instanceCount)? Not really sure... Maybe sole instance referenced from classVar or such...
		- something else I forgot?
	Warning: This search for stuff that can't be removed must be iterated again until it doesn't find any more."
	classesToDeleteButCant _ classesToRemove intersection: classesExtended.
	classesToReallyDelete _ classesToRemove difference: classesToDeleteButCant.
	"Methods. Could also mean classes that can't be deleted!! (include in the iteration)
	Warn if deleting last implementor of sent messages?"
	methodsToRemove _ packageInMemory methods asSet difference: self allMethodReferences.
	methodsToRemove _ methodsToRemove reject: [ :methodReference | classesToReallyDelete includes: methodReference classSymbol ].

"
	'=============' print.
	('classesToRemove: ', classesToRemove printString) print.
	('classesToDeleteButCant: ', classesToDeleteButCant printString) print.
	('classesToReallyDelete: ', classesToReallyDelete printString) print.
	'=============' print.
	'methodsToRemove: ' print.
	methodsToRemove do: [ :methodReference | methodReference print ].
	'=============' print.
"! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 4/25/2012 09:36' prior: 16813537!
                            createPackage

	| pkName |
	pkName_ FillInTheBlank request: 'Name for new package?'.
	CodePackage
		named: pkName
		createIfAbsent: true
		registerIfNew: true! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 4/25/2012 10:11' prior: 16961957!
                              okayToDiscardUnsavedCodeSaving: wouldSave
	"Answer true unless the user cancels quitting because of some warning given.
	Smalltalk okayToDiscardUnsavedCodeSaving: true
	Smalltalk okayToDiscardUnsavedCodeSaving: false
	"

	| baseCSdirty dirtyPackages |
	baseCSdirty _ ChangeSorter allChangeSets anySatisfy: [ :any | any isForBaseSystem and: [ any isEmpty hasUnsavedChanges ]].
	dirtyPackages _ CodePackage installedPackages anySatisfy: [ :pck | pck hasUnsavedChanges ].

	baseCSdirty & dirtyPackages ifTrue: [
		wouldSave ifTrue: [
			^self confirm: 'There are both unsaved Packages', String newLineString,
				'      (would need to be saved on next run), ', String newLineString,
				'and unsaved Changes to Cuis core', String newLineString,
				'      (they would be lost as a separate ChangeSet).', String newLineString,
				'Continue?' ]
		ifFalse: [
			^self confirm: 'There are both unsaved Packages', String newLineString,
				'and unsaved Changes to Cuis core.', String newLineString,
				'If you continue, they will all be lost.', String newLineString,
				'Continue?' ]].

	baseCSdirty ifTrue: [
		^self confirm: 'Some ChangeSet for Cuis core might have unsaved changes.', String newLineString,
			'If you continue, they would be lost.', String newLineString,
			'Continue?' ].

	dirtyPackages ifTrue: [
		wouldSave ifTrue: [
			^self confirm: 'There are unsaved Packages.', String newLineString,
				'If you continue, they will need to be saved on next run.', String newLineString,
				'Continue?' ]
		ifFalse: [
			^self confirm: 'There are unsaved Packages.', String newLineString,
				'If you continue, they will all be lost.', String newLineString,
				'Continue?' ]].

	^true! !

!classDefinition: #ChangeSet category: #'Tools-Changes'!
Object subclass: #ChangeSet
	instanceVariableNames: 'name preamble postscript changeRecords structures superclasses hasUnsavedChanges isForBaseSystem'
	classVariableNames: 'CurrentBaseCSNumber Installing'
	poolDictionaries: ''
	category: 'Tools-Changes'!

Object subclass: #ChangeSet
	instanceVariableNames: 'name preamble postscript changeRecords structures superclasses hasUnsavedChanges isForBaseSystem'
	classVariableNames: 'CurrentBaseCSNumber Installing'
	poolDictionaries: ''
	category: 'Tools-Changes'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
| name |
ChangeSet allInstancesDo: [ :each |
	each hasUnsavedChanges: each isEmpty not.
	name _ each name.
	each isForBaseSystem: ((name at: 1) isDigit
		and: [ (name at: 1) isDigit
			and: [ (name at: 1) isDigit
				and: [ (name at: 1) isDigit
					and: [ name is: '-CuisCore-' substingAt: 5 ]]]])]!

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1270/1261-CuisCore-JuanVuletich-2012Apr25-09h17m-jmv.9.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1261] on 25 April 2012 at 9:58:57 pm'!
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 4/25/2012 10:26' prior: 16801492!
                    changeSetForBaseSystem

	| csName numberToUse |
	Installing

		ifNil: [
			numberToUse _ self currentBaseCSNumber.
			ChangeSorter allChangeSets
				detect: [ :any | any name initialIntegerOrNil = numberToUse ]
				ifFound: [ :existing | ^existing ]
				ifNone: [
					csName _ (self baseSystemNameFor: numberToUse),
						(String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ]).
					^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: true ]]

		ifNotNil: [
			csName _ 'Affects-BaseSystem--Install-', Installing.
			^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false
			"Changes are for the base system, but are not user's own changes..." ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 4/25/2012 10:25' prior: 16801513!
    changeSetForPackage: aCodePackage

	| csName |
	aCodePackage ifNil: [
		^self changeSetForBaseSystem ].
	csName _ Installing
		ifNil: [ 'UnsavedChangesTo-', aCodePackage name ]
		ifNotNil: [
			Installing = aCodePackage packageName
				ifTrue: [ 'Install-', Installing ]
				ifFalse: [ 'Affects-', aCodePackage name, '--Install-', Installing ]].
	^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false! !
!CodeFileBrowserWindow class methodsFor: 'services' stamp: 'jmv 4/25/2012 09:37' prior: 16812113!
                         installPackageStream: aStream

	| fullName pkName existing |
	fullName _ aStream name.
	pkName _ CodePackageFile packageNameFrom: fullName.
	existing _ CodePackage named: pkName createIfAbsent: false registerIfNew: false.
	(existing isNil
		or: [ existing hasUnsavedChanges not
			or: [ self confirm: 'If you install this package, there are unsaved changes that will be lost.', String newLineString, 'Continue?' ]]) ifTrue: [
		Cursor wait showWhile: [
			CodePackageFile
				installFileStream: aStream
				packageName: pkName
				fullName: fullName ]]! !
!CodePackageFile methodsFor: 'services' stamp: 'jmv 4/25/2012 09:36' prior: 16813151!
                              install: aFileStream
	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."
	| localName newCodePackage |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].
	
	"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"

	"Crear, instalar y devolver una instancia de PackageInfo"
	newCodePackage_ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: true.
	newCodePackage
		fullFileName: fullName;
		sourceSystem: sourceSystem;
		description: description.

	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"
	"These were created in #fromFileStream: ... reuse?"
	localName _ FileDirectory localNameFor: fullName.
	ChangeSet installing: newCodePackage packageName do: [
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ]].
	newCodePackage hasUnsavedChanges: false.
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	"Tirar undeclared al transcript. warning si quedaron undeclared
	Es feo que tire an transcript undeclareds que despues no lo son..."
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	"Descartar la instancia de CodePackageFile"
	^newCodePackage! !

CodePackage class removeSelector: #named:!

CodePackage class removeSelector: #named:!

CodePackage class removeSelector: #newNamed:!

CodePackage class removeSelector: #newNamed:!

CodePackage removeSelector: #register!

CodePackage removeSelector: #register!

ChangeSorter class removeSelector: #existingOrNewChangeSetNamed:!

ChangeSorter class removeSelector: #existingOrNewChangeSetNamed:!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

| name |
ChangeSet allInstancesDo: [ :each |
	each hasUnsavedChanges: each isEmpty not.
	name _ each name.
	each isForBaseSystem: ((name at: 1) isDigit
		and: [ (name at: 1) isDigit
			and: [ (name at: 1) isDigit
				and: [ (name at: 1) isDigit
					and: [ name is: '-CuisCore-' substingAt: 5 ]]]])]!

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1270/1262-CuisCore-JuanVuletich-2012Apr25-21h56m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1260] on 23 April 2012 at 11:21:55 pm'!
!CodePackage methodsFor: 'saving' stamp: 'JMG 4/23/2012 23:21' prior: 50343280!
                           save
	| nameToUse |
	fullFileName ifNil: [
		fullFileName _
			ChangeSet defaultChangeSetDirectory fullNameFor: (self packageName, FileDirectory dot, 'pck')].
	nameToUse _ fullFileName.
"	nameToUse _ Preferences changeSetVersionNumbers
		ifTrue: [
			ChangeSet defaultChangeSetDirectory
				nextNameFor: self packageName coda: '-', Utilities authorInitials
				extension: 'pck' ]
		ifFalse: [ (self packageName , FileDirectory dot , Utilities dateTimeSuffix , FileDirectory dot , 'pck') asFileName ]."
	Cursor write
		showWhile: [
			| file |
			file _ ChangeSet defaultChangeSetDirectory forceNewFileNamed: nameToUse.
			[
				file timeStamp.
				self writeOnStream: file ]
					ensure: [ file close ]].
	self hasUnsavedChanges: false.
	ChangeSorter removeChangeSet: (ChangeSet changeSetForPackage: self)! !

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1270/1263-CuisCore-JeffGonis-2012Apr23-23h19m-JMG.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1262] on 25 April 2012 at 10:52:28 am'!
!TextProvider methodsFor: 'testing' stamp: 'jmv 4/25/2012 10:50'!
     refusesToAccept
	"This method must answer false if we usually accept text from a PluggableTextModel (i.e. we understand its textSetter), but are not accepting text right now."

	^ false! !
!PluggableTextModel methodsFor: 'testing' stamp: 'jmv 4/25/2012 10:52' prior: 16915463!
           wantsFrameAdornments

	^textSetter notNil! !

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1270/1264-CuisCore-JuanVuletich-2012Apr25-10h29m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1262] on 25 April 2012 at 11:01:04 am'!
!SocketStream commentStamp: '<historical>' prior: 16946165!
    SocketStream is a wrapper for class Socket making it easy to write networking code by giving the programmer a stream-like protocol. A Socket is a two way communication link with two logically separate channels - input and output. The Socket class is the lowest level in Squeak for network communication and using it directly can be difficult and bug prone.

A SocketStream can be in binary or ascii mode, ascii is the default which means you are transmitting and receiving Strings. Most Internet protocols are in clear text ascii, like for example HTTP. Another setting is what timeout you want to use - default is the standardTimeout from Socket. More settings can be found in the method category 'configuration'.

Simplest example of connecting, sending/receiving and closing:

| stream result |
stream := SocketStream openConnectionToHostNamed: 'www.squeak.org' port: 80.
[[stream nextPutAll: 'GET / HTTP/1.0'; newLine; newLine; flush.
result := stream upToEnd. "Give us all data until the socket is closed."
Transcript show: result withCuisLineEndings; newLine.]
	ensure: [stream close]]
		on: ConnectionTimedOut
		do: [:ex | Transcript show: ex asString; newLine. ex resume]

There are two important things to note above:
	- The methods in category "stream in" can signal two exceptions (unless turned off with #shouldSignal:):
		ConnectionClosed and ConnectionTimedOut
	- We close the stream using #ensure:, that is to make sure it isn't left opened.
	- We use #on:do: to catch any signal. In this case we do not need to catch ConnectionClosed since #upToEnd does that for us intrinsically.

----------------
SocketStream (below called SS) is a reimplementation of 'Old'-SocketStream (below called OSS) - the class that originates from the original Comanche implementation but now is included in standard Squeak. SS has the same protocol as OSS and is meant to replace it. SS is faster, more flexible, is better documented and adds a few features:

1. #shouldSignal:, which decides if SS should signal low level Socket exceptions (true) or if it should swallow them like original OSS did. Default is true. The only reason I added this is for backwards compatibility - not signalling causes problems - see bug 4 below.

2. #nextAllInBuffer, #nextInBuffer:, #skip:, #receiveData:, #nextPutAllFlush: and #recentlyRead are new additions to the public protocol.


It also fixes various bugs:

1. #isDataAvailable could theoretically answer false, when there actually is some in the buffer in OSS. If #receiveDataIfAvailable reads the last byte then the following "socket dataAvailable" would answer false. So the last byte would be sitting in the inStream missed.

2. #upToAll: in OSS has several problems, for example - #positionOfSubCollection:ifAbsent: which was introduced answers one position too low. This was compensated in upToAll:, but only in the pushBack: call, not the actual result being returned which was cut short 1 byte. Amusingly this makes KomHttpServer not use "Keep-Alive" since the last $e in 'Alive' was cut short. :)

3. SS doesn't inherit from PositionableStream since that just breaks various inherited messages, like for example #skip:. OSS should IMHO be changed to inherit from Object - or of course, replaced in full with SS. :)

4. Since SocketStream by default signals closes and timeouts the SocketStreamTest now passes. The reason for SocketStream to fail is that while it does timeout on a low level (#SocketStream>>receiveData doesn't hang forever) - the callers of #receiveData sometimes loop - like in #next:, and thus eliminates the timeout. SS warns about some methods (in their method comments) not honouring timeouts if shouldSignal is false, I really don't know what they should do in that case:
	#next:, #upTo:, #upToAll: and #upToEnd (and #receiveData:)


The primary reason for the SS implementation is optimal performance. The main differences in implementation with the old OSS are:

1. SS uses two buffers directly (inBuffer and outBuffer) with pointers marking start and stop within the buffer. OSS instead uses two regular streams, a ReadStream and a WriteStream. Using internal buffers makes it possible to avoid copying and reallocation in various ways, it also makes SS be able to have specialized growing/buffer moving behaviour.

2. #upTo:, #upToAll: and #peekForAll: uses selectged String messages that in turn uses fast primitives for searching. OSS used other messages that fell back on byte per byte reading.

3. #receiveData in OSS creates a temporary buffer stream for each call!! During a long read operation, like say #upToAll: (which for example is used when uploading files using HTTP POST forms), this is devastating - especially since the default size is only 2000 bytes - and leads to a very high number of low level read operations on the Socket, typically 100 times more calls than with OSS. The buffer in OSS is held in an instvar (not recreated for each call), is larger from the start and above all - grows dynamically by doubling. OSS can also avoid a grow/reallocation by doing a "move down" if data has been read from the SS as it comes in and through that making room in the lower part of the inBuffer. The net result is that upToAll: for large files is about 10 times faster.

4. The implementation of upTo: and upToAll: tries to avoid doing unnecessary find operations in the buffer and is greedy by default, which means it favors reading more data - if available - before searching for the stop sequence. If we had #findString:startingAt:stoppingAt: this wouldn't have to be greedy and we wouldn't be needlessly scanning dead buffer area. VM hackers? Also, while you are at it - make it work for ByteArrays too. :)


SS can not be run unbuffered, since that seems unneeded. The option to autoFlush is still available, with it set to true SocketStream (just like OSS) will flush on its own on each nextPut:/nextPutAll:, otherwise flushing it will have to be done manually but is done on close.

The first performance tests shows that, as noted above, receiving large amounts of data using #upToAll: is greatly improved - factor of 10. Serving HTTP with small payloads seemed at first not be faster at all - but this is due to the high overhead of Socket connect/close and other things. Increasing payloads show a difference and especially with keep alive on - where the new SS roughly doubles the throughput!!!
!String methodsFor: 'converting' stamp: 'jmv 4/25/2012 10:59' prior: 16956235!
                         withCuisLineEndings
	"assume the string is textual, and that CR, LF, and CRLF are all 
	valid line endings.  Replace each occurence with a single Lf
	('aLine', String crlfString, 'anotherOne') withCuisLineEndings
	"

	^ self withLineEndings: String newLineString! !

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1270/1265-CuisCore-JuanVuletich-2012Apr25-10h52m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1262] on 25 April 2012 at 11:22:21 am'!
!CodeProvider methodsFor: 'testing' stamp: 'jmv 4/25/2012 11:20'!
 isRefusingToAccept
	"Answer whether receiver, given its current contentsSymbol, could accept code happily if asked to"

	^ (#(byteCodes documentation) includes: self contentsSymbol)! !
!PluggableTextModel methodsFor: 'testing' stamp: 'jmv 4/25/2012 11:18' prior: 16915459!
               refusesToAccept
	^textProvider is: #refusingToAccept! !
!CodeProvider methodsFor: 'testing' stamp: 'jmv 4/25/2012 11:20' prior: 16814766!
                      is: aSymbol
	aSymbol = #refusingToAccept
		ifTrue: [ ^self isRefusingToAccept ].
	^(#(CodeProvider #ShoutEnabled) pointsTo: aSymbol)
		or: [ super is: aSymbol ]! !

CodeProvider removeSelector: #refusesToAccept!

CodeProvider removeSelector: #refusesToAccept!

TextProvider removeSelector: #refusesToAccept!

TextProvider removeSelector: #refusesToAccept!

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1270/1266-CuisCore-JuanVuletich-2012Apr25-11h11m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1262] on 25 April 2012 at 11:49:14 am'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 4/25/2012 11:49' prior: 50343403!
         okayToDiscardUnsavedCodeSaving: wouldSave
	"Answer true unless the user cancels quitting because of some warning given.
	Smalltalk okayToDiscardUnsavedCodeSaving: true
	Smalltalk okayToDiscardUnsavedCodeSaving: false
	"

	| baseCSdirty dirtyPackages |
	baseCSdirty _ ChangeSorter allChangeSets anySatisfy: [ :any | any isForBaseSystem and: [ any hasUnsavedChanges ]].
	dirtyPackages _ CodePackage installedPackages anySatisfy: [ :pck | pck hasUnsavedChanges ].

	baseCSdirty & dirtyPackages ifTrue: [
		wouldSave ifTrue: [
			^self confirm: 'There are both unsaved Packages', String newLineString,
				'      (would need to be saved on next run), ', String newLineString,
				'and unsaved Changes to Cuis core', String newLineString,
				'      (they would be lost as a separate ChangeSet).', String newLineString,
				'Continue?' ]
		ifFalse: [
			^self confirm: 'There are both unsaved Packages', String newLineString,
				'and unsaved Changes to Cuis core.', String newLineString,
				'If you continue, they will all be lost.', String newLineString,
				'Continue?' ]].

	baseCSdirty ifTrue: [
		^self confirm: 'Some ChangeSet for Cuis core might have unsaved changes.', String newLineString,
			'If you continue, they would be lost.', String newLineString,
			'Continue?' ].

	dirtyPackages ifTrue: [
		wouldSave ifTrue: [
			^self confirm: 'There are unsaved Packages.', String newLineString,
				'If you continue, they will need to be saved on next run.', String newLineString,
				'Continue?' ]
		ifFalse: [
			^self confirm: 'There are unsaved Packages.', String newLineString,
				'If you continue, they will all be lost.', String newLineString,
				'Continue?' ]].

	^true! !

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1270/1267-CuisCore-JuanVuletich-2012Apr25-11h22m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1267] on 28 April 2012 at 11:38:12 am'!
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 4/28/2012 11:34'!
                      popUpOwner
	^popUpOwner! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 4/27/2012 16:37'!
   makeMeFullyVisible 

	self world extent > (0@0) ifFalse: [^ self].

	(self position >= (0@0) and: [ self position < (self world extent-self extent)]) ifTrue: [
		^ self "OK -- visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self isCollapsed
		ifTrue: [self position: (RealEstateAgent assignCollapsePointFor: self)]
		ifFalse: [self position: (RealEstateAgent initialFrameFor: self initialExtent: bounds extent world: self world) topLeft].

! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 4/28/2012 11:38' prior: 16886998!
                    mouseEnter: evt
	"The mouse entered the receiver"
	owner popUpOwner ifNotNil: [ :parentItem |
		parentItem removeAlarm: #deselectTimeOut: ].
	owner ifNil: [ ^self ].
	owner selectItem: self event: evt! !
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 4/27/2012 16:38' prior: 16912138!
                               bringWindowsFullOnscreen
	"Make ever SystemWindow on the desktop be totally on-screen, whenever possible."
	
	(SystemWindow windowsIn: self satisfying: [:w | true]) do: [ :each |
		each makeMeFullyVisible ]! !

MenuMorph removeSelector: #staysUp!

MenuMorph removeSelector: #staysUp!

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1270/1268-CuisCore-JuanVuletich-2012Apr28-11h36m-jmv.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1267] on 30 April 2012 at 12:10:30 am'!
!CodePackage commentStamp: 'jmv 4/30/2012 00:03' prior: 16812140!
               A CodePackage is a package that is currently loaded in the system. If saved (.pck), then it is stored in a file that can be dealt with as an instance of PackageFile. As the code is already in the system, all we need to know is the packageName. Implementation is originally based on PackageInfo, but has diverged.

CodePackage instances are usually created when installing CodePackageFiles. These instances track the code for that package, that we'll need to save if we don't want to lose changes. These instances are held in the InstalledPackages class variable.

We can also create 'transient' instances with whatever name (and classes and extension methods) we chose, like
	(CodePackage named: 'Collections' createIfAbsent: true registerIfNew: false) inspect; save
This won't mean the system is actually partitioned in such way.

(CodePackage named: 'TestPackage' createIfAbsent: true registerIfNew: false) inspect; save!

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1270/1269-CuisCore-JuanVuletich-2012Apr30-00h01m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1269] on 30 April 2012 at 9:30:39 pm'!
!CodePackageFile class methodsFor: 'services' stamp: 'jmv 4/30/2012 21:29'!
      monticelloPackageNameFrom: fullName
	| localName |
	localName _ FileDirectory localNameFor: fullName.
	^(localName prefixAndSuffix: $-)
		ifNotNil: [ :ary | ary first ]
		ifNil: [ localName sansPeriodSuffix ].! !
!ChangeList class methodsFor: 'fileIn/Out' stamp: 'jmv 4/30/2012 21:29' prior: 16799128!
                  browseMCZContents: aStream
	"Browse the selected file."
	| unzipped changeList fullName packageFile pkName |
	
	"For Monticello packages we do as we do with our own .pck files: Instead of just browsing
	contents, also include what is no longer part of the package (and should therefore be removed on install)
	See #browsePackageContents:
	However, this was never tested to run!!"
	self flag: #jmvVer.

	fullName _ aStream name.
	pkName _ CodePackageFile monticelloPackageNameFrom: fullName.
	unzipped _ aStream asUnZippedStream: 'snapshot/source.st'.
	unzipped ascii.
	Cursor read showWhile: [
		changeList _ self new scanFile: unzipped from: 0 to: unzipped size.
		aStream reset.
		packageFile _ CodePackageFile
			buildFileStream: unzipped
			packageName: pkName
			fullName: fullName ].
	"Add deletions of methods and classes that are in the PackageInfo (i.e., active in the system)
	but are no longer in the PackageFile being viewed."
	packageFile methodsToRemove do: [ :methodReference |
		changeList
			addItem: (MethodDeletionChangeRecord new methodReference: methodReference)
			text: 'method no longer in package: ', methodReference asStringOrText ].
	packageFile classesToRemove do: [ :clsName |
		changeList
			addItem: (ClassDeletionChangeRecord new clsName: clsName)
			text: 'class no longer in package: ', clsName ].
	changeList clearSelections.
	ChangeListWindow open: changeList label: aStream name! !
!CodeFileBrowserWindow class methodsFor: 'services' stamp: 'jmv 4/30/2012 21:29' prior: 16812099!
                   installMonticelloPackageStream: aStream
	
	| stream fullName pkName |
	fullName _ aStream name.
	pkName _ CodePackageFile monticelloPackageNameFrom: fullName.
	stream _ aStream asUnZippedStream: 'snapshot/source.st'.
	stream ascii.
	Cursor wait showWhile: [
		CodePackageFile
			installFileStream: stream
			packageName: pkName
			fullName: fullName ]! !
!CodePackageFile class methodsFor: 'services' stamp: 'jmv 4/30/2012 21:30' prior: 16813274!
 packageNameFrom: fullName

	^(FileDirectory localNameFor: fullName) sansPeriodSuffix! !

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1270/1270-CuisCore-JuanVuletich-2012Apr30-21h29m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1270] on 2 May 2012 at 6:42:19 pm'!
!TestRunner methodsFor: 'processing' stamp: 'gsa 5/2/2012 18:39'!
                       runProfiledTests
	| suite |
	Cursor execute showWhile: [
		suite _ TestSuite new name: 'TestRunner Suite'.
		self selectedTests do: [ :ea | self addTestsFor: ea toSuite: suite ].
		self runSuiteProfiled: suite.
	]
! !
!TestRunner methodsFor: 'processing' stamp: 'gsa 5/2/2012 18:40'!
    runSuiteProfiled: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ MessageTally spyOn: [suite run] ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
	      priority: Processor userBackgroundPriority;
	      resume.
! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'gsa 5/2/2012 18:06'!
         buildRunProfiledButton
	| runProfiledButton |
	runProfiledButton := PluggableButtonMorph 
				model: model
				stateGetter: #runButtonState
				action: #runProfiledTests
				label: 'Run Profiled'.
	runProfiledButton
		color: self runButtonColor.
	^runProfiledButton! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'gsa 5/2/2012 18:34' prior: 16969110!
                         buildUpperControls
	| refreshButton filterButton stopButton runOneButton runButton runProfiledButton row column1 column2 column3 theTestsList |

	refreshButton _ self buildRefreshButton.
	filterButton _ self buildFilterButton.
	stopButton _ self buildStopButton.
	column1 _ LayoutMorph newColumn.
	column1 addMorphs: { refreshButton . filterButton . stopButton }.

	theTestsList _ PluggableListMorphOfMany
				model: model
				listGetter: #tests
				primarySelectionGetter: #selectedSuite
				primarySelectionSetter: #selectedSuite:
				listSelectionGetter: #listSelectionAt:
				listSelectionSetter: #listSelectionAt:put:
				mainView: self
				menuGetter: #listMenu
				keystrokeAction: nil.
	theTestsList autoDeselect: false.
	theTestsList color: Color veryVeryLightGray.
	column2 _ LayoutMorph newColumn.
	column2
		addMorph: theTestsList proportionalHeight: 1;
		addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight.

	runOneButton _ self buildRunOneButton.
	runButton _ self buildRunButton.
	runProfiledButton := self buildRunProfiledButton.	
	column3 _ LayoutMorph newColumn.
	column3 addMorphs: { runOneButton . runButton . runProfiledButton }.
	
	row _ LayoutMorph newRow.
	row
		addMorph: column1 fixedWidth: 80;
		addMorph: column2 proportionalWidth: 1;
		addMorph: column3 fixedWidth: 120.

	^row

! !

----End fileIn of /Volumes/CANON_DC/Cuis/1271-CuisCore-GermanArduino-2012May02-17h58m-gsa.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1271] on 7 May 2012 at 9:35:44 am'!

!classDefinition: #SystemConsistencyTest category: #'System-Tests'!
TestCase subclass: #SystemConsistencyTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Tests'!

TestCase subclass: #SystemConsistencyTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Tests'!
!SystemConsistencyTest commentStamp: '<historical>' prior: 0!
             General system - wide image health tests.!
!SystemConsistencyTest methodsFor: 'testing' stamp: 'jmv 5/7/2012 09:35'!
           testMethodsWithUnboundGlobals
	"
	SystemConsistencyTest new testMethodsWithUnboundGlobals
	"
	self assert: Smalltalk methodsWithUnboundGlobals isEmpty! !
!SystemDictionary methodsFor: 'query' stamp: 'jmv 5/6/2012 19:26'!
   methodsWithUnboundGlobals
	"Get all methods that use undeclared global objects that are not listed in Undeclared. For a clean image the result should be empty."
	"
	self assert: Smalltalk methodsWithUnboundGlobals isEmpty
	"
	^ self allSelect: [ :m |
		m literals anySatisfy: [ :l |
			l isVariableBinding and: [
				l key isSymbol and: [
					"avoid class-side methodClass literals"
					(m methodClass bindingOf: l key)
						ifNil: [
							(Undeclared
								associationAt: l key
								ifAbsent: [ ]) ~~ l ]
						ifNotNil: [ :b |
							b ~~ l ]]]]]! !

----End fileIn of /Volumes/CANON_DC/Cuis/1272-MethodsWithUnboundGlobals-JuanVuletich-2012May07-09h32m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1271] on 7 May 2012 at 9:38:15 am'!
!MessageTally class methodsFor: 'spying' stamp: 'jmv 5/7/2012 09:36' prior: 16892238!
              spyAllOn: aBlock
	"Spy on all the processes in the system
	
	[1000 timesRepeat: [3.14159 printString. Processor yield]] fork.
	[1000 timesRepeat: [20 factorial. Processor yield]] fork.
	[1000 timesRepeat: [20 factorial. Processor yield]] fork.
	MessageTally spyAllOn: [ (Delay forMilliseconds: 100) wait]
	
	"
	| node result |
	node _ self new.
	node reportOtherProcesses: true.	"Irrelevant in this case. All processes will be reported on their own."
	result _ node spyAllEvery: self defaultPollPeriod on: aBlock.
	SystemWindow
		editText: (Workspace withText: (String streamContents: [:s | node report: s]))
		label: 'Spy Results'
		wrap: false.
	^ result! !
!MessageTally class methodsFor: 'spying' stamp: 'jmv 5/7/2012 09:36' prior: 16892275!
                      spyOn: aBlock reportOtherProcesses: aBoolean
	"
	Spy on aBlock, in the current process. Can include or not statistics on other processes in the report.
	[1000 timesRepeat: [
		100 timesRepeat: [120 factorial].
		(Delay forMilliseconds: 10) wait
		]] forkAt: 45 named: '45'.
	MessageTally spyOn: [10000 timesRepeat: [1.23 printString]] reportOtherProcesses: true
	"
	| node result |
	node _ self new.
	node reportOtherProcesses: aBoolean.
	result _ node spyEvery: self defaultPollPeriod on: aBlock.
	SystemWindow
		editText: (Workspace withText: (String streamContents: [:s | node report: s]))
		label: 'Spy Results'
		wrap: false.
	^ result! !
!MessageTally class methodsFor: 'spying' stamp: 'jmv 5/7/2012 09:37' prior: 16892331!
      spyOnProcess: aProcess forMilliseconds: msecDuration reportOtherProcesses: aBoolean
	"
	Spy on aProcess for a certain amount of time
	| p1 p2 |  
	p1 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.  
	p2 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.
	p1 resume.
	p2 resume.  
	(Delay forMilliseconds: 100) wait.  
	MessageTally spyOnProcess: p1 forMilliseconds: 1000 reportOtherProcesses: true
	"
	| node |
	node _ self new.
	node reportOtherProcesses: aBoolean.
	node
		spyEvery: self defaultPollPeriod
		onProcess: aProcess
		forMilliseconds: msecDuration.
	SystemWindow
		editText: (Workspace withText: (String streamContents: [:s | node report: s]))
		label: 'Spy Results'
		wrap: false! !
!MessageTally class methodsFor: 'spying' stamp: 'jmv 5/7/2012 09:37' prior: 16892381!
                            tallySendsTo: receiver inBlock: aBlock showTree: treeOption
	"
	MessageTally tallySends: [3.14159 printString]
	"
	"This method uses the simulator to count the number of calls on each method
	invoked in evaluating aBlock. If receiver is not nil, then only sends
	to that receiver are tallied.
	Results are presented as leaves, sorted by frequency,
	preceded, optionally, by the whole tree."
	| prev tallies startTime totalTime |
	startTime _ Time millisecondClockValue.
	tallies _ MessageTally new class: aBlock receiver class method: aBlock method.
	tallies reportOtherProcesses: true.	"Do NOT filter nodes with nil process"
	prev _ aBlock.
	thisContext sender
		runSimulated: aBlock
		contextAtEachStep: [ :current |
			current == prev ifFalse: [ "call or return"
				prev sender ifNotNil: [ "call only"
					(receiver == nil or: [ current receiver == receiver ])
						ifTrue: [ tallies tally: current by: 1 ]].
				prev _ current]].

	totalTime _ Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.
	SystemWindow
		editText: (Workspace withText: (String streamContents: [ :s |
			s nextPutAll: 'This simulation took ' , totalTime printString, ' seconds.'; newLine.
			treeOption
				ifTrue: [ tallies fullPrintExactOn: s ]
				ifFalse: [ tallies leavesPrintExactOn: s ]]))
		label: 'Spy Results'
		wrap: false! !

----End fileIn of /Volumes/CANON_DC/Cuis/1273-MessageTallyOpensWorkspace-JuanVuletich-2012May07-09h35m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1271] on 7 May 2012 at 9:41:05 am'!
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 5/7/2012 09:40' prior: 16861123!
               paragraph: aParagraph bounds: boundsInWorld color: c selectionColor: sc
	| displayScanner leftInRun line |

	self setPaintColor: c.

	displayScanner _ MorphicScanner new 
		text: aParagraph paragraphText
		foreground: (shadowColor ifNil: [ c ])
		ignoreColorChanges: self isShadowDrawing.
	displayScanner canvas: self.

	leftInRun _ 0.
	"Take clipRect into account. Extrememly fast scrolls and redraws of huge files (like .sources)"
	(aParagraph lineIndexForPoint: (0@0 max: clipRect origin- boundsInWorld origin))
		to: (aParagraph lineIndexForPoint: (boundsInWorld extent min: clipRect corner - boundsInWorld origin))
		do: [ :i |
			line _ aParagraph lines at: i.
			aParagraph
				displaySelectionInLine: line
				on: self
				paragraphTopLeft: boundsInWorld topLeft
				selectionColor: sc.
			leftInRun _ displayScanner displayLine: line paragraphTopLeft: boundsInWorld topLeft leftInRun: leftInRun  ]! !

----End fileIn of /Volumes/CANON_DC/Cuis/1274-SuperFastHugeTextDraw-JuanVuletich-2012May07-09h38m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1271] on 7 May 2012 at 9:58:06 am'!
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 5/7/2012 09:56' prior: 16821805!
                      endPC
	"Answer the index of the last bytecode."
	| size flagByte |
	"Can't create a zero-sized CompiledMethod so no need to use last for the errorEmptyCollection check.
	 We can reuse size."
	size := self size.
	flagByte := self at: size.
	flagByte = 0 ifTrue: [
		"If last byte = 0, may be either 0, 0, 0, 0 or just 0"
		1 to: 3 do: [:i | (self at: size - i) = 0 ifFalse: [^size - i]].
		^size - 4].
	flagByte < 252 ifTrue: [
		"Magic sources (temp names encoded in last few bytes)"
		^flagByte <= 127
			ifTrue: [size - flagByte - 1]
			ifFalse: [size - (flagByte - 128 * 128) - (self at: size - 1) - 2]].
	"Normal 4-byte source pointer"
	^size - 4! !

----End fileIn of /Volumes/CANON_DC/Cuis/1275-endPCfix-JuanVuletich-2012May07-09h41m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1275] on 7 May 2012 at 1:44:24 pm'!
!BreakPoint commentStamp: '<historical>' prior: 16793543!
                              This exception is raised on executing a breakpoint.

"BreakPoint signal" is called from "Object>>break".!
!BreakpointManager commentStamp: '<historical>' prior: 16793556!
                     This class manages methods that include breakpoints.
It has several class methods to install and uninstall breakpoints.

Evaluating "BreakpointManager clear" will remove all installed breakpoints in the system.

Known issues:
- currently, only break-on-entry type of breakpoints are supported
- emphasis change not implemented for MVC browsers
- uninstalling the breakpoint doesn't auto-update other browsers
- uninstalling a breakpoint while debugging should restart-simulate the current method

Ernest Micklei, 2002

Send comments to emicklei@philemonworks.com!
!ConnectionClosed commentStamp: '<historical>' prior: 16826045!
            Signals a prematurely closed connection.!
!ConnectionTimedOut commentStamp: '<historical>' prior: 16826325!
                    Signals that a connection attempt timed out.!
!ExceptionAboutToReturn commentStamp: '<historical>' prior: 16846364!
            This class is private to the EHS implementation.  Its use allows for ensured execution to survive code such as:

[self doThis.
^nil]
	ensure: [self doThat]

Signaling or handling this exception is not recommended.  Not even slightly.!
!ExternalSemaphoreTable commentStamp: '<historical>' prior: 16847198!
               By John M McIntosh johnmci@smalltalkconsulting.com
This class was written to mange the external semaphore table. When I was writing a Socket test server I discovered various race conditions on the access to the externalSemaphore table. This new class uses class side methods to restrict access using a mutex semaphore. It seemed cleaner to deligate the reponsibility here versus adding more code and another class variable to SystemDictionary 

Note that in Smalltalk recreateSpecialObjectsArray we still directly play with the table.!
!IdentityBag commentStamp: '<historical>' prior: 16867422!
             Like a Bag, except that items are compared with #== instead of #= .

See the comment of IdentitySet for more information.!
!InvalidSocketStatusException commentStamp: '<historical>' prior: 16878188!
                         Signals if an operation on a Socket found it in a state invalid for that operation.!
!NetNameResolver commentStamp: '<historical>' prior: 16901704!
            This class implements TCP/IP style network name lookup and translation facilities.

Attempt to keep track of whether there is a network available.
HaveNetwork	true if last attempt to contact the network was successful.
LastContact		Time of that contact (totalSeconds).
haveNetwork	returns true, false, or #expired.  True means there was contact in the last 30 minutes.  False means contact failed or was false last time we asked.  Get out of false state by making contact with a server in some way (FileList or updates).!
!NoNetworkError commentStamp: '<historical>' prior: 16902223!
                        Signals that no network was found. This could happen, e.g., on dial-up connection when no connection was established when Squeak tried to access it.!
!SoundService commentStamp: '<historical>' prior: 16949962!
              This is the AppRegistry class for the sound system.

A sound system offers a small protocol for playing sounds and making beeps and works like a facade towards the rest of Squeak. A sound system is registered in this registry and can be accessed by "SoundService default". This way we decouple the sound system from the rest of Squeak and make it pluggable. It also is a perfect spot to check for the Preference class>>soundsEnabled.!
!Transcript commentStamp: '<historical>' prior: 16978076!
                   A new implementation of Transcript.
- Thread safe.
- Very fast.
- Independent of Morphic or any other UI framework.
- Immediate feedback.
- Can log to file.
- Not an editor. Only used for output.
- All protocol is on the Class side!
!UnloadedSound commentStamp: '<historical>' prior: 16980518!
                          Instances of me, which are really just FMSounds, are used placeholders for sounds that have been unloaded from this image but which may be re-loaded later.!

----End fileIn of /Volumes/CANON_DC/Cuis/1276-FixCrs-JuanVuletich-2012May07-13h41m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1275] on 7 May 2012 at 2:00:31 pm'!

!classDefinition: #SHTextStyler category: #'Shout-Styling'!
Object subclass: #SHTextStyler
	instanceVariableNames: 'sem backgroundProcess monitor formattedText textModel mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Shout-Styling'!

Object subclass: #SHTextStyler
	instanceVariableNames: 'sem backgroundProcess monitor formattedText textModel mutex '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Shout-Styling'!
!SHTextStyler methodsFor: 'private' stamp: 'jmv 5/7/2012 13:57'!
             mutex
	mutex
		ifNil: [ mutex := Mutex new ].
	^mutex! !
!SHTextStyler methodsFor: 'styling' stamp: 'jmv 5/7/2012 13:57' prior: 16931250!
                      styleInBackgroundProcess
	"Do the styling on a copy of the provided text (and in a separate process).
	After finishing, send it to the model, via #stylerStyled:checkForChanges:
	The the model should grab the TextAttributes we added to the copy, as appropriate."
	self terminateBackgroundStylingProcess.

	formattedText _ textModel actualContents copy.
	self mutex critical: [
		
		"This part, running at current priority, and fired by sem, is for events to be triggered at current priority"
		sem _ Semaphore new. 
		[
			sem ifNotNil: [
				sem wait.
				textModel stylerStyled: formattedText checkForChanges: true ]
		] forkAt: Processor activePriority.

		"This part runs at low priority, and signals sem when finished"
		backgroundProcess _  [
			textModel privateStyleWith: self.
			sem signal] newProcess.
		backgroundProcess priority: Processor userBackgroundPriority.
		backgroundProcess resume
	]! !
!SHTextStyler methodsFor: 'private' stamp: 'jmv 5/7/2012 13:58' prior: 16931288!
  terminateBackgroundStylingProcess
	self mutex critical: [
		backgroundProcess 
			ifNotNil: [
				backgroundProcess terminate.
				backgroundProcess := nil].
		sem 
			ifNotNil:[
				sem terminateProcess.
				sem := nil].	
	]		! !

SHTextStyler removeSelector: #monitor!

SHTextStyler removeSelector: #monitor!

!classDefinition: #SHTextStyler category: #'Shout-Styling'!
Object subclass: #SHTextStyler
	instanceVariableNames: 'sem backgroundProcess formattedText textModel mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Shout-Styling'!

Object subclass: #SHTextStyler
	instanceVariableNames: 'sem backgroundProcess formattedText textModel mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Shout-Styling'!

----End fileIn of /Volumes/CANON_DC/Cuis/1277-UseMutexInShout-JuanVuletich-2012May07-13h44m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1277] on 7 May 2012 at 2:40:53 pm'!
!Mutex commentStamp: 'jmv 5/7/2012 14:40' prior: 16901598!
 A Mutex is a light-weight MUTual EXclusion object being used when two or more processes need to access a shared resource concurrently. A Mutex grants ownership to a single process and will suspend any other process trying to aquire the mutex while in use. Waiting processes are granted access to the mutex in the order the access was requested.

Nested (or recursive) calls to #critical: from a single process are allowed, and the process is not blocked for this: access is granted immediately. For this reason instances of Mutex should be used for resources that support this form of multiple access (i.e. multiple simultaneous access from within a single Process). Resources that don't support this, like access to private state that changes for each call, should use a Semaphore. See Semaphore's class comment

Instance variables:
	semaphore		<Semaphore>		The (primitive) semaphore used for synchronization.
	owner			<Process>			The process owning the mutex.!
!Semaphore commentStamp: 'jmv 5/7/2012 14:39' prior: 16935436!
                              I provide synchronized communication of a single bit of information (a "signal") between Processes. A signal is sent by sending the message signal and received by sending the message wait. If no signal has been sent when a wait message is sent, the sending Process will be suspended until a signal is sent.

Beware that if a process calls 'aSemaphore critical: []' while already in a critical section for that semaphore, it will enter a deadlock. In some cases, a Mutex can be used instead. Refer to the Mutex class comment.!

----End fileIn of /Volumes/CANON_DC/Cuis/1278-MutexAndSemaphoreComments-JuanVuletich-2012May07-14h03m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1278] on 7 May 2012 at 10:10:48 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/7/2012 22:09'!
                            contributorInitialsAndNames
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk contributorInitialsAndNames collect: [ :pair | pair first ]) asSet.
self assert: all = ok

initials         name"
^ #(
	#('ab' 					'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 					'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 					'Andreas Raab')
	#('asm' 				'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('bf' 					'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 				'Bolot Kerimbaev')
	#('bp' 					'Bernhard Pieber')
	#('BP' 					'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'					'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 				'Chris Muller')
	#('crl' 					'Craig Latta')
	#('cwp' 				'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 					'Damien Cassou')
	#('dew' 				'Doug Way')
	#('dgd' 				'Diego Gomez Deck')
	#('dhhi' 				'Dan Ingalls')
	#('di' 					'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DSM' 				'Duane Maxwell')
	#('dtl' 					'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 				'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 					'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 	'Fernando Olivero')
	#('FernanodOlivero' 	'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gh' 					'Goran Krampe (nee Hultgren)')
	#('gk' 					'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 					'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('hmm' 				'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 					'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 					'Joern Eyrich')
	#('jf' 					'Julian Fitzell')
	#('JF' 					'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jlb' 					'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 				'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 					'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 				'Kurt Thams')
	#('laza' 				'Alexander Lazarevic')
	#('LC' 					'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lr' 					'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 					'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 				'Mike Rutenberg')
	#('mga' 				'Markus Galli')
	#('mha' 				'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 				'Michael Hewner')
	#('mpw' 				'Marcel Weiher')
	#('MPW' 				'Marcel Weiher')
	#('mrm' 				'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 					'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 					'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 					'Nathanael Schaerli')
	#('panda' 				'Michael Rueger')
	#('PHK' 				'Peter Keeler')
	#('Pmm' 				'Philippe Marschall')
	#('pnm' 				'Paul McDonough')
	#('r++' 				'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 				'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 					'Robert Hirschfeld')
	#('rr' 					'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 					'Robert Withers')
	#('rww' 				'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 				'Stephan B. Wessels')
	#('sd' 					'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 				'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sr' 					'Stephan Rudlof')
	#('SSS' 				'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 				'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 					'Torge Husfeldt')
	#('tk' 					'Ted Kaehler')
	#('tlk' 					'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 					'Levente Uzonyi')
	#('vb' 					'Vassili Bykov')
	#('ward' 				'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 				'Bill Dargel')
	#('yo' 					'Yoshiki Ohshima')
	#('zz' 					'Serge Stinckwich'))! !
!AdditionalMethodState methodsFor: 'testing' stamp: 'jmv 5/7/2012 16:16' prior: 16781057!
                              hasLiteralSuchThat: aBlock
	"Answer true if litBlock returns true for any literal in this array, even if embedded in further array structure.
	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"
	1 to: self basicSize do: [:i |
		| propertyOrPragma "<Association|Pragma>" |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
			ifTrue: [(aBlock value: propertyOrPragma key)
					or: [(aBlock value: propertyOrPragma value)
					or: [propertyOrPragma value isArray
						and: [propertyOrPragma value hasLiteralSuchThat: aBlock]]]]
			ifFalse: [propertyOrPragma hasLiteralSuchThat: aBlock]) ifTrue: [^true]].
	^false! !
!AdditionalMethodState methodsFor: 'accessing' stamp: 'jmv 5/7/2012 21:34' prior: 16781171!
at: aKey put: aValue
	"Replace the property value or pragma associated with aKey."

	| keyAlreadyExists |
	keyAlreadyExists _ false.
	
	1 to: self basicSize do: [ :i |
		| propertyOrPragma "<Association|Pragma>" |
		(propertyOrPragma _ self basicAt: i) key == aKey ifTrue: [
			keyAlreadyExists _ true.
			propertyOrPragma isVariableBinding
				ifTrue: [ propertyOrPragma value: aValue ]
				ifFalse: [ self basicAt: i put: aValue ]]].
	
	keyAlreadyExists ifFalse: [
		method propertyValueAt: aKey put: aValue ].
	
	^ aValue! !
!Color methodsFor: 'transformations' stamp: 'jmv 5/7/2012 15:05' prior: 16817497!
                              twiceDarker
	"Answer a significantly darker shade of this color."

	^ self adjustSaturation: 0.076 brightness: -0.15! !
!DateAndTime methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:26' prior: 16832510!
                noon
	"Answer a DateAndTime starting at noon"

	^ self dayMonthYearDo: [ :d :m :y |
		self class year: y month: m day: d hour: 12 minute: 0 second: 0 ]! !
!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:25' prior: 16832895!
       epoch
	"Answer a DateAndTime representing the Squeak epoch: 1 January 1901"

	^ self julianDayNumber: SqueakEpoch! !
!ExceptionSet methodsFor: 'private' stamp: 'jmv 5/7/2012 21:38' prior: 16846393!
                          add: anException

	^exceptions add: anException! !
!ExceptionTester methodsFor: 'tests' stamp: 'jmv 5/7/2012 21:38' prior: 16846949!
                           simpleNoTimeoutTest

	[ self doSomething ]
		valueWithin: 1 days onTimeout:
			[ self doSomethingElse ]! !
!FloatTest methodsFor: 'IEEE 754' stamp: 'jmv 5/7/2012 15:15' prior: 16856078!
      testInfinity3
	self assert:
		(Float infinity negated asIEEE32BitWord
			printPaddedWith: $0
			to: 32
			base: 2) = '11111111100000000000000000000000'.
	self assert:
		(Float fromIEEE32Bit:
			(Integer
				readFrom: '11111111100000000000000000000000' readStream
				base: 2)) = Float infinity negated! !
!FloatTest methodsFor: 'IEEE 754' stamp: 'jmv 5/7/2012 15:15' prior: 16856112!
testZero2
	self assert:
		(Float negativeZero asIEEE32BitWord
			printPaddedWith: $0
			to: 32
			base: 2) = '10000000000000000000000000000000'.
	self assert:
		(Float fromIEEE32Bit:
			(Integer
				readFrom: '10000000000000000000000000000000' readStream
				base: 2)) = Float negativeZero! !
!Heap methodsFor: 'removing' stamp: 'jmv 5/7/2012 21:54' prior: 16866021!
                 removeAll

	array atAllPut: nil.
	tally _ 0! !
!Integer methodsFor: 'bit manipulation' stamp: 'jmv 5/7/2012 15:09' prior: 16873686!
                            >> shiftAmount  "right shift"
	shiftAmount < 0 ifTrue: [self error: 'negative arg'].
	^ self bitShift: shiftAmount negated! !
!MethodContext methodsFor: 'printing' stamp: 'jmv 5/7/2012 20:25' prior: 16893289!
               printString
	"Answer an emphasized string in case of a breakpoint method"
	(self method notNil and: [ self method hasBreakpoint ])
		ifFalse: [ ^ super printString ].
	^ super printString , ' [break]' asText allBold! !
!ParserNotification methodsFor: 'as yet unclassified' stamp: 'jmv 5/7/2012 16:20' prior: 16911486!
  setName: aString

	name _ aString! !
!Process methodsFor: 'accessing' stamp: 'jmv 5/7/2012 16:16' prior: 16921330!
             isTerminated

	self isActiveProcess ifTrue: [^ false].
	^suspendedContext isNil
	  or: ["If the suspendedContext is the bottomContext it is the block in Process>>newProcess.
		   If so, and the pc is greater than the startpc, the bock has alrteady sent and returned
		   from value and there is nothing more to do."
		suspendedContext isBottomContext
		and: [
			suspendedContext pc > suspendedContext startpc]]! !
!SmallIntegerTest methodsFor: 'testing - basic' stamp: 'jmv 5/7/2012 21:35' prior: 16941097!
    testEven
	
	self assert: (SmallInteger minVal even).
	self deny: (SmallInteger maxVal even).
	
	self deny: ((SmallInteger minVal + 1) even).
	self assert: ((SmallInteger maxVal - 1) even).
	
	self deny: (1 even).
	self deny: (-1 even).
	
	self assert: (2 even).
	self assert: (-2 even).
	
	self assert: (0 even)! !
!SmallIntegerTest methodsFor: 'testing - basic' stamp: 'jmv 5/7/2012 21:35' prior: 16941110!
        testOdd
	
	self deny: (SmallInteger minVal odd).
	self assert: (SmallInteger maxVal odd).
	
	self assert: ((SmallInteger minVal + 1) odd).
	self deny: ((SmallInteger maxVal - 1) odd).
	
	self assert: (1 odd).
	self assert: (-1 odd).
	
	self deny: (2 odd).
	self deny: (-2 odd).
	
	self deny: (0 odd)! !
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/7/2012 15:19' prior: 16959983!
                       allContributors
"
	Smalltalk allContributors
"
	| bag author |
	bag _ Bag new.
	Smalltalk allBehaviorsDo: [ :behavior |
		behavior methodsDo: [ :compiledMethod |
			author _ compiledMethod author.
			author notEmpty ifTrue: [
				bag add: author ]]].
	^bag! !
!SystemDictionary class methodsFor: 'copyright' stamp: 'jmv 5/7/2012 14:49' prior: 16964558!
                               copyright
	"The Smalltalk copyright.
	Parts are copyright of many contributors to Squeak and Cuis projects."

	^
'Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982.
Copyright (c) Apple Computer, Inc. 1985-1996.
Copyright (c) Contributors to Squeak and Cuis projects. 1997-2012.'! !
!Time class methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:26' prior: 16977361!
      hour: hour minute: minute second: second nanoSecond: nanoCount
	"Answer a Time"

	^ self 
		seconds: (hour * SecondsInHour) + (minute * SecondsInMinute) + second 
		nanoSeconds: nanoCount! !
!Time class methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:27' prior: 16977375!
          noon

	^ self seconds: (SecondsInDay / 2)! !
!UndefinedVariable methodsFor: 'as yet unclassified' stamp: 'jmv 5/7/2012 16:19' prior: 16980327!
                 openMenuIn: aBlock
	| labels caption index |
	labels _ #('yes' 'no' ).
	caption _ name , ' appears to be 
undefined at this point.
Proceed anyway?'.
	index _ aBlock
		value: labels
		value: #()
		value: caption.
	^ self resume: index = 1! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/7/2012 15:25' prior: 16985838!
                        startDay
	^ StartDay ifNil: [ StartDay _ DayNames first ]! !

Utilities class removeSelector: #reportSenderCountsFor:!

Utilities class removeSelector: #reportSenderCountsFor:!

SystemDictionary removeSelector: #agreedContributors!

SystemDictionary removeSelector: #agreedContributors!

SystemDictionary removeSelector: #missingAuthorsWithMethods!

SystemDictionary removeSelector: #missingAuthorsWithMethods!

SystemDictionary removeSelector: #newContributors!

SystemDictionary removeSelector: #newContributors!

SystemDictionary removeSelector: #okContributors!

SystemDictionary removeSelector: #okContributors!

SystemDictionary removeSelector: #relicenseEffortStartDate!

SystemDictionary removeSelector: #relicenseEffortStartDate!

SystemDictionary removeSelector: #returnedSignatories!

SystemDictionary removeSelector: #returnedSignatories!

BlockContext removeSelector: #argumentCount!

BlockContext removeSelector: #argumentCount!

----End fileIn of /Volumes/CANON_DC/Cuis/1279-AuthorNamesTweaks-JuanVuletich-2012May07-18h42m-jmv.3.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #4220] on 11 May 2012 at 3:42:03 pm'!
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 5/11/2012 15:40' prior: 50344516!
                       endPC
	"Answer the index of the last bytecode."
	| size flagByte |
	"Can't create a zero-sized CompiledMethod so no need to use last for the errorEmptyCollection check.
	 We can reuse size."
	size := self size.
	flagByte := self at: size.
	flagByte = 0 ifTrue: [
		"If last byte = 0, may be either 0, 0, 0, 0 or just 0"
		size-1 to: size-3 by: -1 do: [ :i |
			i < self initialPC ifTrue: [ ^ i ].
			(self at: i) = 0 ifFalse: [ ^ i ]].
		^size - 4].
	flagByte < 252 ifTrue: [
		"Magic sources (temp names encoded in last few bytes)"
		^flagByte <= 127
			ifTrue: [size - flagByte - 1]
			ifFalse: [size - (flagByte - 128 * 128) - (self at: size - 1) - 2]].
	"Normal 4-byte source pointer"
	^size - 4! !

----End fileIn of /Volumes/CANON_DC/Cuis/1280-CuisCore-JuanVuletich-2012May11-15h33m-jmv.1.cs----!

----SNAPSHOT----#(12 May 2012 7:34:19 pm) Cuis4.0-1280.image priorSource: 434!

'From Cuis 4.0 of 21 April 2012 [latest update: #1260] on 24 April 2012 at 1:05:20 am'!

'Description Please enter a description for this package '!

!classDefinition: #CypressJsonParser category: #'Cypress-Structure'!
Object subclass: #CypressJsonParser
	instanceVariableNames: 'stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Structure'!

Object subclass: #CypressJsonParser
	instanceVariableNames: 'stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Structure'!

!classDefinition: 'CypressJsonParser class' category: #'Cypress-Structure'!
CypressJsonParser class
	instanceVariableNames: ''!

CypressJsonParser class
	instanceVariableNames: ''!

!classDefinition: #CypressPackageReader category: #'Cypress-Structure'!
Object subclass: #CypressPackageReader
	instanceVariableNames: 'packageDirectory packageStructure properties'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Structure'!

Object subclass: #CypressPackageReader
	instanceVariableNames: 'packageDirectory packageStructure properties'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Structure'!

!classDefinition: 'CypressPackageReader class' category: #'Cypress-Structure'!
CypressPackageReader class
	instanceVariableNames: ''!

CypressPackageReader class
	instanceVariableNames: ''!

!classDefinition: #CypressPackageWriter category: #'Cypress-Structure'!
Object subclass: #CypressPackageWriter
	instanceVariableNames: 'packageStructure rootDirectory packageDirectory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Structure'!

Object subclass: #CypressPackageWriter
	instanceVariableNames: 'packageStructure rootDirectory packageDirectory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Structure'!

!classDefinition: 'CypressPackageWriter class' category: #'Cypress-Structure'!
CypressPackageWriter class
	instanceVariableNames: 'specials'!

CypressPackageWriter class
	instanceVariableNames: 'specials'!

!classDefinition: #CypressStructure category: #'Cypress-Structure'!
Object subclass: #CypressStructure
	instanceVariableNames: 'name properties packageStructure'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Structure'!

Object subclass: #CypressStructure
	instanceVariableNames: 'name properties packageStructure'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Structure'!

!classDefinition: 'CypressStructure class' category: #'Cypress-Structure'!
CypressStructure class
	instanceVariableNames: ''!

CypressStructure class
	instanceVariableNames: ''!

!classDefinition: #CypressClassStructure category: #'Cypress-Structure'!
CypressStructure subclass: #CypressClassStructure
	instanceVariableNames: 'instanceMethods classMethods comment isClassExtension'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Structure'!

CypressStructure subclass: #CypressClassStructure
	instanceVariableNames: 'instanceMethods classMethods comment isClassExtension'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Structure'!

!classDefinition: 'CypressClassStructure class' category: #'Cypress-Structure'!
CypressClassStructure class
	instanceVariableNames: ''!

CypressClassStructure class
	instanceVariableNames: ''!

!classDefinition: #CypressMethodStructure category: #'Cypress-Structure'!
CypressStructure subclass: #CypressMethodStructure
	instanceVariableNames: 'source isMetaclass classStructure'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Structure'!

CypressStructure subclass: #CypressMethodStructure
	instanceVariableNames: 'source isMetaclass classStructure'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Structure'!

!classDefinition: 'CypressMethodStructure class' category: #'Cypress-Structure'!
CypressMethodStructure class
	instanceVariableNames: ''!

CypressMethodStructure class
	instanceVariableNames: ''!

!classDefinition: #CypressPackageStructure category: #'Cypress-Structure'!
CypressStructure subclass: #CypressPackageStructure
	instanceVariableNames: 'classes extensions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Structure'!

CypressStructure subclass: #CypressPackageStructure
	instanceVariableNames: 'classes extensions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Structure'!

!classDefinition: 'CypressPackageStructure class' category: #'Cypress-Structure'!
CypressPackageStructure class
	instanceVariableNames: ''!

CypressPackageStructure class
	instanceVariableNames: ''!
!Array methodsFor: '*Cypress-Structure'!
                       asCypressPropertyObject

	^self collect: [:each | each asCypressPropertyObject ]
! !
!Array methodsFor: '*Cypress-Structure' stamp: 'dkh 4/23/2012 23:36'!
     writeCypressJsonOn: aStream  indent: startIndent

	| indent |
	aStream 
		nextPutAll: '[';
		newLine.
	indent := startIndent + 1.
	1 to: self size do: [:index | | item | 
		item := self at: index.
		aStream tab: indent.
		item writeCypressJsonOn: aStream  indent: indent.
		index < self size ifTrue: [ aStream nextPutAll: ','; newLine ]].
	self size = 0 ifTrue: [ aStream tab: indent ].
	aStream nextPutAll: ' ]'
! !
!Boolean methodsFor: '*Cypress-Structure'!
                    writeCypressJsonOn: aStream  indent: startIndent

	aStream 
		nextPutAll: self printString
! !
!Character methodsFor: '*Cypress-Structure' stamp: 'dkh 4/23/2012 23:50'!
                       isSafeForHTTP
	"whether a character is 'safe', or needs to be escaped when used, eg, in a URL"

	^  value < 128
		and: [ self isAlphaNumeric
				or: [ '.-_' includes: self ]]
! !
!CypressClassStructure methodsFor: 'converting'!
                            asCypressClassDefinition
	self isClassExtension ifTrue: [ ^nil ].
	^CypressClassDefinition
		name: self className
		superclassName: self superclassName
		category: self category 
		instVarNames: self instanceVariableNames
		classInstVarNames: self classInstanceVariableNames
		comment: self comment
! !
!CypressClassStructure methodsFor: 'accessing'!
 category

	^self packageStructure packageName
! !
!CypressClassStructure methodsFor: 'accessing'!
                              classInstanceVariableNames
	^self properties at: 'classinstvars' ifAbsent: ['']
! !
!CypressClassStructure methodsFor: 'accessing'!
                            classInstanceVariableNames: aString
	^self properties at: 'classinstvars' put: aString
! !
!CypressClassStructure methodsFor: 'querying'!
                      classMethodNamed: methodName

	^self classMethods 
		at: methodName 
		ifAbsent: [ self classMethods at: methodName put: (CypressMethodStructure new name: methodName) ]
! !
!CypressClassStructure methodsFor: 'accessing'!
   classMethods

	classMethods ifNil: [ classMethods := Dictionary new ].
	^classMethods
! !
!CypressClassStructure methodsFor: 'accessing'!
                      className

	^self name
! !
!CypressClassStructure methodsFor: 'accessing'!
                     comment

	comment ifNil: [ comment := '' ].
	^comment
! !
!CypressClassStructure methodsFor: 'accessing'!
                      comment: aString

	comment := aString
! !
!CypressClassStructure methodsFor: 'initialization'!
 fromClassDefinition: classDefinition

	self isClassExtension: false.
	self name: classDefinition name.
	self comment: classDefinition comment.
  	self superclassName: classDefinition superclassName.
	self instanceVariableNames: classDefinition instVarNames.
	self classInstanceVariableNames: classDefinition classInstVarNames.
! !
!CypressClassStructure methodsFor: 'initialization'!
fromJs: jsObject

	properties := jsObject at: 'properties.json'.
	(jsObject at: 'class' ifAbsent: [#()]) do: [:jsMethodObject |  | methodNameParts |
		methodNameParts := self splitMethodNameFor: jsMethodObject.
		(self classMethodNamed: (methodNameParts at: 1)) 
			packageStructure: self packageStructure;
			classStructure: self;
			isMetaclass: true;
			fromJs: jsMethodObject named: methodNameParts ].
	(jsObject at: 'instance' ifAbsent: [#()]) do: [:jsMethodObject |  | methodNameParts |
		methodNameParts := self splitMethodNameFor: jsMethodObject.
		(self instanceMethodNamed: (methodNameParts at: 1)) 
			packageStructure: self packageStructure;
			classStructure: self;
			fromJs: jsMethodObject named: methodNameParts ].	
	comment := jsObject at: 'README.md' ifAbsent: ['']
! !
!CypressClassStructure methodsFor: 'querying'!
                             instanceMethodNamed: methodName

	^self instanceMethods 
		at: methodName 
		ifAbsent: [ self instanceMethods at: methodName put: (CypressMethodStructure new name: methodName) ]
! !
!CypressClassStructure methodsFor: 'accessing'!
                          instanceMethods

	instanceMethods ifNil: [ instanceMethods := Dictionary new ].
	^instanceMethods
! !
!CypressClassStructure methodsFor: 'accessing'!
          instanceVariableNames

	^self properties at: 'instvars' ifAbsent: ['']
! !
!CypressClassStructure methodsFor: 'accessing'!
     instanceVariableNames: aString

	^self properties at: 'instvars' put: aString
! !
!CypressClassStructure methodsFor: 'accessing'!
                              isClassExtension

        isClassExtension ifNil: [ isClassExtension := true ].
        ^isClassExtension
! !
!CypressClassStructure methodsFor: 'accessing'!
  isClassExtension: aBoolean

	isClassExtension := aBoolean
! !
!CypressClassStructure methodsFor: 'accessing'!
                  name

	^self properties at: 'name'
! !
!CypressClassStructure methodsFor: 'accessing'!
         name: aString

	self properties at: 'name' put: aString
! !
!CypressClassStructure methodsFor: 'private' stamp: 'dkh 4/23/2012 23:25'!
                         splitMethodName: methodName

	| ext  |
	ext := '.json'.
	(   '*' , ext match: methodName)
		ifFalse: [
			ext := '.st'.
			('*' , ext match: methodName)
				ifFalse: [ self error: 'invalid structure element: ', methodName ] ].
	^{methodName copyFrom: 1 to: (methodName size - ext size). ext}
! !
!CypressClassStructure methodsFor: 'private' stamp: 'dkh 4/23/2012 23:24'!
             splitMethodNameFor: jsMethodObject

	^self splitMethodName: (jsMethodObject at: 'name')! !
!CypressClassStructure methodsFor: 'accessing'!
                     superclassName

	^self properties at: 'super'
! !
!CypressClassStructure methodsFor: 'accessing'!
                              superclassName: aString

	^self properties at: 'super' put: aString
! !
!CypressClassStructure methodsFor: 'writing' stamp: 'dkh 4/23/2012 23:38'!
             writeJsonOn: aStream  indent: startIndent

	| indent methods |
	indent := startIndent.
	aStream 
		tab: indent;
		nextPutAll: '{';
		newLine.
	indent := indent + 1.
	aStream
		tab: indent;
		nextPutAll: '"name"';
		nextPutAll: ' : ';
		nextPutAll: '"', self name, (self isClassExtension ifTrue: [ '.extension' ] ifFalse: [ '.class' ]), '",';
		newLine.
	aStream
		tab: indent;
		nextPutAll: '"instance" : [';
		newLine;
		yourself.
	methods := self instanceMethods values asArray sorted: [:a :b | a selector <= b selector].
	1 to: methods size do: [:index | | methodStructure | 
		methodStructure := methods at: index.
		methodStructure writeJsonOn: aStream indent: indent + 1.
		index < methods size ifTrue: [ aStream nextPutAll: ','; newLine ]].
	aStream
		tab: indent;
		nextPutAll: '],';
		newLine;
		yourself.
	aStream
		tab: indent;
		nextPutAll: '"class" : [';
		newLine;
		yourself.
	methods := self classMethods values asArray sorted: [:a :b | a selector <= b selector].
	1 to: methods size do: [:index | | methodStructure | 
		methodStructure := methods at: index.
		methodStructure writeJsonOn: aStream indent: indent + 1.
		index < methods size ifTrue: [ aStream nextPutAll: ','; newLine ]].
	aStream
		tab: indent;
		nextPutAll: ']'.
	self isClassExtension
		ifFalse: [ 
			aStream
				nextPutAll: ',';
				newLine;
				tab: indent;
				nextPutAll: '"README.md" : ';
				yourself.
			self comment writeCypressJsonOn: aStream indent: indent ].
	aStream
		nextPutAll: ',';
		newLine;
		tab: indent;
		nextPutAll: '"properties.json" : ';
		yourself.
	self properties writeCypressJsonOn: aStream indent: indent.
	indent := indent - 1.
	aStream
		newLine;
		tab: indent;
		nextPutAll: ' }'
! !
!CypressClassStructure class methodsFor: 'instance creation'!
                            fromClassDefinition: classDefinition

	^self new
		fromClassDefinition: classDefinition;
		yourself
! !
!CypressJsonParser methodsFor: 'adding' stamp: 'dkh 2/16/2012 14:39:25'!
               addProperty: anAssociation to: anObject	"Add the property anAssociation described with key and value to anObject. Subclasses might want to refine this implementation."		^ anObject 		add: anAssociation;		yourself! !
!CypressJsonParser methodsFor: 'adding' stamp: 'dkh 2/16/2012 14:39:25'!
                           addValue: anObject to: aCollection	"Add anObject to aCollection. Subclasses might want to refine this implementation."	^ aCollection copyWith: anObject! !
!CypressJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!
                       createArray	"Create an empty collection. Subclasses might want to refine this implementation."	^ Array new! !
!CypressJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!
    createFalse	"Create the false literal. Subclasses might want to refine this implementation."		^ false! !
!CypressJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!
         createNull	"Create the null literal. Subclasses might want to refine this implementation."	^ nil! !
!CypressJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!
              createNumber: aString	"Create a number literal. Subclasses might want to refine this implementation."	^ aString asNumber! !
!CypressJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!
                      createObject	"Create an empty object. Subclasses might want to refine this implementation."		^ Dictionary new! !
!CypressJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!
 createProperty: aKey with: aValue	"Create an empty attribute value pair. Subclasses might want to refine this implementation."		^ aKey -> aValue! !
!CypressJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!
                              createString: aString	"Create a string literal. Subclasses might want to refine this implementation."	^ aString! !
!CypressJsonParser methodsFor: 'creating' stamp: 'dkh 2/16/2012 14:39:25'!
                               createTrue	"Create the true literal. Subclasses might want to refine this implementation."	^ true! !
!CypressJsonParser methodsFor: 'private' stamp: 'dkh 2/16/2012 14:39:25'!
              expect: aString	"Expects aString and consume input, throw an error otherwise."	^ (self match: aString) ifFalse: [ self error: aString , ' expected' ]! !
!CypressJsonParser methodsFor: 'initialization' stamp: 'dkh 2/16/2012 14:39:25'!
                   initializeOn: aStream	self initialize.	stream := aStream! !
!CypressJsonParser methodsFor: 'private' stamp: 'dkh 2/16/2012 14:39:25'!
                        match: aString	"Tries to match aString, consume input and answer true if successful."		| position |	position := stream position.	aString do: [ :each |		(stream atEnd or: [ stream next ~= each ]) ifTrue: [ 			stream position: position.			^ false ] ].	self whitespace.	^ true! !
!CypressJsonParser methodsFor: 'parsing' stamp: 'dkh 2/16/2012 14:39:25'!
                       parse	| result |	result := self whitespace; parseValue.	stream atEnd		ifFalse: [ self error: 'end of input expected' ].	^ result! !
!CypressJsonParser methodsFor: 'parsing' stamp: 'dkh 2/16/2012 14:39:25'!
             parseArray	| result |	self expect: '['.	result := self createArray.	(self match: ']')		ifTrue: [ ^ result ].	[ stream atEnd ] whileFalse: [		result := self			addValue: self parseValue			to: result.		(self match: ']') 			ifTrue: [ ^ result ].		self expect: ',' ].	self error: 'end of array expected'! !
!CypressJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 4/23/2012 23:39'!
                     parseCharacter	| char |	(char := stream next) = $\ 		ifFalse: [ ^ char ].	(char := stream next) = $" 		ifTrue: [ ^ char ].	char = $\		ifTrue: [ ^ char ].	char = $/		ifTrue: [ ^ char ].	char = $b		ifTrue: [ ^ Character backspace ].	char = $f		ifTrue: [ ^ Character newPage ].	char = $n		ifTrue: [ ^ Character lfCharacter ].	char = $r		ifTrue: [ ^ Character crCharacter ].	char = $t		ifTrue: [ ^ Character tab ].	char = $u		ifTrue: [ ^ self parseCharacterHex ].	self error: 'invalid escape character \' , (String with: char)! !
!CypressJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 2/16/2012 14:39:25'!
         parseCharacterHex	| value |	value := self parseCharacterHexDigit.	3 timesRepeat: [ value := (value << 4) + self parseCharacterHexDigit ].	^ Character codePoint: value! !
!CypressJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 4/6/2012 15:56:14'!
parseCharacterHexDigit    | digit |    stream atEnd        ifFalse: [             digit := stream next charCode.            (digit between: 48 and: 57)                ifTrue: [ ^ digit - 48 ].	"$0"	"$9"            (digit between: 65 and: 70)                ifTrue: [ ^ digit - 55 ].	"$A"	"$F"            (digit between: 97 and: 102)                ifTrue: [ ^ digit - 87 ]	"$a"	"$f" ].    self error: 'hex-digit expected'! !
!CypressJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 2/16/2012 14:39:25'!
                         parseNumber	| negated number |	negated := stream peek = $-.	negated ifTrue: [ stream next ].	number := self parseNumberInteger.	(stream peek = $.) ifTrue: [		stream next. 		number := number + self parseNumberFraction ].	(stream peek = $e or: [ stream peek = $E ]) ifTrue: [		stream next.		number := number * self parseNumberExponent ].	negated ifTrue: [ number := number negated ].	^ self whitespace; createNumber: number! !
!CypressJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 4/6/2012 15:56:14'!
                         parseNumberExponent    | number negated |    number := 0.    negated := stream peek = $-.    (negated or: [ stream peek = $+ ])        ifTrue: [ stream next ].    [ stream atEnd not and: [ stream peek isDigit ] ] whileTrue: [ number := 10 * number + (stream next charCode - 48) ].    negated        ifTrue: [ number := number negated ].    ^ 10 raisedTo: number! !
!CypressJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 4/6/2012 15:56:14'!
                        parseNumberFraction    | number power |    number := 0.    power := 1.0.    [ stream atEnd not and: [ stream peek isDigit ] ]        whileTrue: [             number := 10 * number + (stream next charCode - 48).            power := power * 10.0 ].    ^ number / power! !
!CypressJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 4/23/2012 23:35'!
                          parseNumberInteger    | number |    number := 0.    [ stream atEnd not and: [ stream peek isDigit ] ] whileTrue: [ number := 10 * number + (stream next asciiValue - 48) ].    ^ number! !
!CypressJsonParser methodsFor: 'parsing' stamp: 'dkh 2/16/2012 14:39:25'!
                       parseObject	| result |	self expect: '{'.	result := self createObject.	(self match: '}')		ifTrue: [ ^ result ].	[ stream atEnd ] whileFalse: [		result := self			addProperty: self parseProperty			to: result.		(self match: '}')			ifTrue: [ ^ result ].		self expect: ',' ].	self error: 'end of object expected'! !
!CypressJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 2/16/2012 14:39:25'!
          parseProperty	| name value |	name := self parseString.	self expect: ':'.	value := self parseValue.	^ self createProperty: name with: value.! !
!CypressJsonParser methodsFor: 'parsing-internal' stamp: 'dkh 2/16/2012 14:39:25'!
                         parseString	| result |	self expect: '"'.	result := WriteStream on: String new.	[ stream atEnd or: [ stream peek = $" ] ] 		whileFalse: [ result nextPut: self parseCharacter ].	^ self expect: '"'; createString: result contents! !
!CypressJsonParser methodsFor: 'parsing' stamp: 'dkh 2/16/2012 14:39:25'!
           parseValue	| char |	stream atEnd ifFalse: [ 		char := stream peek.		char = ${			ifTrue: [ ^ self parseObject ].		char = $[			ifTrue: [ ^ self parseArray ].		char = $"			ifTrue: [ ^ self parseString ].		(char = $- or: [ char between: $0 and: $9 ])			ifTrue: [ ^ self parseNumber ].		(self match: 'true')			ifTrue: [ ^ self createTrue ].		(self match: 'false')			ifTrue: [ ^ self createFalse ].		(self match: 'null')			ifTrue: [ ^ self createNull ] ].	self error: 'invalid input'! !
!CypressJsonParser methodsFor: 'private' stamp: 'dkh 2/16/2012 14:39:25'!
   whitespace	"Strip whitespaces from the input stream."	[ stream atEnd not and: [ stream peek isSeparator ] ]		whileTrue: [ stream next ]! !
!CypressJsonParser class methodsFor: 'instance creation' stamp: 'dkh 2/16/2012 14:39:25'!
                       new	self error: 'Instantiate the parser with a stream.'! !
!CypressJsonParser class methodsFor: 'instance creation' stamp: 'dkh 2/16/2012 14:39:25'!
          on: aStream	^ self basicNew initializeOn: aStream! !
!CypressJsonParser class methodsFor: 'accessing' stamp: 'dkh 2/16/2012 14:39:25'!
                        parse: aString	^ self parseStream: aString readStream! !
!CypressJsonParser class methodsFor: 'accessing' stamp: 'dkh 2/16/2012 14:39:25'!
                    parseStream: aStream	^ (self on: aStream) parse! !
!CypressMethodStructure methodsFor: 'converting'!
                          asCypressMethodDefinition

	^CypressMethodDefinition 
        	className: self classStructure className
		classIsMeta: self isMetaclass
		selector: self selector
		category: self category
		source: self source
! !
!CypressMethodStructure methodsFor: 'accessing'!
                         category

	^self properties at: 'category'
! !
!CypressMethodStructure methodsFor: 'accessing'!
category: aString

	self properties at: 'category' put: aString
! !
!CypressMethodStructure methodsFor: 'accessing'!
           classStructure
	^classStructure
! !
!CypressMethodStructure methodsFor: 'accessing'!
           classStructure: aCypressClassStructure
	classStructure := aCypressClassStructure
! !
!CypressMethodStructure methodsFor: 'accessing' stamp: 'dkh 4/23/2012 23:37'!
                             cypressSource

	| stream |
	stream := WriteStream on: String new.
	stream 
		nextPutAll: self category;
		newLine;
		nextPutAll: self source.
	^stream contents
! !
!CypressMethodStructure methodsFor: 'private' stamp: 'dkh 4/23/2012 23:28'!
                extractCypressSource: aString
    | stream categoryStream sourceStream readingCategory |
    stream := ReadStream on: aString.
    categoryStream := WriteStream on: String new.
    sourceStream := WriteStream on: String new.
    readingCategory := true.
    [ stream atEnd ]
        whileFalse: [ 
            | char |
            char := stream next.
            readingCategory
                ifTrue: [ 
                    char = Character lfCharacter
                        ifTrue: [ readingCategory := false ]
                        ifFalse: [ categoryStream nextPut: char ] ]
                ifFalse: [ sourceStream nextPut: char ] ].
    self category: categoryStream contents.
    self source: sourceStream contents! !
!CypressMethodStructure methodsFor: 'initialization'!
                fromJs: jsObject  named: methodNameParts

	| ext |
	(ext := methodNameParts at: 2) = '.st'
		ifTrue: [  self extractCypressSource: (jsObject at: 'contents') ]
		ifFalse: [ ext = '.json' ifTrue: [  properties := jsObject at: 'contents' ] ]
! !
!CypressMethodStructure methodsFor: 'initialization'!
                       fromMethodDefinition: methodDefinition

	self isMetaclass: methodDefinition classIsMeta.
	self selector: methodDefinition selector.
	self category: methodDefinition category.
	self source: methodDefinition source.
! !
!CypressMethodStructure methodsFor: 'accessing'!
                     isMetaclass

	isMetaclass ifNil: [ isMetaclass := false ].
	^isMetaclass
! !
!CypressMethodStructure methodsFor: 'accessing'!
  isMetaclass: aBoolean
	isMetaclass := aBoolean
! !
!CypressMethodStructure methodsFor: 'accessing' stamp: 'dkh 4/24/2012 00:07'!
                               selector
    ^ String
        streamContents: [ :stream | 
            self name
                do: [ :chara | 
                    stream
                        nextPut:
                            (chara = $.
                                ifTrue: [ $: ]
                                ifFalse: [ chara ]) ] ]! !
!CypressMethodStructure methodsFor: 'accessing' stamp: 'dkh 4/24/2012 00:06'!
                   selector: aString
    name := String
        streamContents: [ :stream | 
            aString
                do: [ :chara | 
                    stream
                        nextPut:
                            (chara = $:
                                ifTrue: [ $. ]
                                ifFalse: [ chara ]) ] ]! !
!CypressMethodStructure methodsFor: 'accessing'!
   source

	^source
! !
!CypressMethodStructure methodsFor: 'accessing'!
                          source: aString

	source := aString
! !
!CypressMethodStructure methodsFor: 'writing' stamp: 'dkh 4/23/2012 23:37'!
            writeJsonOn: aStream  indent: startIndent

	| indent |
	indent := startIndent.
	aStream 
		tab: indent;
		nextPutAll: '{';
		newLine.
	indent := indent + 1.
	aStream
		tab: indent;
		nextPutAll: '"name"';
		nextPutAll: ' : ';
		nextPutAll: '"', self name, '.st",';
		newLine.
	aStream
		tab: indent;
		nextPutAll: '"contents"';
		nextPutAll: ' : '.
	self cypressSource writeCypressJsonOn: aStream indent: indent.
	indent := indent - 1.
	aStream
		newLine;
		tab: indent;
		nextPutAll: ' }'
! !
!CypressMethodStructure class methodsFor: 'instance creation'!
                   fromMethodDefinition: methodDefinition

	^self new
		fromMethodDefinition: methodDefinition;
		yourself
! !
!CypressPackageReader methodsFor: 'private' stamp: 'dkh 4/22/2012 13:24:15'!
       classStructureFrom: classPropertiesDict 	^(CypressClassStructure new)		isClassExtension: true;		properties: classPropertiesDict;		yourself! !
!CypressPackageReader methodsFor: 'private' stamp: 'dkh 4/22/2012 13:24:15'!
classStructureFrom: classPropertiesDict comment: classComment.	^(self classStructureFrom: classPropertiesDict)		isClassExtension: false;		comment: classComment;		yourself! !
!CypressPackageReader methodsFor: 'accessing' stamp: 'dkh 4/22/2012 13:24:15'!
                              packageDirectory	^packageDirectory! !
!CypressPackageReader methodsFor: 'accessing' stamp: 'dkh 4/22/2012 13:24:15'!
         packageDirectory: aDirectory	packageDirectory := aDirectory! !
!CypressPackageReader methodsFor: 'accessing' stamp: 'dkh 4/22/2012 13:24:15'!
                packageStructure	^packageStructure! !
!CypressPackageReader methodsFor: 'accessing' stamp: 'dkh 4/22/2012 13:24:15'!
         packageStructure: aPackageStructure	packageStructure := aPackageStructure! !
!CypressPackageReader methodsFor: 'reading' stamp: 'dkh 4/22/2012 13:24:15'!
    read    	self readPropertiesFile.	self readPackageStructure! !
!CypressPackageReader methodsFor: 'reading' stamp: 'dkh 4/23/2012 20:19'!
                    readClassStructureFromEntry: classEntry    | classDirectory classPropertiesDict classComment entries classStructure |    classDirectory := classEntry asFileDirectory.    ((entries := classDirectory entries) detect: [ :entry | entry name = 'properties.json' ] ifNone: [  ])        ifNotNil: [ :propertyEntry | propertyEntry readStreamDo: [ :fileStream | classPropertiesDict := CypressJsonParser parseStream: fileStream ] ].    (entries detect: [ :entry | entry name = 'README.md' ] ifNone: [  ])        ifNotNil: [ :commentEntry | commentEntry readStreamDo: [ :fileStream | classComment := fileStream contents ] ].    classStructure := self classStructureFrom: classPropertiesDict comment: classComment.    self readMethodStructureFor: classStructure in: entries.	^classStructure! !
!CypressPackageReader methodsFor: 'reading' stamp: 'dkh 4/23/2012 20:20'!
                              readExtensionClassStructureFromEntry: classEntry    | classDirectory classPropertiesDict entries classStructure |    classDirectory := classEntry asFileDirectory.    ((entries := classDirectory entries) detect: [ :entry | entry name = 'properties.json' ] ifNone: [  ])        ifNotNil: [ :propertyEntry | propertyEntry readStreamDo: [ :fileStream | classPropertiesDict := CypressJsonParser parseStream: fileStream ] ].    classStructure := self classStructureFrom: classPropertiesDict.    self readMethodStructureFor: classStructure in: entries.	^classStructure! !
!CypressPackageReader methodsFor: 'reading' stamp: 'dkh 4/22/2012 13:24:15'!
                      readMethodStructureFor: classStructure in: entries    entries        do: [ :entry |             | methods isMeta |		isMeta := false. 		methods := entry name = 'class'                ifTrue: [ 			isMeta := true.			classStructure classMethods ]		    ifFalse: [ classStructure instanceMethods ].            (entry name = 'instance' or: [ entry name = 'class' ])                ifTrue: [                     (entry asFileDirectory entries select: [ :each | each name endsWith: '.st' ])                        do: [ :methodEntry |                             methodEntry                                readStreamDo: [ :fileStream |                                     | category source selector |                                    category := fileStream nextLine.                                    source := fileStream upToEnd.						selector := Parser new parseSelector: source.                                     methods 							at: selector							put: ((CypressMethodStructure new)									name: selector;									isMetaclass: isMeta;									selector: selector;									category: category;									source: source;									yourself) ] ] ] ]! !
!CypressPackageReader methodsFor: 'reading' stamp: 'dkh 4/22/2012 13:24:15'!
                               readPackageStructure   packageStructure := CypressPackageStructure new name: self packageDirectory localName.   self packageDirectory entries        do: [ :entry |             (entry name endsWith: '.class')                ifTrue: [ self packageStructure classes add: (self readClassStructureFromEntry: entry) ].            (entry name endsWith: '.extension')                ifTrue: [ self packageStructure extensions add: (self readExtensionClassStructureFromEntry: entry) ] ]! !
!CypressPackageReader methodsFor: 'reading' stamp: 'dkh 4/23/2012 20:20'!
             readPropertiesFile		self packageDirectory 		readOnlyFileNamed: 'properties.json'		do: [:fileStream |			properties := CypressJsonParser parseStream: fileStream ]! !
!CypressPackageReader class methodsFor: 'instance creation' stamp: 'dkh 4/22/2012 13:24:15'!
                          readPackageStructureFrom: aPackagesDirectory	^(self new)		packageDirectory: aPackagesDirectory;		read;		yourself! !
!CypressPackageStructure methodsFor: 'accessing'!
                     classes

	classes ifNil: [ classes := OrderedCollection new ].
	^classes
! !
!CypressPackageStructure methodsFor: 'accessing'!
 extensions

	extensions ifNil: [ extensions := OrderedCollection new ].
	^extensions
! !
!CypressPackageStructure methodsFor: 'initialization' stamp: 'dkh 4/24/2012 00:46'!
                   fromJs: jsObject

	name := jsObject at: 'name'.
	(jsObject at: 'contents') do: [:jsClassObject| | classStructure objectName |
		classStructure := (CypressClassStructure new)
                		packageStructure: self;
				yourself.
                (  '*.extension' match:(objectName := jsClassObject at: 'name') )
			ifTrue: [ 
				classStructure isClassExtension: true.
				self extensions add: classStructure ]
			ifFalse: [
				( '*.class' match: objectName)
					ifTrue: [ 
						classStructure isClassExtension: false.
						self classes add: classStructure ]].
		classStructure fromJs: jsClassObject].
	properties := jsObject at: 'properties.json'
! !
!CypressPackageStructure methodsFor: 'initialization'!
                         fromPackage: aCypressPackageDefinition

	| snapshot classMap classDefinitions classStructure |
	snapshot := aCypressPackageDefinition snapshot.
	name := aCypressPackageDefinition name, '.package'.
	properties := Dictionary new.
	classDefinitions := Set new.
	classMap := Dictionary new.
	snapshot definitions do: [:definition |  
			definition 
				classDefinition: [:classDefinition |  classDefinitions add: classDefinition ] 
				methodDefinition: [:methodDefinition | 
					(classMap 
						at: methodDefinition className 
						ifAbsent: [classMap at: methodDefinition className put: Set new]) 
							add: methodDefinition. ]].
	classDefinitions do: [:classDefinition |
		classStructure := (CypressClassStructure fromClassDefinition: classDefinition)
			packageStructure: self.
		(classMap removeKey: classDefinition className ifAbsent: [#()]) do: [:methodDefinition | | methodStructure |
			methodStructure := (CypressMethodStructure fromMethodDefinition: methodDefinition)
				packageStructure: self;
				classStructure: classStructure.
			(methodDefinition
				instanceMethod: [:instanceMethod | classStructure instanceMethods ] 
				classMethod: [:classMethod | classStructure classMethods ])
					at: methodDefinition selector
					put: methodStructure ].
		self classes add: classStructure ].
	classMap keysAndValuesDo: [:className :methods |
		classStructure := (CypressClassStructure new name: className)
			packageStructure: self.
		methods do: [:methodDefinition | | methodStructure |
			methodStructure := (CypressMethodStructure fromMethodDefinition: methodDefinition)
				packageStructure: self;
				classStructure: classStructure.
			(methodDefinition
				instanceMethod: [:instanceMethod | classStructure instanceMethods ] 
				classMethod: [:classMethod | classStructure classMethods ])
					at: methodDefinition selector
					put: methodStructure ].
		self extensions add: classStructure ].
! !
!CypressPackageStructure methodsFor: 'accessing'!
                 packageExtension

	^self properties at: 'extension' ifAbsent: ['.package' ]
! !
!CypressPackageStructure methodsFor: 'accessing'!
                              packageName

	^self name copyFrom: 1 to: (self name size - self packageExtension size)
! !
!CypressPackageStructure methodsFor: 'accessing'!
                   packageStructure
	^self
! !
!CypressPackageStructure methodsFor: 'snapshotting'!
               snapshot
	| definitions map  |
	definitions := OrderedCollection new.
	self classes do: [:classStructure |
        	definitions add: classStructure asCypressClassDefinition.
                (classStructure instanceMethods values asArray sorted: [:a :b | a selector <= b selector]) do: [:methodStructure |
			definitions add: methodStructure asCypressMethodDefinition ].
                (classStructure classMethods values asArray sorted: [:a :b | a selector <= b selector]) do: [:methodStructure |
			definitions add: methodStructure asCypressMethodDefinition ]].
	self extensions do: [:classStructure |
                (classStructure instanceMethods values asArray sorted: [:a :b | a selector <= b selector]) do: [:methodStructure |
			definitions add: methodStructure asCypressMethodDefinition ].
                (classStructure classMethods values asArray sorted: [:a :b | a selector <= b selector]) do: [:methodStructure |
			definitions add: methodStructure asCypressMethodDefinition ]].
	^ CypressSnapshot definitions: definitions
! !
!CypressPackageStructure methodsFor: 'writing' stamp: 'dkh 4/23/2012 23:39'!
 writeJsonOn: aStream  indent: startIndent

	| indent |
	indent := startIndent.
	aStream 
		tab: indent;
		nextPutAll: '{';
		newLine.
	indent := indent + 1.
	aStream
		tab: indent;
		nextPutAll: '"name"';
		nextPutAll: ' : ';
		nextPutAll: '"', self name, '",'.
	aStream
		newLine;
		tab: indent;
		nextPutAll: '"contents" : [';
		newLine;
		yourself.
	1 to: self classes size do: [:index | | classStructure | 
		classStructure := self classes at: index.
		classStructure writeJsonOn: aStream indent: indent + 1.
		(self extensions size > 0 or: [ index < self classes size]) ifTrue: [ aStream nextPutAll: ','; newLine. ]].
	1 to: self extensions size do: [:index | | classStructure | 
		classStructure := self extensions at: index.
		classStructure writeJsonOn: aStream indent: indent + 1.
		index < self extensions size ifTrue: [ aStream nextPutAll: ','; newLine.] ].
	aStream
		newLine;
		tab: indent;
		nextPutAll: '],';
		newLine;
		tab: indent;
		nextPutAll: '"properties.json" : '.
	self properties writeCypressJsonOn: aStream indent: indent.
	indent := indent - 1.
	aStream 
		newLine;
		tab: indent;
		nextPutAll: '}'
! !
!CypressPackageStructure class methodsFor: 'instance creation' stamp: 'dkh 4/23/2012 23:33'!
                         fromJson: aJsonString

	^self fromJs: (CypressJsonParser parse: aJsonString)
! !
!CypressPackageStructure class methodsFor: 'instance creation'!
               fromPackage: aCypressPackageDefinition

	^(self new) 
		fromPackage: aCypressPackageDefinition;
		yourself
! !
!CypressPackageWriter methodsFor: 'private' stamp: 'dkh 4/22/2012 13:24:15'!
    directoryForDirectoryNamed: directoryNameOrPath    ^ directoryNameOrPath = '.'        ifTrue: [ self packageDirectory assureExistence ]        ifFalse: [ | dir |            dir := self packageDirectory directoryNamed: directoryNameOrPath.            dir assureExistence.            dir  ]! !
!CypressPackageWriter methodsFor: 'private' stamp: 'dkh 4/22/2012 13:24:15'!
         fileNameForSelector: selector    ^ selector last = $:        ifTrue: [             selector                collect: [ :each |                     each = $:                        ifTrue: [ $. ]                        ifFalse: [ each ] ] ]        ifFalse: [             selector first isLetter                ifTrue: [ selector ]                ifFalse: [                     | output specials |                    specials := self class specials.                    output := String new writeStream.                    output nextPut: $^.                    selector do: [ :each | output nextPutAll: (specials at: each) ] separatedBy: [ output nextPut: $. ].                    output contents ] ]! !
!CypressPackageWriter methodsFor: 'accessing' stamp: 'dkh 4/22/2012 13:24:15'!
   packageDirectory	packageDirectory 		ifNil: [ 			packageDirectory := self rootDirectory directoryNamed: self packageStructure name.			packageDirectory assureExistence ].	^packageDirectory! !
!CypressPackageWriter methodsFor: 'accessing' stamp: 'dkh 4/22/2012 13:24:15'!
             packageDirectory: aPackageDirectory	packageDirectory := aPackageDirectory! !
!CypressPackageWriter methodsFor: 'accessing' stamp: 'dkh 4/22/2012 13:24:15'!
  packageStructure	^packageStructure! !
!CypressPackageWriter methodsFor: 'accessing' stamp: 'dkh 4/22/2012 13:24:15'!
         packageStructure: aCypressPackageStructure	packageStructure := aCypressPackageStructure! !
!CypressPackageWriter methodsFor: 'accessing' stamp: 'dkh 4/22/2012 13:24:15'!
                    rootDirectory	^rootDirectory! !
!CypressPackageWriter methodsFor: 'accessing' stamp: 'dkh 4/22/2012 13:24:15'!
               rootDirectory: aDirectory	rootDirectory := aDirectory! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'dkh 4/22/2012 13:24:15'!
                        write	self packageDirectory exists        ifTrue: [ self packageDirectory recursiveDelete ].    	self writePropertiesFile.	self writePackageStructure! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'dkh 4/22/2012 13:24:15'!
                     writeClassComment: classStructure on: fileStream    fileStream nextPutAll: classStructure comment withUnixLineEndings! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'dkh 4/22/2012 13:24:15'!
                         writeClassStructure: classStructure on: fileStream    | properties |    properties := Dictionary new.    properties at: 'name' put: classStructure className.    properties at: 'super' put: classStructure superclassName.    properties at: 'instvars' put: classStructure instanceVariableNames.    properties at: 'classinstvars' put: classStructure classInstanceVariableNames.    properties writeCypressJsonOn: fileStream! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'dkh 4/22/2012 13:24:15'!
     writeClassStructure: classStructure to: classPath    self        writeInDirectoryName: classPath        fileName: 'README'        extension: '.md'        visit: [:fileStream | self writeClassComment: classStructure on: fileStream ].    self        writeInDirectoryName: classPath        fileName: 'properties'        extension: '.json'        visit: [:fileStream | self writeClassStructure: classStructure on: fileStream ]! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'dkh 4/22/2012 13:24:15'!
                              writeExtensionClassStructure: classStructure to: classPath     self        writeInDirectoryName: classPath        fileName: 'properties'        extension: '.json'        visit: [:fileStream |  | properties |    		properties := Dictionary new.    		properties at: 'name' put: classStructure className.    		properties writeCypressJsonOn: fileStream ]! !
!CypressPackageWriter methodsFor: 'private' stamp: 'dkh 4/22/2012 13:24:15'!
         writeInDirectoryName: directoryNameOrPath fileName: fileName extension: ext visit: visitBlock    | directory |    directory := self directoryForDirectoryNamed: directoryNameOrPath.    directory        forceNewFileNamed: fileName , ext        do: [ :file |             file lineEndConvention: #'lf'.            visitBlock value: file ]! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'dkh 4/23/2012 23:38'!
                             writeMethodStructure: methodStructure to:methodPath    | filename |    filename := self fileNameForSelector: methodStructure selector.    self        writeInDirectoryName: methodPath        fileName: filename        extension: '.st'        visit: [:fileStream |		fileStream        		nextPutAll: methodStructure category;        		newLine;        		nextPutAll: methodStructure source withUnixLineEndings ]! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'dkh 4/22/2012 13:24:15'!
               writePackageStructure	self writePackageStructureClasses:  self packageStructure classes isClassExtension: false.	self writePackageStructureClasses:  self packageStructure extensions isClassExtension: true! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'dkh 4/22/2012 13:24:15'!
                               writePackageStructureClasses:  classStructures isClassExtension: isClassExtension    | classDirExtension |	    classDirExtension := isClassExtension		ifTrue: [ '.extension' ]		ifFalse: [ '.class' ].    classStructures        do: [ :classStructure |             | classPath instanceMethodPath classMethodPath |            classPath := classStructure className , classDirExtension , FileDirectory slash.	      isClassExtension			ifTrue: [ self writeExtensionClassStructure: classStructure to: classPath ]            	ifFalse: [ self writeClassStructure: classStructure to: classPath ].            instanceMethodPath := classPath , 'instance' , FileDirectory slash.            classStructure instanceMethods                do: [ :methodStructure |  self writeMethodStructure: methodStructure to: instanceMethodPath ].            classMethodPath := classPath , 'class' , FileDirectory slash.            classStructure classMethods                do: [ :methodStructure |  self writeMethodStructure: methodStructure to: classMethodPath ] ].! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'dkh 4/22/2012 13:24:15'!
                 writePropertiesFile    self        writeInDirectoryName: '.'        fileName: 'properties'        extension: '.json'        visit: [:fileStream | Dictionary new writeCypressJsonOn: fileStream ]! !
!CypressPackageWriter class methodsFor: 'as yet unclassified' stamp: 'dkh 4/22/2012 13:24:15'!
                      initializeSpecials    | map |    map := Dictionary new.    map        at: $+ put: 'plus';        at: $- put: 'minus';        at: $= put: 'equals';        at: $< put: 'less';        at: $> put: 'more';        at: $% put: 'percent';        at: $& put: 'and';        at: $| put: 'pipe';        at: $* put: 'star';        at: $/ put: 'slash';        at: $\ put: 'backslash';        at: $~ put: 'tilde';        at: $? put: 'wat';        at: $@ put: 'at'.    map keys do: [ :key | map at: (map at: key) put: key ].    ^ map! !
!CypressPackageWriter class methodsFor: 'as yet unclassified' stamp: 'dkh 4/22/2012 13:24:15'!
     specials    ^ specials ifNil: [ specials := self initializeSpecials ]! !
!CypressPackageWriter class methodsFor: 'instance creation' stamp: 'dkh 4/22/2012 13:24:15'!
                         writePackageStructure: aPackageStructure to: aPackagesDirectory	self new		packageStructure: aPackageStructure;		rootDirectory: aPackagesDirectory;		write! !
!CypressStructure methodsFor: 'initialization'!
              fromJs: jsObject

	self subclassResponsibility
! !
!CypressStructure methodsFor: 'initialization' stamp: 'dkh 4/23/2012 19:15'!
fromPackage: aCypressPackageDefinition

	| snapshot classMap classDefinitions classStructure |
	snapshot := aCypressPackageDefinition snapshot.
	name := aCypressPackageDefinition name, '.package'.
	properties := Dictionary new.
	classDefinitions := Set new.
	classMap := Dictionary new.
	snapshot definitions do: [:definition |  
			definition 
				classDefinition: [:classDefinition |  classDefinitions add: classDefinition ] 
				methodDefinition: [:methodDefinition | 
					(classMap 
						at: methodDefinition className 
						ifAbsent: [classMap at: methodDefinition className put: Set new]) 
							add: methodDefinition. ]].
	classDefinitions do: [:classDefinition | 
		classStructure := (CypressClassStructure fromClassDefinition: classDefinition)
			packageStructure: self.
		(classMap removeKey: classDefinition className ifAbsent: [#()]) do: [:methodDefinition | | methodStructure |
			methodStructure := (CypressMethodStructure fromMethodDefinition: methodDefinition)
				packageStructure: self;
				classStructure: classStructure.
			(methodDefinition
				instanceMethod: [:instanceMethod | classStructure instanceMethods ] 
				classMethod: [:classMethod | classStructure classMethods ])
					at: methodDefinition selector
					put: methodStructure ].
		self classes add: classStructure ].
	classMap keysAndValuesDo: [:className :methods |
		classStructure := (CypressClassStructure new name: className)
			packageStructure: self.
		methods do: [:methodDefinition | | methodStructure |
			methodStructure := (CypressMethodStructure fromMethodDefinition: methodDefinition)
				packageStructure: self;
				classStructure: classStructure.
			(methodDefinition
				instanceMethod: [:instanceMethod | classStructure instanceMethods ] 
				classMethod: [:classMethod | classStructure classMethods ])
					at: methodDefinition selector
					put: methodStructure ].
		self extensions add: classStructure ].
! !
!CypressStructure methodsFor: 'accessing'!
                       name

	^name
! !
!CypressStructure methodsFor: 'accessing'!
    name: aString 

	name := aString
! !
!CypressStructure methodsFor: 'accessing'!
                packageStructure
	^packageStructure
! !
!CypressStructure methodsFor: 'accessing'!
             packageStructure: aCypressPackageStructure
	packageStructure := aCypressPackageStructure
! !
!CypressStructure methodsFor: 'writing'!
                          path: aFSPath file: aFilename write: writeBlock

	| fs stream |
	fs := aFSPath fs.
	stream := fs createWriteStream: (aFSPath resolve: aFilename).
	writeBlock value: stream.
	stream end.
! !
!CypressStructure methodsFor: 'accessing'!
                       properties

	properties ifNil: [ properties := Dictionary new ].
	^properties
! !
!CypressStructure methodsFor: 'writing'!
     writeJsonOn: aStream

	self writeJsonOn: aStream indent: 0.
! !
!CypressStructure methodsFor: 'writing'!
                       writeJsonOn: aStream  indent: indent

	self subclassResponsibility
! !
!CypressStructure class methodsFor: 'instance creation'!
fromJs: jsObject

	^(self new) 
		fromJs: jsObject asCypressPropertyObject;
		yourself
! !
!Dictionary methodsFor: '*Cypress-Structure' stamp: 'dkh 4/23/2012 23:54'!
                          asCypressPropertyObject
    self associations do: [ :assoc | self at: assoc key put: assoc value asCypressPropertyObject ]! !
!Dictionary methodsFor: '*Cypress-Structure' stamp: 'dkh 4/23/2012 23:54'!
                       writeCypressJsonOn: aStream indent: startIndent
    | indent count |
    indent := startIndent.
    aStream
        nextPutAll: '{';
        newLine.
    count := 0.
    indent := indent + 1.
    (self keys sort: [ :a :b | a <= b ])
        do: [ :key | 
            | value |
            value := self at: key.
            count := count + 1.
            aStream tab: indent.
            key writeCypressJsonOn: aStream indent: indent.
            aStream nextPutAll: ' : '.
            value writeCypressJsonOn: aStream indent: indent.
            count < self size
                ifTrue: [ 
                    aStream
                        nextPutAll: ',';
                        newLine ] ].
    self size = 0
        ifTrue: [ aStream tab: indent ].
    aStream nextPutAll: ' }'! !
!Number methodsFor: '*Cypress-Structure'!
                              writeCypressJsonOn: aStream  indent: startIndent

	aStream 
		nextPutAll: self printString
! !
!Object methodsFor: '*Cypress-Structure'!
                       asCypressPropertyObject

	^self
! !
!String methodsFor: '*Cypress-Structure' stamp: 'dkh 4/23/2012 23:49'!
                     asCypressPropertyObject

	^self unescapePercents withLineEndings: String lfString
! !
!String methodsFor: '*Cypress-Structure' stamp: 'dkh 4/23/2012 23:47'!
   encodeForHTTP
	"change dangerous characters to their %XX form, for use in HTTP transactions"
	| encodedStream |
	encodedStream _ WriteStream on: (String new).
	
	1 to: self size do: [ :n | | c |
		c := self at: n.
		c isSafeForHTTP ifTrue: [ encodedStream nextPut: c ] ifFalse: [
			encodedStream nextPut: $%.
			encodedStream nextPut: (c asciiValue // 16) asHexDigit.
			encodedStream nextPut: (c asciiValue \\ 16) asHexDigit.
		]
	].
	^encodedStream contents.! !
!String methodsFor: '*Cypress-Structure' stamp: 'dkh 4/23/2012 23:48'!
        writeCypressJsonOn: aStream  indent: startIndent

	aStream 
		nextPutAll: '"';
		nextPutAll: (self withLineEndings: String lfString) encodeForHTTP;
		nextPutAll: '"'
! !

----End fileIn of /Volumes/CANON_DC/Cuis/CampSmalltalk-cuis-cypress-0640657/Cypress-Structure.pck----!

Smalltalk browseUndeclaredReferences !

'From Cuis 4.0 of 21 April 2012 [latest update: #1260] on 24 April 2012 at 3:30:21 pm'!

'Description Please enter a description for this package '!

!classDefinition: #CypressDefinition category: #'Cypress-Definitions'!
Object subclass: #CypressDefinition
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

Object subclass: #CypressDefinition
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

!classDefinition: 'CypressDefinition class' category: #'Cypress-Definitions'!
CypressDefinition class
	instanceVariableNames: ''!

CypressDefinition class
	instanceVariableNames: ''!

!classDefinition: #CypressClassDefinition category: #'Cypress-Definitions'!
CypressDefinition subclass: #CypressClassDefinition
	instanceVariableNames: 'name superclassName category comment instVarNames classInstVarNames'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

CypressDefinition subclass: #CypressClassDefinition
	instanceVariableNames: 'name superclassName category comment instVarNames classInstVarNames'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

!classDefinition: 'CypressClassDefinition class' category: #'Cypress-Definitions'!
CypressClassDefinition class
	instanceVariableNames: ''!

CypressClassDefinition class
	instanceVariableNames: ''!

!classDefinition: #CypressDefinitionIndex category: #'Cypress-Definitions'!
Object subclass: #CypressDefinitionIndex
	instanceVariableNames: 'definitionMap'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

Object subclass: #CypressDefinitionIndex
	instanceVariableNames: 'definitionMap'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

!classDefinition: 'CypressDefinitionIndex class' category: #'Cypress-Definitions'!
CypressDefinitionIndex class
	instanceVariableNames: ''!

CypressDefinitionIndex class
	instanceVariableNames: ''!

!classDefinition: #CypressDependencySorter category: #'Cypress-Definitions'!
Object subclass: #CypressDependencySorter
	instanceVariableNames: 'required provided orderedItems'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

Object subclass: #CypressDependencySorter
	instanceVariableNames: 'required provided orderedItems'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

!classDefinition: 'CypressDependencySorter class' category: #'Cypress-Definitions'!
CypressDependencySorter class
	instanceVariableNames: ''!

CypressDependencySorter class
	instanceVariableNames: ''!

!classDefinition: #CypressLoader category: #'Cypress-Definitions'!
Object subclass: #CypressLoader
	instanceVariableNames: 'additions removals unloadable provisions errors methodAdditions requirements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

Object subclass: #CypressLoader
	instanceVariableNames: 'additions removals unloadable provisions errors methodAdditions requirements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

!classDefinition: 'CypressLoader class' category: #'Cypress-Definitions'!
CypressLoader class
	instanceVariableNames: ''!

CypressLoader class
	instanceVariableNames: ''!

!classDefinition: #CypressMethodDefinition category: #'Cypress-Definitions'!
CypressDefinition subclass: #CypressMethodDefinition
	instanceVariableNames: 'classIsMeta source category selector className'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

CypressDefinition subclass: #CypressMethodDefinition
	instanceVariableNames: 'classIsMeta source category selector className'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

!classDefinition: 'CypressMethodDefinition class' category: #'Cypress-Definitions'!
CypressMethodDefinition class
	instanceVariableNames: ''!

CypressMethodDefinition class
	instanceVariableNames: ''!

!classDefinition: #CypressPackageDefinition category: #'Cypress-Definitions'!
Object subclass: #CypressPackageDefinition
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

Object subclass: #CypressPackageDefinition
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

!classDefinition: 'CypressPackageDefinition class' category: #'Cypress-Definitions'!
CypressPackageDefinition class
	instanceVariableNames: ''!

CypressPackageDefinition class
	instanceVariableNames: ''!

!classDefinition: #CypressPatch category: #'Cypress-Definitions'!
Object subclass: #CypressPatch
	instanceVariableNames: 'operations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

Object subclass: #CypressPatch
	instanceVariableNames: 'operations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

!classDefinition: 'CypressPatch class' category: #'Cypress-Definitions'!
CypressPatch class
	instanceVariableNames: ''!

CypressPatch class
	instanceVariableNames: ''!

!classDefinition: #CypressPatchOperation category: #'Cypress-Definitions'!
Object subclass: #CypressPatchOperation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

Object subclass: #CypressPatchOperation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

!classDefinition: 'CypressPatchOperation class' category: #'Cypress-Definitions'!
CypressPatchOperation class
	instanceVariableNames: ''!

CypressPatchOperation class
	instanceVariableNames: ''!

!classDefinition: #CypressAddition category: #'Cypress-Definitions'!
CypressPatchOperation subclass: #CypressAddition
	instanceVariableNames: 'definition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

CypressPatchOperation subclass: #CypressAddition
	instanceVariableNames: 'definition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

!classDefinition: 'CypressAddition class' category: #'Cypress-Definitions'!
CypressAddition class
	instanceVariableNames: ''!

CypressAddition class
	instanceVariableNames: ''!

!classDefinition: #CypressModification category: #'Cypress-Definitions'!
CypressPatchOperation subclass: #CypressModification
	instanceVariableNames: 'obsoletion modification'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

CypressPatchOperation subclass: #CypressModification
	instanceVariableNames: 'obsoletion modification'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

!classDefinition: 'CypressModification class' category: #'Cypress-Definitions'!
CypressModification class
	instanceVariableNames: ''!

CypressModification class
	instanceVariableNames: ''!

!classDefinition: #CypressRemoval category: #'Cypress-Definitions'!
CypressPatchOperation subclass: #CypressRemoval
	instanceVariableNames: 'definition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

CypressPatchOperation subclass: #CypressRemoval
	instanceVariableNames: 'definition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

!classDefinition: 'CypressRemoval class' category: #'Cypress-Definitions'!
CypressRemoval class
	instanceVariableNames: ''!

CypressRemoval class
	instanceVariableNames: ''!

!classDefinition: #CypressSnapshot category: #'Cypress-Definitions'!
Object subclass: #CypressSnapshot
	instanceVariableNames: 'definitions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

Object subclass: #CypressSnapshot
	instanceVariableNames: 'definitions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Definitions'!

!classDefinition: 'CypressSnapshot class' category: #'Cypress-Definitions'!
CypressSnapshot class
	instanceVariableNames: ''!

CypressSnapshot class
	instanceVariableNames: ''!
!Class methodsFor: '*Cypress-Definitions' stamp: 'dkh 4/23/2012 20:54'!
     asCypressClassDefinition
	^CypressClassDefinition
		name: self name
		superclassName: self superclass name
		category: self category 
		instVarNames: self instVarNames
		classInstVarNames: self class instVarNames
		comment: self comment
! !
!CompiledMethod methodsFor: '*Cypress-Definitions' stamp: 'dkh 4/23/2012 21:02'!
                              asCypressMethodDefinition

	^CypressMethodDefinition 
        	className: (self methodClass isMeta ifTrue: [ self methodClass theNonMetaClass ] ifFalse: [ self methodClass ]) name
		classIsMeta: self methodClass isMeta
		selector: self selector
		category: self category
		source: self getSource
! !
!CompiledMethod methodsFor: '*Cypress-Definitions' stamp: 'dkh 4/23/2012 21:01'!
   category

	^self methodClass organization categoryOfElement: self selector! !
!CypressAddition methodsFor: 'comparing'!
        = aPatchOperation
	^(super = aPatchOperation) and: [self definition = aPatchOperation definition]
! !
!CypressAddition methodsFor: 'applying'!
                 applyTo: aCypressLoader

	aCypressLoader applyAddition: self
! !
!CypressAddition methodsFor: 'accessing'!
                     definition

	^definition
! !
!CypressAddition methodsFor: 'initialization'!
                    definition: aDefinition

	definition := aDefinition
! !
!CypressAddition methodsFor: 'accessing' stamp: 'dkh 4/23/2012 23:22'!
 description
    ^ 'add: ' , self definition printString! !
!CypressAddition methodsFor: 'loading'!
                             loadClassDefinition

	self definition loadClassDefinition
! !
!CypressAddition methodsFor: 'loading'!
                          loadMethodDefinition
	self definition loadMethodDefinition
! !
!CypressAddition methodsFor: 'loading'!
                         postLoadDefinition
	self definition postLoadOver: nil
! !
!CypressAddition methodsFor: 'printing' stamp: 'dkh 4/23/2012 20:24'!
printString

	| str |
	str := WriteStream on: String new.
	str 
		nextPutAll: super printString;
		nextPutAll: ' (';
		nextPutAll: self description;
		nextPutAll: ')'.
	^str contents
! !
!CypressAddition methodsFor: 'dependency'!
                          provisions
	"Answer list of global names defined by this definition"

	^self definition provisions
! !
!CypressAddition methodsFor: 'dependency'!
              requirements
	"Answer list of global names required by this definition"

	^self definition requirements
! !
!CypressAddition class methodsFor: 'instance creation'!
                            of: aDefinition
	^ self new definition: aDefinition
! !
!CypressClassDefinition methodsFor: 'comparing'!
                       = aDefinition
	^(super = aDefinition)
		and: [superclassName = aDefinition superclassName
		and: [category = aDefinition category
		and: [instVarNames = aDefinition instVarNames
		and: [classInstVarNames = aDefinition classInstVarNames
		and: [comment = aDefinition comment]]]]]
! !
!CypressClassDefinition methodsFor: 'loading'!
                      actualClass

	^Smalltalk current at: self name
! !
!CypressClassDefinition methodsFor: 'converting'!
                           asCypressClassDefinition

	^self
! !
!CypressClassDefinition methodsFor: 'accessing'!
          category

	^category
! !
!CypressClassDefinition methodsFor: 'visiting'!
                       classDefinition: classBlock methodDefinition: methodBlock

	classBlock value: self
! !
!CypressClassDefinition methodsFor: 'accessing'!
                        classInstVarNames

	^classInstVarNames
! !
!CypressClassDefinition methodsFor: 'accessing'!
    className

	^self name
! !
!CypressClassDefinition methodsFor: 'accessing'!
                    comment

	^comment
! !
!CypressClassDefinition methodsFor: 'loading'!
                          createClass

	| superClass |
	superClass := Smalltalk current at: self superclassName.
	^ClassBuilder new
		superclass: superClass 
		subclass: self name
		instanceVariableNames: (self stringForVariables: self instVarNames)
		classVariableNames: '' poolDictionaries: '' category: self category
! !
!CypressClassDefinition methodsFor: 'accessing'!
     description

	^ Array with: name
! !
!CypressClassDefinition methodsFor: 'comparing' stamp: 'dkh 4/23/2012 21:30'!
             hash
    | hash |
    hash := String stringHash: name initialHash: 0.
    hash := String stringHash: superclassName initialHash: hash.
    hash := String stringHash: (category ifNil: [ '' ]) initialHash: hash.
    instVarNames , classInstVarNames do: [ :vName | hash := String stringHash: vName initialHash: hash ].
    ^ hash! !
!CypressClassDefinition methodsFor: 'accessing'!
     instVarNames

	^instVarNames
! !
!CypressClassDefinition methodsFor: 'loading'!
                loadClassDefinition

	 | cls |
	cls := self createClass.
	cls class instanceVariableNames: (self stringForVariables: self classInstVarNames).
	self comment notEmpty ifTrue: [ cls comment: self comment ]
! !
!CypressClassDefinition methodsFor: 'accessing'!
name

	^name
! !
!CypressClassDefinition methodsFor: 'initialization'!
                         name: aClassName superclassName: aSuperclassName category: aCategory instVarNames: anInstanceVariableNames classInstVarNames: aClassInstanceVariableNames comment: aComment

	name := aClassName.
	superclassName := aSuperclassName.
	category := aCategory.
	instVarNames := anInstanceVariableNames.
	classInstVarNames := aClassInstanceVariableNames.
	comment := aComment
! !
!CypressClassDefinition methodsFor: 'printString' stamp: 'dkh 4/23/2012 20:24'!
                            printString

	| str |
	str := WriteStream on: String new.
	str 
		nextPutAll: super printString;
		nextPutAll: ' (';
		nextPutAll: self name;
		nextPutAll: ')'.
	^str contents
! !
!CypressClassDefinition methodsFor: 'dependency'!
                          provisions
	"Answer list of global names defined by this definition"

	^{ self name }
! !
!CypressClassDefinition methodsFor: 'dependency'!
                    requirements
	"Answer list of global names required by this definition"

	^{self name}
! !
!CypressClassDefinition methodsFor: 'printString'!
                  stringForVariables: aCollectionOfVariableNames
	^ String streamContents:
		[:stream |
		aCollectionOfVariableNames
			do: [:ea | stream nextPutAll: ea]
			separatedBy: [stream space]]
! !
!CypressClassDefinition methodsFor: 'accessing'!
                   superclassName

	^superclassName
! !
!CypressClassDefinition methodsFor: 'loading'!
            unloadDefinition

	Smalltalk current removeClass: self actualClass.
! !
!CypressClassDefinition class methodsFor: 'instance creation'!
                         name: aClassName 
superclassName: aSuperclassName
category: aCategory
instVarNames: anInstanceVariableNames
classInstVarNames: aClassInstanceVariableNames
comment: aComment

	^(self new) 
		name: aClassName 
		superclassName: aSuperclassName
		category: aCategory
		instVarNames: anInstanceVariableNames
		classInstVarNames: aClassInstanceVariableNames
		comment: aComment
! !
!CypressDefinition methodsFor: 'comparing'!
                           = aDefinition
	^(aDefinition isKindOf: CypressDefinition) and: [self isRevisionOf: aDefinition]
! !
!CypressDefinition methodsFor: 'loading'!
                  actualClass

	self subclassResponsibility
! !
!CypressDefinition methodsFor: 'visiting'!
       classDefinition: classBlock methodDefinition: methodBlock
	"default is noop"
! !
!CypressDefinition methodsFor: 'accessing'!
   description
	self subclassResponsibility
! !
!CypressDefinition methodsFor: 'testing'!
         isRevisionOf: aDefinition
	^ (aDefinition isKindOf: CypressDefinition) and: [aDefinition description = self description]
! !
!CypressDefinition methodsFor: 'testing'!
                         isSameRevisionAs: aDefinition
	^ self = aDefinition
! !
!CypressDefinition methodsFor: 'loading'!
                              loadClassDefinition
	"default is to do nothing"
! !
!CypressDefinition methodsFor: 'loading'!
  loadMethodDefinition
	"default is to do nothing"
! !
!CypressDefinition methodsFor: 'loading'!
 postLoad
	"noop"
! !
!CypressDefinition methodsFor: 'loading'!
 postLoadOver: aDefinition

	self postLoad
! !
!CypressDefinition methodsFor: 'dependency'!
     provisions
	"Answer list of global names defined by this definition"

	^#()
! !
!CypressDefinition methodsFor: 'dependency'!
   requirements
	"Answer list of global names required by this definition"

	^#()
! !
!CypressDefinition methodsFor: 'loading'!
   unloadDefinition

	self subclassResponsibility
! !
!CypressDefinitionIndex methodsFor: 'adding'!
                               add: aDefinition
	^ self definitionMap at: aDefinition description put: aDefinition
! !
!CypressDefinitionIndex methodsFor: 'adding'!
                          addAll: aCollection
	aCollection do: [:ea | self add: ea]
! !
!CypressDefinitionIndex methodsFor: 'querying'!
                  definitionLike: aDefinition ifPresent: foundBlock ifAbsent: errorBlock
	| definition |
	definition := self definitionMap at: aDefinition description ifAbsent: [].
	^ definition
		ifNil: errorBlock
		ifNotNil: [foundBlock value: definition]
! !
!CypressDefinitionIndex methodsFor: 'accessing'!
                           definitionMap
	definitionMap ifNil: [ definitionMap := Dictionary new ].
	^ definitionMap
! !
!CypressDefinitionIndex methodsFor: 'accessing'!
                 definitions
	^self definitionMap values
! !
!CypressDefinitionIndex methodsFor: 'removing'!
    remove: aDefinition
	self definitionMap removeKey: aDefinition description ifAbsent: []
! !
!CypressDefinitionIndex class methodsFor: 'instance creation'!
     definitions: aCollection
	^ self new addAll: aCollection
! !
!CypressDependencySorter methodsFor: 'building'!
                  add: aPatchOperation
	| requirements |
	requirements := self unresolvedRequirementsFor: aPatchOperation.
	requirements isEmpty
		ifTrue: [self addToOrder: aPatchOperation]
		ifFalse: [self addRequirements: requirements for: aPatchOperation].
	^ aPatchOperation
! !
!CypressDependencySorter methodsFor: 'building'!
      addAll: aCollection
	aCollection do: [:aPatchOperation | self add: aPatchOperation ]
! !
!CypressDependencySorter methodsFor: 'private'!
                       addExternalProvisions: aCollection
	(aCollection intersection: self externalRequirements)
		do: [:globalName | self addProvision: globalName]
! !
!CypressDependencySorter methodsFor: 'private'!
                              addProvision: aGlobalName
	| newlySatisfied |
	self provided add: aGlobalName.
	newlySatisfied := self required removeKey: aGlobalName ifAbsent: [#()].
	self addAll: newlySatisfied.
! !
!CypressDependencySorter methodsFor: 'private'!
                      addRequirement: globalName for: aPatchOperation
	(self itemsRequiring: globalName) add: aPatchOperation
! !
!CypressDependencySorter methodsFor: 'private'!
    addRequirements: aCollection for: aPatchOperation
	aCollection do: [:globalName | self addRequirement: globalName for: aPatchOperation]
! !
!CypressDependencySorter methodsFor: 'private'!
    addToOrder: aPatchOperation
	self orderedItems add: aPatchOperation.
	aPatchOperation provisions do: [:globalName | self addProvision: globalName ].
! !
!CypressDependencySorter methodsFor: 'accessing'!
                     externalRequirements
	| unloaded providedByUnloaded |
	unloaded := self itemsWithMissingRequirements.
	providedByUnloaded := (unloaded gather: [:e | e provisions]) asSet.
	^ self required keys reject: [:globalName | providedByUnloaded includes: globalName ]
! !
!CypressDependencySorter methodsFor: 'private'!
          itemsRequiring: globalName
	^ self required at: globalName ifAbsentPut: [Set new]
! !
!CypressDependencySorter methodsFor: 'accessing'!
                        itemsWithMissingRequirements
	| patchOperations |
	patchOperations := Set new.
	self required values do: [:aSetOfPatchOperations | patchOperations addAll: aSetOfPatchOperations ].
	^ patchOperations
! !
!CypressDependencySorter methodsFor: 'accessing'!
   orderedItems
	"ordered list of patch operations"

	orderedItems ifNil: [ orderedItems := OrderedCollection new ].
	^orderedItems
! !
!CypressDependencySorter methodsFor: 'accessing'!
         provided
	"set of global names provided by definitions already loaded"

	provided ifNil: [ provided := Set new ].
	^provided
! !
!CypressDependencySorter methodsFor: 'accessing'!
             required
	"dictionary of required global name mapped to list of definitions that require the global"

	required ifNil: [ required := Dictionary new ].
	^required
! !
!CypressDependencySorter methodsFor: 'private'!
          unresolvedRequirementsFor: aPatchOperation
	"Answer a list of global names that are required by <aPatchOperation>, but not 
	 provided by patchOperations that have already been processed"

	^ aPatchOperation requirements difference: self provided
! !
!CypressLoader methodsFor: 'accessing'!
                             additions

	additions ifNil: [ additions := OrderedCollection new ].
	^additions
! !
!CypressLoader methodsFor: 'loading'!
     analyze

	self 
		analyzeAdditions;
		analyzeRemovals
! !
!CypressLoader methodsFor: 'loading'!
analyzeAdditions

	| sorter |
	sorter := CypressDependencySorter new 
		addAll: self additions;
		addExternalProvisions: self provisions;
		yourself.
	additions := sorter orderedItems.
	requirements := sorter externalRequirements.
	unloadable := sorter itemsWithMissingRequirements.
! !
!CypressLoader methodsFor: 'loading'!
                           analyzeRemovals

	| sorter |
	sorter := CypressDependencySorter new 
		addAll: self removals;
		yourself.
	removals := sorter orderedItems reversed.
! !
!CypressLoader methodsFor: 'applying'!
applyAddition: aCypressPatchOperation

	self additions add: aCypressPatchOperation
! !
!CypressLoader methodsFor: 'applying'!
  applyModification: aCypressPatchOperation

	self additions add: aCypressPatchOperation
! !
!CypressLoader methodsFor: 'applying'!
                              applyRemoval: aCypressPatchOperation

	self removals add: aCypressPatchOperation
! !
!CypressLoader methodsFor: 'loading' stamp: 'dkh 4/23/2012 20:26'!
        basicLoad
	errors := OrderedCollection new.
	self additions do: [:ea | self loadClassDefinition: ea ]. "load class definitions first"
	self additions do: [:ea | self loadMethodDefinition: ea ] . "load method definitions now"
	self removals do: [:ea | self unloadDefinition: ea ]. "now we can remove things"
	self errors do: [:ea | ea addMethodAdditionTo: methodAdditions]. "not sure about methodAddtions...yet"
	self methodAdditions do: [:ea | self loadMethodAddition: ea ]. "ditto"
	self additions do: [:ea | self postLoad: ea ]. "this is where the obsoletion is taken into account ..."
! !
!CypressLoader methodsFor: 'accessing'!
        errors
	errors ifNil: [ errors := OrderedCollection new ].
	^errors
! !
!CypressLoader methodsFor: 'error handling' stamp: 'dkh 4/24/2012 15:30'!
              handleErrorFor: aPatchOperation during: aBlock
	aBlock on: Error do: [:ex | self errors add: aPatchOperation ].
! !
!CypressLoader methodsFor: 'loading'!
      load

	self analyze.
	self unloadable isEmpty ifFalse: [self unloadableDefinitionsError].
	self basicLoad
! !
!CypressLoader methodsFor: 'operations'!
         loadClassDefinition: aPatchOperation

	self 
		handleErrorFor: aPatchOperation 
		during: [ aPatchOperation loadClassDefinition ]
! !
!CypressLoader methodsFor: 'operations'!
                 loadMethodDefinition: aPatchOperation
	
	self 
		handleErrorFor: aPatchOperation 
		during: [ aPatchOperation loadMethodDefinition ]
! !
!CypressLoader methodsFor: 'accessing'!
               methodAdditions

	^#()
! !
!CypressLoader methodsFor: 'operations'!
                            postLoad: aPatchOperation
	aPatchOperation postLoadDefinition
! !
!CypressLoader methodsFor: 'accessing' stamp: 'dkh 4/23/2012 21:03'!
                         provisions
	^ provisions ifNil: [provisions := (Smalltalk classes collect: [:cl | cl name]) asSet ]
! !
!CypressLoader methodsFor: 'accessing'!
                removals

	removals ifNil: [ removals := OrderedCollection new ].
	^removals
! !
!CypressLoader methodsFor: 'operations'!
      unloadDefinition: aPatchOperation
	
	self 
		handleErrorFor: aPatchOperation 
		during: [ aPatchOperation unloadDefinition ]
! !
!CypressLoader methodsFor: 'accessing'!
                       unloadable

	unloadable ifNil: [ unloadable := OrderedCollection new ].
	^unloadable
! !
!CypressLoader methodsFor: 'loading'!
 updatePackage: aPackage withSnapshot: aSnapshot
	|  patch snapshot |
	snapshot := aPackage snapshot.
	patch := aSnapshot patchRelativeToBase: snapshot.
	patch applyTo: self.
	snapshot definitions do: [:ea | self provisions addAll: ea provisions]
! !
!CypressLoader class methodsFor: 'loading'!
                          updatePackage: aPackage withSnapshot: aSnapshot
	self new
		updatePackage: aPackage withSnapshot: aSnapshot;
		load
! !
!CypressMethodDefinition methodsFor: 'comparing'!
                      = aDefinition
    ^ super = aDefinition
        and: [ aDefinition source = self source
                and: [ aDefinition category = self category ] ]
! !
!CypressMethodDefinition methodsFor: 'loading'!
                    actualClass

	| cls |
	cls := self theNonMetaClass.
	^self classIsMeta
		ifTrue: [ cls class ]
		ifFalse: [ cls  ].
! !
!CypressMethodDefinition methodsFor: 'converting'!
                     asCypressMethodDefinition

	^self
! !
!CypressMethodDefinition methodsFor: 'accessing'!
        category

	^category
! !
!CypressMethodDefinition methodsFor: 'visiting'!
                      classDefinition: classBlock methodDefinition: methodBlock

	methodBlock value: self
! !
!CypressMethodDefinition methodsFor: 'accessing'!
                      classIsMeta

	^classIsMeta
! !
!CypressMethodDefinition methodsFor: 'accessing'!
               className

	^className
! !
!CypressMethodDefinition methodsFor: 'initialization' stamp: 'dkh 4/24/2012 00:27'!
                 className: aName classIsMeta: isMetaclass selector: aSelector category: aCategory source: aSource

	className := aName asSymbol.
	classIsMeta := isMetaclass.
	selector := aSelector asSymbol.
	category := aCategory asSymbol.
	source := aSource withLineEndings: String lfString.
! !
!CypressMethodDefinition methodsFor: 'accessing'!
                     description
	^ Array	
		with: className
		with: selector
		with: classIsMeta
! !
!CypressMethodDefinition methodsFor: 'comparing' stamp: 'dkh 4/23/2012 23:20'!
hash
    | hash |
    hash := String stringHash: classIsMeta asString initialHash: 0.
    hash := String stringHash: source initialHash: hash.
    hash := String stringHash: category initialHash: hash.
    hash := String stringHash: className initialHash: hash.
    ^ hash! !
!CypressMethodDefinition methodsFor: 'visiting'!
                           instanceMethod: instanceBlock classMethod: classBlock

	^(self classIsMeta
		ifTrue: [ classBlock ]
		ifFalse: [ instanceBlock ]) value: self
! !
!CypressMethodDefinition methodsFor: 'testing'!
                              isInitializer
	^ self selector = 'initialize' and: [self classIsMeta]
! !
!CypressMethodDefinition methodsFor: 'loading' stamp: 'dkh 4/24/2012 15:27'!
         loadMethodDefinition

	self actualClass
		compile: self source
		classified: self category
! !
!CypressMethodDefinition methodsFor: 'loading'!
                 postLoadOver: aDefinition

	super postLoadOver: aDefinition.
	(self isInitializer
		and: [ aDefinition isNil or: [ self source ~= aDefinition source ]]) 
			ifTrue: [ self theNonMetaClass initialize ].
! !
!CypressMethodDefinition methodsFor: 'printing' stamp: 'dkh 4/23/2012 20:24'!
    printString

	| str |
	str := WriteStream on: String new.
	str 
		nextPutAll: super printString;
		nextPutAll: ' (';
		nextPutAll: self className.
	self classIsMeta
		ifTrue: [ str nextPutAll: ' class' ].
	str 
		nextPutAll: '>>';
		nextPutAll: self selector;
		nextPutAll: ')'.
	^str contents
! !
!CypressMethodDefinition methodsFor: 'dependency'!
   requirements
	"Answer list of global names required by this definition"

	^{self className}
! !
!CypressMethodDefinition methodsFor: 'accessing'!
              selector

	^selector
! !
!CypressMethodDefinition methodsFor: 'accessing'!
                     source

	^source
! !
!CypressMethodDefinition methodsFor: 'loading' stamp: 'dkh 4/24/2012 15:26'!
                              theNonMetaClass
	^Smalltalk at: self className
! !
!CypressMethodDefinition methodsFor: 'loading' stamp: 'dkh 4/24/2012 15:28'!
unloadDefinition

	self actualClass removeSelector: self selector asSymbol
! !
!CypressMethodDefinition class methodsFor: 'instance creation'!
                 className: aName
classIsMeta: isMetaclass
selector: aSelector
category: aCategory
source: aSource

	^(self new)
		className: aName
		classIsMeta: isMetaclass
		selector: aSelector
		category: aCategory
		source: aSource
! !
!CypressModification methodsFor: 'initialization'!
             = aPatchOperation
	^(super = aPatchOperation) and: [self obsoletion = aPatchOperation obsoletion and: [ self modification = aPatchOperation modification]]
! !
!CypressModification methodsFor: 'applying'!
                    applyTo: aCypressLoader

	aCypressLoader applyModification: self
! !
!CypressModification methodsFor: 'initialization'!
        base: base target: target

	obsoletion := base.
	modification := target.
! !
!CypressModification methodsFor: 'accessing' stamp: 'dkh 4/23/2012 23:22'!
        description
    ^ 'modify from: ' , self obsoletion printString , ' to: ' , self modification printString! !
!CypressModification methodsFor: 'loading'!
       loadClassDefinition

	self modification loadClassDefinition
! !
!CypressModification methodsFor: 'loading'!
                    loadMethodDefinition
	self modification loadMethodDefinition
! !
!CypressModification methodsFor: 'accessing'!
                 modification

	^modification
! !
!CypressModification methodsFor: 'accessing'!
                 obsoletion

	^obsoletion
! !
!CypressModification methodsFor: 'loading'!
                       postLoadDefinition
	self modification postLoadOver: self obsoletion
! !
!CypressModification methodsFor: 'printing' stamp: 'dkh 4/23/2012 20:25'!
              printString

	| str |
	str := WriteStream on: String new.
	str 
		nextPutAll: super printString;
		nextPutAll: ' (';
		nextPutAll: self description;
		nextPutAll: ')'.
	^str contents
! !
!CypressModification methodsFor: 'dependency'!
                      provisions
	"Answer list of global names defined by this definition"

	^self modification provisions
! !
!CypressModification methodsFor: 'dependency'!
        requirements
	"Answer list of global names required by this definition"

	^self modification requirements
! !
!CypressModification class methodsFor: 'instance creation'!
                      of: base to: target
	^ self new base: base target: target
! !
!CypressPackageDefinition methodsFor: 'comparing'!
               = other
	^ other species = self species and: [other name sameAs: name]
! !
!CypressPackageDefinition methodsFor: 'accessing'!
  name
	^ name
! !
!CypressPackageDefinition methodsFor: 'accessing'!
                            name: aString
	name := aString
! !
!CypressPackageDefinition methodsFor: 'printing'!
           printString
	^super printString, '(', name, ')'
! !
!CypressPackageDefinition methodsFor: 'snapshotting' stamp: 'dkh 4/23/2012 20:53'!
                         snapshot
    | package definitions map classMap |
    package := CodePackage named: self name.
    definitions := OrderedCollection new.
    (ChangeSet superclassOrder: package classes)
        do: [ :cls | 
            definitions add: cls asCypressClassDefinition.
            (cls methodDictionary values sorted: [ :a :b | a selector <= b selector ])
                do: [ :method | 
                    (method category at: 1) = $*
                        ifFalse: [ definitions add: method asCypressMethodDefinition ] ].
            (cls class methodDictionary values sorted: [ :a :b | a selector <= b selector ])
                do: [ :method | 
                    (method category at: 1) = $*
                        ifFalse: [ definitions add: method asCypressMethodDefinition ] ] ].
    classMap := Dictionary new.
    Smalltalk allClasses
        do: [ :each | 
            {each.
            (each class)}
                do: [ :aClass | 
                    | defs |
                    defs := OrderedCollection new.
                    map := Dictionary new.
                    aClass organization categories
                        do: [ :category | 
                            | methods |
                            methods := aClass organization listAtCategoryNamed: category.
                            (category asLowercase beginsWith: '*' , self name asLowercase)
                                ifTrue: [ map at: category put: methods ] ].
                    (map keys sorted: [ :a :b | a <= b ])
                        do: [ :category | 
                            ((map at: category) sorted: [ :a :b | a selector <= b selector ])
                                do: [ :method | defs add: (aClass compiledMethodAt: method) asCypressMethodDefinition ] ].
                    defs notEmpty
                        ifTrue: [ classMap at: each put: defs ] ] ].
    (ChangeSet superclassOrder: classMap keys) do: [ :aClass | definitions addAll: (classMap at: aClass) ].
    ^ CypressSnapshot definitions: definitions! !
!CypressPatch methodsFor: 'applying'!
                             applyTo: aCypressLoader
	operations do: [:ea | ea applyTo: aCypressLoader].
! !
!CypressPatch methodsFor: 'initialization'!
    fromBase: baseSnapshot toTarget: targetSnapshot
	| base target |	
	operations := OrderedCollection new.
	base := CypressDefinitionIndex definitions: baseSnapshot definitions.
	target := CypressDefinitionIndex definitions: targetSnapshot definitions.
	
	target definitions do:
		[:t |
		base
			definitionLike: t
			ifPresent: [:b | (b isSameRevisionAs: t) ifFalse: [operations add: (CypressModification of: b to: t)]]
			ifAbsent: [operations add: (CypressAddition of: t)]].
		
	base definitions do:
		[:b |
		target
			definitionLike: b
			ifPresent: [:t | ]
			ifAbsent: [operations add: (CypressRemoval of: b)]]
! !
!CypressPatch methodsFor: 'accessing'!
              operations

	^operations
! !
!CypressPatch class methodsFor: 'instance creation'!
              fromBase: baseSnapshot toTarget: targetSnapshot
	^ (self new)
		fromBase: baseSnapshot
		toTarget: targetSnapshot
! !
!CypressPatchOperation methodsFor: 'comparing'!
                          = aPatchOperation
	^aPatchOperation isKindOf: self class
! !
!CypressPatchOperation methodsFor: 'applying'!
                    applyTo: aCypressLoader

	self subclassResponsibility
! !
!CypressPatchOperation methodsFor: 'accessing'!
                      description

	self subclassResponsibility
! !
!CypressPatchOperation methodsFor: 'comparing' stamp: 'dkh 4/23/2012 23:21'!
     hash
    ^ self description hash! !
!CypressPatchOperation methodsFor: 'loading'!
              loadClassDefinition

	self subclassResponsibility
! !
!CypressPatchOperation methodsFor: 'loading'!
                            loadMethodDefinition
	self subclassResponsibility
! !
!CypressPatchOperation methodsFor: 'loading'!
                            postLoadDefinition
	self subclassResponsibility
! !
!CypressPatchOperation methodsFor: 'dependency'!
                           provisions
	"Answer list of global names defined by this definition"

	self subclassResponsibility
! !
!CypressPatchOperation methodsFor: 'dependency'!
        requirements
	"Answer list of global names required by this definition"

	self subclassResponsibility
! !
!CypressPatchOperation methodsFor: 'loading'!
        unloadDefinition

	self error: 'inappropriate to send #unloadDefinition to an addition or modification operation'
! !
!CypressRemoval methodsFor: 'comparing'!
 = aPatchOperation
	^(super = aPatchOperation) and: [self definition = aPatchOperation definition]
! !
!CypressRemoval methodsFor: 'applying'!
                  applyTo: aCypressLoader

	aCypressLoader applyRemoval: self
! !
!CypressRemoval methodsFor: 'accessing'!
                       definition

	^definition
! !
!CypressRemoval methodsFor: 'initialization'!
                     definition: aDefinition

	definition := aDefinition
! !
!CypressRemoval methodsFor: 'accessing' stamp: 'dkh 4/23/2012 23:23'!
  description

	^'remove: ', self definition printString
! !
!CypressRemoval methodsFor: 'loading'!
                              loadClassDefinition
	
	self error: 'inappropriate to send #loadClassDefinition to a removal operation'
! !
!CypressRemoval methodsFor: 'loading'!
              loadMethodDefinition
	
	self error: 'inappropriate to send #loadMethodDefinition to a removal operation'
! !
!CypressRemoval methodsFor: 'loading'!
            postLoadDefinition
	
	self error: 'inappropriate to send #postLoadDefinition to a removal operation'
! !
!CypressRemoval methodsFor: 'printing' stamp: 'dkh 4/23/2012 20:25'!
                  printString

	| str |
	str := WriteStream on: String new.
	str 
		nextPutAll: super printString;
		nextPutAll: ' (';
		nextPutAll: self description;
		nextPutAll: ')'.
	^str contents
! !
!CypressRemoval methodsFor: 'dependency'!
                           provisions
	"Answer list of global names defined by this definition"

	^#()
! !
!CypressRemoval methodsFor: 'dependency'!
      requirements
	"Answer list of global names required by this definition"

	^#()
! !
!CypressRemoval methodsFor: 'loading'!
      unloadDefinition

	self definition unloadDefinition
! !
!CypressRemoval class methodsFor: 'instance creation'!
                 of: aDefinition
	^ self new definition: aDefinition
! !
!CypressSnapshot methodsFor: 'comparing'!
                              = other
	^ definitions asArray = other definitions asArray
! !
!CypressSnapshot methodsFor: 'enumerating'!
                     classDefinitions: classBlock methodDefinitions: methodBlock

	self definitions do: [:definition |
		definition classDefinition: classBlock methodDefinition: methodBlock]
! !
!CypressSnapshot methodsFor: 'accessing'!
        definitions

	^definitions
! !
!CypressSnapshot methodsFor: 'accessing'!
                       definitions: aDefinitions

	definitions := aDefinitions
! !
!CypressSnapshot methodsFor: 'patching'!
                           patchRelativeToBase: aSnapshot
	^ CypressPatch fromBase: aSnapshot toTarget: self
! !
!CypressSnapshot methodsFor: 'loading'!
  updatePackage: aPackage
	CypressLoader updatePackage: aPackage withSnapshot: self
! !
!CypressSnapshot class methodsFor: 'instance creation'!
                  definitions: aDefinitions

	^(self new) definitions: aDefinitions
! !
!SystemDictionary methodsFor: '*Cypress-Definitions' stamp: 'dkh 4/23/2012 21:06'!
       classes

	^self classNames collect: [:each | self at: each ]! !

----End fileIn of /Volumes/CANON_DC/Cuis/CampSmalltalk-cuis-cypress-0640657/Cypress-Definitions.pck----!

Smalltalk browseUndeclaredReferences !

'From Cuis 4.0 of 21 April 2012 [latest update: #1260] on 24 April 2012 at 3:27:33 pm'!

'Description Please enter a description for this package '!

!classDefinition: #CypressAbstractTest category: #'Cypress-Tests'!
TestCase subclass: #CypressAbstractTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Tests'!

TestCase subclass: #CypressAbstractTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Tests'!

!classDefinition: 'CypressAbstractTest class' category: #'Cypress-Tests'!
CypressAbstractTest class
	instanceVariableNames: ''!

CypressAbstractTest class
	instanceVariableNames: ''!

!classDefinition: #CypressDefinitionTest category: #'Cypress-Tests'!
CypressAbstractTest subclass: #CypressDefinitionTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Tests'!

CypressAbstractTest subclass: #CypressDefinitionTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Tests'!

!classDefinition: 'CypressDefinitionTest class' category: #'Cypress-Tests'!
CypressDefinitionTest class
	instanceVariableNames: ''!

CypressDefinitionTest class
	instanceVariableNames: ''!

!classDefinition: #CypressLoaderTest category: #'Cypress-Tests'!
CypressAbstractTest subclass: #CypressLoaderTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Tests'!

CypressAbstractTest subclass: #CypressLoaderTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Tests'!

!classDefinition: 'CypressLoaderTest class' category: #'Cypress-Tests'!
CypressLoaderTest class
	instanceVariableNames: ''!

CypressLoaderTest class
	instanceVariableNames: ''!

!classDefinition: #CypressPatchTest category: #'Cypress-Tests'!
CypressAbstractTest subclass: #CypressPatchTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Tests'!

CypressAbstractTest subclass: #CypressPatchTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Tests'!

!classDefinition: 'CypressPatchTest class' category: #'Cypress-Tests'!
CypressPatchTest class
	instanceVariableNames: ''!

CypressPatchTest class
	instanceVariableNames: ''!

!classDefinition: #CypressSnapshotTest category: #'Cypress-Tests'!
CypressAbstractTest subclass: #CypressSnapshotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Tests'!

CypressAbstractTest subclass: #CypressSnapshotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Tests'!

!classDefinition: 'CypressSnapshotTest class' category: #'Cypress-Tests'!
CypressSnapshotTest class
	instanceVariableNames: ''!

CypressSnapshotTest class
	instanceVariableNames: ''!

!classDefinition: #CypressStructureTest category: #'Cypress-Tests'!
CypressAbstractTest subclass: #CypressStructureTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Tests'!

CypressAbstractTest subclass: #CypressStructureTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Tests'!

!classDefinition: 'CypressStructureTest class' category: #'Cypress-Tests'!
CypressStructureTest class
	instanceVariableNames: ''!

CypressStructureTest class
	instanceVariableNames: ''!
!CypressAbstractTest methodsFor: 'private' stamp: 'dkh 4/24/2012 01:03'!
   baseDefinitions
	| className |
	className := 'CypressMockBasic'.
	^{
		(CypressClassDefinition
        		name: className
       		 	superclassName: 'Object'
       			category: 'Cypress-Mocks'
                       	instVarNames: #('name')
			classInstVarNames: #('current')
        		comment:  'This mock contains basic class and instance method selectors').
   	 	(CypressMethodDefinition
          		className: className
        		classIsMeta: false
        		selector: 'extra'
        		category: 'accessing'
        		source:'extra
	"extra method"').
   	 	(CypressMethodDefinition
          		className: className
        		classIsMeta: false
        		selector: 'initialize'
        		category: 'initialization'
        		source:'initialize
	super initialize.
	self name: ''Unknown''').
   	 	(CypressMethodDefinition
          		className: className
        		classIsMeta: false
        		selector: 'name'
        		category: 'accessing'
        		source:'name
	^name').
   	 	(CypressMethodDefinition
          		className: className
        		classIsMeta: false
        		selector: 'name:'
        		category: 'accessing'
        		source:'name: aString
	name := aString').
   	 	(CypressMethodDefinition
          		className: className
        		classIsMeta: true
        		selector: 'current'
        		category: 'accessing'
        		source:'current
	^current').
   	 	(CypressMethodDefinition
          		className: className
        		classIsMeta: true
        		selector: 'current:'
        		category: 'accessing'
        		source:'current: anObject
	current := anObject').
   	 	(CypressMethodDefinition
          		className: className
        		classIsMeta: true
        		selector: 'initialize'
        		category: 'initialization'
        		source:'initialize
	self current: self new').
   	 	(CypressMethodDefinition
          		className: 'Object'
        		classIsMeta: false
        		selector: 'isCypressMockBasic'
        		category: '*Cypress-Mocks'
        		source:'isCypressMockBasic
	^false')
	}
! !
!CypressAbstractTest methodsFor: 'private' stamp: 'dkh 4/24/2012 00:45'!
    basePackageStructureJson
    ^ '{
	"name" : "Cypress-Mocks.package",
	"contents" : [
		{
			"name" : "CypressMockBasic.class",
			"instance" : [
				{
					"name" : "extra.st",
					"contents" : "accessing%0Aextra%0A%09%22extra%20method%22"
				 },
				{
					"name" : "initialize.st",
					"contents" : "initialization%0Ainitialize%0A%09super%20initialize.%0A%09self%20name%3A%20%27Unknown%27"
				 },
				{
					"name" : "name.st",
					"contents" : "accessing%0Aname%0A%09%5Ename"
				 },
				{
					"name" : "name..st",
					"contents" : "accessing%0Aname%3A%20aString%0A%09name%20%3A%3D%20aString"
				 }			],
			"class" : [
				{
					"name" : "current.st",
					"contents" : "accessing%0Acurrent%0A%09%5Ecurrent"
				 },
				{
					"name" : "current..st",
					"contents" : "accessing%0Acurrent%3A%20anObject%0A%09current%20%3A%3D%20anObject"
				 },
				{
					"name" : "initialize.st",
					"contents" : "initialization%0Ainitialize%0A%09self%20current%3A%20self%20new"
				 }			],
			"README.md" : "This%20mock%20contains%20basic%20class%20and%20instance%20method%20selectors",
			"properties.json" : {
				"classinstvars" : [
					"current" ],
				"instvars" : [
					"name" ],
				"name" : "CypressMockBasic",
				"super" : "Object" }
		 },
		{
			"name" : "Object.extension",
			"instance" : [
				{
					"name" : "isCypressMockBasic.st",
					"contents" : "%2ACypress-Mocks%0AisCypressMockBasic%0A%09%5Efalse"
				 }			],
			"class" : [
			],
			"properties.json" : {
				"name" : "Object" }
		 }
	],
	"properties.json" : {
		 }
}'! !
!CypressAbstractTest methodsFor: 'private'!
       baseTargetPatch
	| className |
	className := 'CypressMockBasic'.
	^{
		(CypressAddition 
			of: (CypressMethodDefinition
          			className: className
        			classIsMeta: false
        			selector: 'added'
        			category: 'accessing'
        			source:'added
	"added method"')).
		(CypressModification 
			of: (CypressMethodDefinition
          			className: className
        			classIsMeta: false
        			selector: 'name:'
        			category: 'accessing'
        			source:'name: aString
	name := aString') 
			to: (CypressMethodDefinition
          			className: className
        			classIsMeta: false
        			selector: 'name:'
        			category: 'accessing'
        			source:'name: aString
	"changed method"
	name := aString')).
		(CypressRemoval 
			of: (CypressMethodDefinition
          			className: className
        			classIsMeta: false
        			selector: 'extra'
        			category: 'accessing'
        			source:'extra
	"extra method"')).
		(CypressRemoval 
			of: (CypressMethodDefinition
          			className: 'Object'
        			classIsMeta: false
        			selector: 'isCypressMockBasic'
        			category: '*Cypress-Mocks'
        			source:'isCypressMockBasic
	^false'))
	}
! !
!CypressAbstractTest methodsFor: 'private' stamp: 'dkh 4/24/2012 01:04'!
          classComment

	^'This mock contains basic class and instance method selectors'
! !
!CypressAbstractTest methodsFor: 'private' stamp: 'dkh 4/23/2012 21:33'!
    compileJSON: aJsonString

	^CypressJsonParser parse: aJsonString! !
!CypressAbstractTest methodsFor: 'private' stamp: 'dkh 4/24/2012 00:04'!
                   sampleJson

	^'{
	"age" : 25,
	"name" : "John%20Smith",
	"phoneNumber" : [
		{
			"number" : "212%20555-1234",
			"type" : "home" },
		{
			"number" : "646%20555-4567",
			"type" : "fax" } ],
	"registered" : true }'
! !
!CypressAbstractTest methodsFor: 'private'!
                        targetDefinitions
	"remove #extra method and modify #name: method"

	| className |
	className := 'CypressMockBasic'.
	^{
		(CypressClassDefinition
        		name: className
       		 	superclassName: 'Object'
       			category: 'Cypress-Mocks'
                       	instVarNames: #('name')
			classInstVarNames: #('current')
        		comment: self classComment).
   	 	(CypressMethodDefinition
          		className: className
        		classIsMeta: false
        		selector: 'added'
        		category: 'accessing'
        		source:'added
	"added method"').
   	 	(CypressMethodDefinition
          		className: className
        		classIsMeta: false
        		selector: 'initialize'
        		category: 'initialization'
        		source:'initialize
	super initialize.
	self name: ''Unknown''').
   	 	(CypressMethodDefinition
          		className: className
        		classIsMeta: false
        		selector: 'name'
        		category: 'accessing'
        		source:'name
	^name').
   	 	(CypressMethodDefinition
          		className: className
        		classIsMeta: false
        		selector: 'name:'
        		category: 'accessing'
        		source:'name: aString
	"changed method"
	name := aString').
   	 	(CypressMethodDefinition
          		className: className
        		classIsMeta: true
        		selector: 'current'
        		category: 'accessing'
        		source:'current
	^current').
   	 	(CypressMethodDefinition
          		className: className
        		classIsMeta: true
        		selector: 'current:'
        		category: 'accessing'
        		source:'current: anObject
	current := anObject').
   	 	(CypressMethodDefinition
          		className: className
        		classIsMeta: true
        		selector: 'initialize'
        		category: 'initialization'
        		source:'initialize
	self current: self new')
	}
! !
!CypressAbstractTest methodsFor: 'private' stamp: 'dkh 4/24/2012 00:55'!
      validatePackage: package against: expectedDefinitions

	| packageDefinitions cd1 cd2 |
	packageDefinitions := package snapshot definitions.
	self assert: (expectedDefinitions size = packageDefinitions size).
	cd1 := packageDefinitions detect: [:each | each isKindOf: CypressClassDefinition].
	cd2 :=  expectedDefinitions detect: [:each | each isKindOf: CypressClassDefinition].
	self assert: cd1 = cd2.
	packageDefinitions do: [:def |
		(expectedDefinitions includes: def)
			ifFalse: [ 
				def inspect.
				self assert: false ]].
! !
!CypressDefinitionTest methodsFor: 'testing'!
                          testClassDefinition
	self assert: (CypressClassDefinition
		name: 'Foo'
       		 superclassName: 'Object'
       		category: 'Foo'
                instVarNames: #()
		classInstVarNames: #()
        	comment: '') printString =  'a CypressClassDefinition (Foo)'
! !
!CypressDefinitionTest methodsFor: 'testing'!
         testDictionaryOfDefinitions

	| dict |
	"baseDefinitions"
	dict := Dictionary new.
	self baseDefinitions do: [:each | 
		dict at: each put: each ].
	self baseDefinitions do: [:each | 
		self assert: (dict at: each) = each ].

	"targetDefinitions"
	dict := Dictionary new.
	self targetDefinitions do: [:each | 
		dict at: each put: each ].
	self targetDefinitions do: [:each | 
		self assert: (dict at: each) = each ].
! !
!CypressDefinitionTest methodsFor: 'testing'!
            testEquality
	| pkg1 pkg2 pkg3 name |
	name := 'Cypress-Mocks'.
	pkg1 := CypressPackageDefinition new name: name.
	pkg2 := CypressPackageDefinition new name: name.
	pkg3 := CypressPackageDefinition new name: 'Nope!!'.

	self assert: pkg1 equals: pkg2.
	self deny: pkg1 = pkg3
! !
!CypressDefinitionTest methodsFor: 'testing'!
                          testMethodDefinition
	self assert: (CypressMethodDefinition
		className: 'Foo'
		classIsMeta: false
		selector: 'isFoo'
		category: 'testing'
		source: 'isFoo ^true') printString = 'a CypressMethodDefinition (Foo>>isFoo)'
! !
!CypressDefinitionTest methodsFor: 'testing'!
                testNameEquality
	| pkg name |
	name := 'Cypress-Mocks'.
	pkg := CypressPackageDefinition new name: name.
	self assert: pkg name equals: name.
	self deny: (pkg name = 'Nope.').
! !
!CypressDefinitionTest methodsFor: 'testing'!
                             testPrintString
	| name pkg |
	name := 'Cypress-Mocks'.
	pkg := CypressPackageDefinition new name: name.
	self assert: 'a CypressPackageDefinition(', name, ')' equals: pkg printString.
! !
!CypressLoaderTest methodsFor: 'running'!
                         tearDown

	| name |
	super tearDown.
	name := 'Cypress-Mocks'.
	(CypressSnapshot definitions: self baseDefinitions)
		 updatePackage: (CypressPackageDefinition new name: name)
! !
!CypressLoaderTest methodsFor: 'testing'!
  testLoad

	| name |
	name := 'Cypress-Mocks'.
	(CypressSnapshot definitions: self targetDefinitions)
		 updatePackage: (CypressPackageDefinition new name: name)
! !
!CypressPatchTest methodsFor: 'testing'!
                  testDictionaryOfPatchOperations
	"loader uses dictionary for managing patch operations ... ensure that Amber Dictionaries stand up"

	| dict |
	dict := Dictionary new.
	self baseTargetPatch do: [:each | 
		dict at: each put: each ].
	self baseTargetPatch do: [:each | 
		self assert: (dict at: each) = each ].
! !
!CypressPatchTest methodsFor: 'testing' stamp: 'dkh 4/24/2012 00:18'!
testPatch
    | baseSnapshot targetSnapshot patch operations expected |
    baseSnapshot := CypressSnapshot definitions: self baseDefinitions.
    targetSnapshot := CypressSnapshot definitions: self targetDefinitions.
    patch := CypressPatch fromBase: baseSnapshot toTarget: targetSnapshot.
    operations := patch operations.
    self assert: operations size = 4.
    expected := self baseTargetPatch asArray.
    1 to: operations size do: [ :index | 
        | op |
        op := operations at: index.
        self assert: (expected includes: op) ]! !
!CypressPatchTest methodsFor: 'testing'!
           testPatchOperationEquality

	| className modification removal addition |
	className := 'CypressMockBasic'.
	modification := CypressModification 
			of: (CypressMethodDefinition
          			className: className
        			classIsMeta: false
        			selector: 'name:'
        			category: 'accessing'
        			source:'name: aString
	name := aString') 
			to: (CypressMethodDefinition
          			className: className
        			classIsMeta: false
        			selector: 'name:'
        			category: 'accessing'
        			source:'name: aString
	"changed method"
	name := aString').
	self assert: modification = modification.
	removal := CypressRemoval 
			of: (CypressMethodDefinition
          			className: className
        			classIsMeta: false
        			selector: 'extra'
        			category: 'accessing'
        			source:'extra
	"extra method"').
	self assert: removal = removal.
	addition := CypressAddition
			of: (CypressMethodDefinition
          			className: className
        			classIsMeta: false
        			selector: 'extra'
        			category: 'accessing'
        			source:'extra
	"extra method"').
	self assert: addition = addition.
! !
!CypressSnapshotTest methodsFor: 'testing'!
           testSnapshot
	| name pkg  |
	name := 'Cypress-Mocks'.
	pkg := CypressPackageDefinition new name: name.
	self validatePackage: pkg against: self baseDefinitions
! !
!CypressSnapshotTest methodsFor: 'testing' stamp: 'dkh 4/24/2012 00:20'!
                   testSnapshotEquality
	| name pkg packageDefinitions expectedDefinitions |
	name := 'Cypress-Mocks'.
	pkg := CypressPackageDefinition new name: name.
	packageDefinitions := pkg snapshot definitions.
	expectedDefinitions := self baseDefinitions.
	self assert: packageDefinitions asArray = expectedDefinitions asArray
! !
!CypressStructureTest methodsFor: 'tests' stamp: 'dkh 4/24/2012 00:59'!
                         testClassStructure

	| jsObject packageStructure classStructure classProperties |
	jsObject := self compileJSON: self basePackageStructureJson.
	packageStructure := CypressPackageStructure fromJs: jsObject.
	classStructure := packageStructure classes first.
	self assert: classStructure name = 'CypressMockBasic'.
	self deny: classStructure isClassExtension.
	self assert: classStructure comment =  'This mock contains basic class and instance method selectors'..
	classProperties := classStructure properties.
	self assert: classProperties size = 4.
	self assert: (classProperties at: 'instvars') = #('name').
	self assert: (classProperties at: 'classinstvars') = #('current').
	self assert: (classProperties at: 'name') = 'CypressMockBasic'.
	self assert: (classProperties at: 'super') = 'Object'.
	self assert: classStructure instanceMethods size = 4.
	self assert: classStructure classMethods size = 3.
	classStructure := packageStructure extensions first.
	self assert: classStructure name = 'Object'.
	self assert: classStructure isClassExtension.
	self assert: classStructure comment = ''.
	classProperties := classStructure properties.
	self assert: classProperties size = 1.
	self assert: (classProperties at: 'name') = 'Object'.
	self assert: classStructure instanceMethods size = 1.
	self assert: classStructure classMethods size = 0.
! !
!CypressStructureTest methodsFor: 'tests'!
               testJson
	"Let's compile the JSON without errors"

	self compileJSON: self basePackageStructureJson
! !
!CypressStructureTest methodsFor: 'tests'!
             testPackageStructureFromJson

	| packageStructure classStructure classProperties |
	packageStructure := CypressPackageStructure fromJson: self basePackageStructureJson.
	self assert: packageStructure name = 'Cypress-Mocks.package'.
	self assert: packageStructure packageName = 'Cypress-Mocks'.
	self assert: packageStructure properties isEmpty.
	self assert: packageStructure extensions size = 1.
	self assert: packageStructure classes size = 1.
! !
!CypressStructureTest methodsFor: 'tests'!
                   testPackageStructureFromPackage

	| packageStructure |
	packageStructure := CypressPackageStructure fromPackage: (CypressPackageDefinition new name: 'Cypress-Mocks').
	self validatePackage: packageStructure against: self baseDefinitions
! !
!CypressStructureTest methodsFor: 'tests'!
    testPackageStructureSnapshot

	| packageStructure |
	packageStructure := CypressPackageStructure fromJs: (self compileJSON: self basePackageStructureJson).
	self validatePackage: packageStructure against: self baseDefinitions
! !
!CypressStructureTest methodsFor: 'tests' stamp: 'dkh 4/24/2012 00:38'!
                  testPackageStructureToJson

	| packageStructure stream json |
	packageStructure := CypressPackageStructure fromPackage: (CypressPackageDefinition new name: 'Cypress-Mocks').
	stream := WriteStream on: String new.
	packageStructure writeJsonOn: stream.
	json := stream contents.
	self assert: (self basePackageStructureJson withLineEndings: String lfString) = (json withLineEndings: String lfString)
! !
!CypressStructureTest methodsFor: 'tests'!
  testPropertyDictionaryRead

	| propertyDictionary phoneNumbers |
	propertyDictionary := (self compileJSON: self sampleJson) asCypressPropertyObject.
	self assert: (propertyDictionary at: 'name') = 'John Smith'.
	self assert: (propertyDictionary at: 'age') = 25.
	self assert: (propertyDictionary at: 'registered').
	phoneNumbers := propertyDictionary at: 'phoneNumber'.
	self assert: phoneNumbers size = 2.
	self assert: ((phoneNumbers at: 1) at: 'number') = '212 555-1234'.
	self assert: ((phoneNumbers at: 2) at: 'number') = '646 555-4567'.
! !
!CypressStructureTest methodsFor: 'tests' stamp: 'dkh 4/23/2012 23:59'!
                     testPropertyDictionaryWrite

	| propertyDictionary stream x y |
	propertyDictionary := (self compileJSON: self sampleJson) asCypressPropertyObject.
	stream := WriteStream on: String new.
	propertyDictionary writeCypressJsonOn: stream indent: 0.
	self assert: (x:= stream contents withLineEndings: String lfString)  = (y := self sampleJson withLineEndings: String lfString)
! !

----End fileIn of /Volumes/CANON_DC/Cuis/CampSmalltalk-cuis-cypress-0640657/Cypress-Tests.pck----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1260] on 24 April 2012 at 3:29:19 pm'!

'Description Please enter a description for this package '!

!classDefinition: #CypressMockBasic category: #'Cypress-Mocks'!
Object subclass: #CypressMockBasic
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Mocks'!

Object subclass: #CypressMockBasic
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cypress-Mocks'!

!classDefinition: 'CypressMockBasic class' category: #'Cypress-Mocks'!
CypressMockBasic class
	instanceVariableNames: 'current'!

CypressMockBasic class
	instanceVariableNames: 'current'!
!CypressMockBasic commentStamp: 'dkh 4/24/2012 01:05' prior: 0!
                      This mock contains basic class and instance method selectors!
!CypressMockBasic methodsFor: 'accessing' stamp: 'dkh 4/24/2012 15:29'!
                          extra
	"extra method"! !
!CypressMockBasic methodsFor: 'initialization' stamp: 'dkh 4/24/2012 00:33'!
                          initialize
	super initialize.
	self name: 'Unknown'! !
!CypressMockBasic methodsFor: 'accessing' stamp: 'dkh 4/24/2012 00:22'!
 name
	^name! !
!CypressMockBasic methodsFor: 'accessing' stamp: 'dkh 4/24/2012 15:29'!
         name: aString
	name := aString! !
!CypressMockBasic class methodsFor: 'accessing' stamp: 'dkh 4/24/2012 00:23'!
                current
	^current! !
!CypressMockBasic class methodsFor: 'accessing' stamp: 'dkh 4/24/2012 00:23'!
                             current: anObject
	current := anObject! !
!CypressMockBasic class methodsFor: 'initialization' stamp: 'dkh 4/24/2012 00:23'!
   initialize
	self current: self new! !
!Object methodsFor: '*Cypress-Mocks' stamp: 'dkh 4/24/2012 15:29'!
                       isCypressMockBasic
	^false! !

CypressMockBasic initialize!

----End fileIn of /Volumes/CANON_DC/Cuis/CampSmalltalk-cuis-cypress-0640657/Cypress-Mocks.pck----!
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/12/2012 19:40'!
              array ^ #(nil true false)! !

ArrayLiteralTest removeSelector: #array!
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/12/2012 19:40'!
       array ^ #(#nil #true #false #'nil' #'true' #'false')! !

ArrayLiteralTest removeSelector: #array!
!CypressPackageDefinition methodsFor: 'snapshotting' stamp: 'jmv 5/12/2012 19:41' prior: 50347875!
                           snapshot
    | package definitions map classMap |
    package := CodePackage named: self name createIfAbsent: true registerIfNew: false.
    definitions := OrderedCollection new.
    (ChangeSet superclassOrder: package classes)
        do: [ :cls | 
            definitions add: cls asCypressClassDefinition.
            (cls methodDictionary values sorted: [ :a :b | a selector <= b selector ])
                do: [ :method | 
                    (method category at: 1) = $*
                        ifFalse: [ definitions add: method asCypressMethodDefinition ] ].
            (cls class methodDictionary values sorted: [ :a :b | a selector <= b selector ])
                do: [ :method | 
                    (method category at: 1) = $*
                        ifFalse: [ definitions add: method asCypressMethodDefinition ] ] ].
    classMap := Dictionary new.
    Smalltalk allClasses
        do: [ :each | 
            {each.
            (each class)}
                do: [ :aClass | 
                    | defs |
                    defs := OrderedCollection new.
                    map := Dictionary new.
                    aClass organization categories
                        do: [ :category | 
                            | methods |
                            methods := aClass organization listAtCategoryNamed: category.
                            (category asLowercase beginsWith: '*' , self name asLowercase)
                                ifTrue: [ map at: category put: methods ] ].
                    (map keys sorted: [ :a :b | a <= b ])
                        do: [ :category | 
                            ((map at: category) sorted: [ :a :b | a selector <= b selector ])
                                do: [ :method | defs add: (aClass compiledMethodAt: method) asCypressMethodDefinition ] ].
                    defs notEmpty
                        ifTrue: [ classMap at: each put: defs ] ] ].
    (ChangeSet superclassOrder: classMap keys) do: [ :aClass | definitions addAll: (classMap at: aClass) ].
    ^ CypressSnapshot definitions: definitions! !

Smalltalk browseAllUnimplementedCalls!

	$0 asciiValue!
!Character methodsFor: '*Cypress-Structure' stamp: 'jmv 5/12/2012 19:44'!
                      charCode
	^self asciiValue! !

Smalltalk browseUndeclaredReferences !

Smalltalk browseAllUnimplementedCalls !
!Character class methodsFor: '*Cypress-Structure' stamp: 'jmv 5/12/2012 19:46'!
 codePoint: x
	^self unicodeCodePoint: x! !
!Character class methodsFor: '*Cypress-Structure' stamp: 'jmv 5/12/2012 19:46' prior: 50348931!
                     codePoint: codePoint
	^self unicodeCodePoint: codePoint! !

Smalltalk browseAllUnimplementedCalls !
!FileDirectory methodsFor: 'file stream creation' stamp: 'jmv 5/12/2012 19:50'!
            readOnlyFileNamed: localFileName do: aBlock
	"Open the existing file with the given name in this directory for read-only access,
	evaluate aBlock, and close the file"

	| file |
	file _ self readOnlyFileNamed: localFileName.
	[ aBlock value: file ] ensure: [ file close ]! !
!FileDirectory methodsFor: 'file stream creation' stamp: 'jmv 5/12/2012 19:51' prior: 50348942!
             readOnlyFileNamed: localFileName do: aBlock
	"Open the existing file with the given name in this directory for read-only access,
	evaluate aBlock, and close the file"

	| fileStream |
	fileStream _ self readOnlyFileNamed: localFileName.
	[ aBlock value: fileStream ] ensure: [ fileStream close ]! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'jmv 5/12/2012 19:53' prior: 50346600!
                           writeMethodStructure: methodStructure to:methodPath    | filename |    filename := self fileNameForSelector: methodStructure selector.    self        writeInDirectoryName: methodPath        fileName: filename        extension: '.st'        visit: [:fileStream |		fileStream        		nextPutAll: methodStructure category;        		newLine;        		nextPutAll: (methodStructure source withLineEndings: String lfString) ]! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'jmv 5/12/2012 19:53' prior: 50348967!
                   writeMethodStructure: methodStructure to:methodPath

    | filename |
    filename := self fileNameForSelector: methodStructure selector.
    self
        writeInDirectoryName: methodPath
        fileName: filename
        extension: '.st'
        visit: [:fileStream |
		fileStream
        		nextPutAll: methodStructure category;
        		newLine;
        		nextPutAll: (methodStructure source withLineEndings: String lfString) ]! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'jmv 5/12/2012 19:53' prior: 50346532!
                   writeClassComment: classStructure on: fileStream    fileStream nextPutAll: (classStructure comment withLineEndings: String lfString)! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'jmv 5/12/2012 19:53' prior: 50349001!
                             writeClassComment: classStructure on: fileStream

    fileStream nextPutAll: (classStructure comment withLineEndings: String lfString)! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'jmv 5/12/2012 19:54' prior: 50346662!
                            writePropertiesFile

    self
        writeInDirectoryName: '.'
        fileName: 'properties'
        extension: '.json'
        visit: [:fileStream | Dictionary new writeCypressJsonOn: fileStream indent: 1 ]! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'jmv 5/12/2012 19:54' prior: 50349017!
                 writePropertiesFile

    self
        writeInDirectoryName: '.'
        fileName: 'properties'
        extension: '.json'
        visit: [:fileStream | Dictionary new writeCypressJsonOn: fileStream indent: 0 ]! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'jmv 5/12/2012 19:54' prior: 50346572!
                 writeExtensionClassStructure: classStructure to: classPath

     self
        writeInDirectoryName: classPath
        fileName: 'properties'
        extension: '.json'
        visit: [:fileStream |  | properties |
    		properties := Dictionary new.
    		properties at: 'name' put: classStructure className.
    		properties writeCypressJsonOn: fileStream  indent: 0 ]! !
!CypressPackageWriter methodsFor: 'writing' stamp: 'jmv 5/12/2012 19:54' prior: 50346539!
                 writeClassStructure: classStructure on: fileStream

    | properties |
    properties := Dictionary new.
    properties at: 'name' put: classStructure className.
    properties at: 'super' put: classStructure superclassName.
    properties at: 'instvars' put: classStructure instanceVariableNames.
    properties at: 'classinstvars' put: classStructure classInstanceVariableNames.
    properties writeCypressJsonOn: fileStream  indent: 0! !
!CypressPackageWriter methodsFor: 'private' stamp: 'jmv 5/12/2012 19:56' prior: 50346586!
             writeInDirectoryName: directoryNameOrPath fileName: fileName extension: ext visit: visitBlock
    | directory stream |
    directory _ self directoryForDirectoryNamed: directoryNameOrPath.
    stream _ directory
        forceNewFileNamed: fileName , ext.
        stream
            file lineEndConvention: #'lf'.
            visitBlock value: stream! !
!CypressPackageWriter methodsFor: 'private' stamp: 'jmv 5/12/2012 19:57' prior: 50349069!
     writeInDirectoryName: directoryNameOrPath fileName: fileName extension: ext visit: visitBlock
    | directory stream |
    directory _ self directoryForDirectoryNamed: directoryNameOrPath.
    stream _ directory
        forceNewFileNamed: fileName , ext.
    "stream lineEndConvention: #'lf'."
    visitBlock value: stream! !

Smalltalk browseAllUnimplementedCalls!
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/12/2012 19:59'!
array ^ #(nil true false)! !

ArrayLiteralTest removeSelector: #array!
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/12/2012 19:59'!
       array ^ #(#nil #true #false #'nil' #'true' #'false')! !

ArrayLiteralTest removeSelector: #array!
!CypressMockBasic methodsFor: 'accessing' stamp: 'jmv 5/12/2012 19:59'!
                      added
	"added method"! !
!CypressMockBasic methodsFor: 'accessing' stamp: 'jmv 5/12/2012 19:59' prior: 50348819!
               name: aString
	"changed method"
	name := aString! !

Object removeSelector: #isCypressMockBasic!

CypressMockBasic removeSelector: #extra!
!Object methodsFor: '*Cypress-Mocks' stamp: 'jmv 5/12/2012 19:59'!
                  isCypressMockBasic
	^false! !
!CypressMockBasic methodsFor: 'accessing' stamp: 'jmv 5/12/2012 19:59'!
                          extra
	"extra method"! !
!CypressMockBasic methodsFor: 'accessing' stamp: 'jmv 5/12/2012 19:59' prior: 50349112!
               name: aString
	name := aString! !

CypressMockBasic removeSelector: #added!
!a subclass of Theme methodsFor: 'as yet unclassified' stamp: 'jmv 5/12/2012 19:59'!
                               	shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 			-> #green.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 			-> #(blue muchDarker).
		#instVar 				-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 		-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 			-> #(gray muchDarker).
	}
! !

DefaultDirectory!

FileDirectory default!

FileDirectory forFileName: 'CampSmalltalk-Cypress-Mocks-0497a19'!

FileDirectory forFileName: './CampSmalltalk-Cypress-Mocks-0497a19'!

FileDirectory on: 'CampSmalltalk-Cypress-Mocks-0497a19'!

(FileDirectory on: 'CampSmalltalk-Cypress-Mocks-0497a19') entries!

(FileDirectory on: './CampSmalltalk-Cypress-Mocks-0497a19') entries!

FileDirectory default directoryNamed: 'CampSmalltalk-Cypress-Mocks-0497a19'!

(FileDirectory default directoryNamed: 'CampSmalltalk-Cypress-Mocks-0497a19') entries!
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:10'!
                         readClassStructureFromEntry: classEntry in: aFileDirectory

    | classDirectory classPropertiesDict classComment entries classStructure |
    classDirectory := aFileDirectory directoryNamed: classEntry name.
    ((entries := classDirectory entries) detect: [ :entry | entry name = 'properties.json' ] ifNone: [  ])
        ifNotNil: [ :propertyEntry | propertyEntry readStreamDo: [ :fileStream | classPropertiesDict := CypressJsonParser parseStream: fileStream ] ].
    (entries detect: [ :entry | entry name = 'README.md' ] ifNone: [  ])
        ifNotNil: [ :commentEntry | commentEntry readStreamDo: [ :fileStream | classComment := fileStream contents ] ].
    classStructure := self classStructureFrom: classPropertiesDict comment: classComment.
    self readMethodStructureFor: classStructure in: entries.
	^classStructure! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:10' prior: 50346228!
       readPackageStructure   packageStructure := CypressPackageStructure new name: self packageDirectory localName.   self packageDirectory entries        do: [ :entry |             (entry name endsWith: '.class')                ifTrue: [ self packageStructure classes add: (self readClassStructureFromEntry: entry in: self packageDirectory) ].            (entry name endsWith: '.extension')                ifTrue: [ self packageStructure extensions add: (self readExtensionClassStructureFromEntry: entry) ] ]! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:10' prior: 50349199!
   readPackageStructure

   packageStructure := CypressPackageStructure new name: self packageDirectory localName.
   self packageDirectory entries
        do: [ :entry | 
            (entry name endsWith: '.class')
                ifTrue: [ self packageStructure classes add: (self readClassStructureFromEntry: entry in: self packageDirectory) ].
            (entry name endsWith: '.extension')
                ifTrue: [ self packageStructure extensions add: (self readExtensionClassStructureFromEntry: entry) ] ]! !

CypressPackageReader removeSelector: #readClassStructureFromEntry:!
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:11'!
              readExtensionClassStructureFromEntry: classEntry in: aFileDirectory

    | classDirectory classPropertiesDict entries classStructure |
    classDirectory := aFileDirectory directoryNamed: classEntry name.
    ((entries := classDirectory entries) detect: [ :entry | entry name = 'properties.json' ] ifNone: [  ])
        ifNotNil: [ :propertyEntry | propertyEntry readStreamDo: [ :fileStream | classPropertiesDict := CypressJsonParser parseStream: fileStream ] ].
    classStructure := self classStructureFrom: classPropertiesDict.
    self readMethodStructureFor: classStructure in: entries.
	^classStructure! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:12' prior: 50349218!
  readPackageStructure

   packageStructure := CypressPackageStructure new name: self packageDirectory localName.
   self packageDirectory entries
        do: [ :entry | 
            (entry name endsWith: '.class')
                ifTrue: [ self packageStructure classes add: (self readClassStructureFromEntry: entry in: self packageDirectory) ].
            (entry name endsWith: '.extension')
                ifTrue: [ self packageStructure extensions add: (self readExtensionClassStructureFromEntry: entry in: self packageDirectory) ] ]! !

CypressPackageReader removeSelector: #readExtensionClassStructureFromEntry:!
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:12' prior: 50346188!
                           readMethodStructureFor: classStructure in: entries

    entries
        do: [ :entry | 
            | methods isMeta |
		isMeta := false.
 		methods := entry name = 'class'
                ifTrue: [ 
			isMeta := true.
			classStructure classMethods ]
		    ifFalse: [ classStructure instanceMethods ].
            (entry name = 'instance' or: [ entry name = 'class' ])
                ifTrue: [ 
                    (entry asFileDirectory entries select: [ :each | each name endsWith: '.st' ])
                        do: [ :methodEntry | 
                            methodEntry
                                readStreamDo: [ :fileStream | 
                                    | category source selector |
                                    category := fileStream nextLine.
                                    source := fileStream upToEnd.
						selector := Parser new parseSelector: source.
                                     methods 
							at: selector
							put: ((CypressMethodStructure new)
									name: selector;
									isMetaclass: isMeta;
									selector: selector;
									category: category;
									source: source;
									yourself) ] ] ] ]! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:12'!
  readMethodStructureFor: classStructure in: entries in: aFileDirectory

    entries
        do: [ :entry | 
            | methods isMeta |
		isMeta := false.
 		methods := entry name = 'class'
                ifTrue: [ 
			isMeta := true.
			classStructure classMethods ]
		    ifFalse: [ classStructure instanceMethods ].
            (entry name = 'instance' or: [ entry name = 'class' ])
                ifTrue: [ 
                    (entry asFileDirectory entries select: [ :each | each name endsWith: '.st' ])
                        do: [ :methodEntry | 
                            methodEntry
                                readStreamDo: [ :fileStream | 
                                    | category source selector |
                                    category := fileStream nextLine.
                                    source := fileStream upToEnd.
						selector := Parser new parseSelector: source.
                                     methods 
							at: selector
							put: ((CypressMethodStructure new)
									name: selector;
									isMetaclass: isMeta;
									selector: selector;
									category: category;
									source: source;
									yourself) ] ] ] ]! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:12' prior: 50349170!
                               readClassStructureFromEntry: classEntry in: aFileDirectory

    | classDirectory classPropertiesDict classComment entries classStructure |
    classDirectory := aFileDirectory directoryNamed: classEntry name.
    ((entries := classDirectory entries) detect: [ :entry | entry name = 'properties.json' ] ifNone: [  ])
        ifNotNil: [ :propertyEntry | propertyEntry readStreamDo: [ :fileStream | classPropertiesDict := CypressJsonParser parseStream: fileStream ] ].
    (entries detect: [ :entry | entry name = 'README.md' ] ifNone: [  ])
        ifNotNil: [ :commentEntry | commentEntry readStreamDo: [ :fileStream | classComment := fileStream contents ] ].
    classStructure := self classStructureFrom: classPropertiesDict comment: classComment.
    self readMethodStructureFor: classStructure in: entries  in: aFileDirectory.
	^classStructure! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:12' prior: 50349364!
                   readClassStructureFromEntry: classEntry in: aFileDirectory

    | classDirectory classPropertiesDict classComment entries classStructure |
    classDirectory := aFileDirectory directoryNamed: classEntry name.
    ((entries := classDirectory entries) detect: [ :entry | entry name = 'properties.json' ] ifNone: [  ])
        ifNotNil: [ :propertyEntry | propertyEntry readStreamDo: [ :fileStream | classPropertiesDict := CypressJsonParser parseStream: fileStream ] ].
    (entries detect: [ :entry | entry name = 'README.md' ] ifNone: [  ])
        ifNotNil: [ :commentEntry | commentEntry readStreamDo: [ :fileStream | classComment := fileStream contents ] ].
    classStructure := self classStructureFrom: classPropertiesDict comment: classComment.
    self readMethodStructureFor: classStructure in: entries in: aFileDirectory.
	^classStructure! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:12' prior: 50349239!
                    readExtensionClassStructureFromEntry: classEntry in: aFileDirectory

    | classDirectory classPropertiesDict entries classStructure |
    classDirectory := aFileDirectory directoryNamed: classEntry name.
    ((entries := classDirectory entries) detect: [ :entry | entry name = 'properties.json' ] ifNone: [  ])
        ifNotNil: [ :propertyEntry | propertyEntry readStreamDo: [ :fileStream | classPropertiesDict := CypressJsonParser parseStream: fileStream ] ].
    classStructure := self classStructureFrom: classPropertiesDict.
    self readMethodStructureFor: classStructure in: entries in: aFileDirectory.
	^classStructure! !

CypressPackageReader removeSelector: #readMethodStructureFor:in:!
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:13' prior: 50349394!
            readClassStructureFromEntry: classEntry in: aFileDirectory
	| classDirectory classPropertiesDict classComment entries classStructure |
	classDirectory _ aFileDirectory directoryNamed: classEntry name.
	((entries _ classDirectory entries)
		detect: [ :entry |
			entry name = 'properties.json' ]
		ifNone: [ ]) ifNotNil: [ :propertyEntry |
		propertyEntry readStreamDo: [ :fileStream |
			classPropertiesDict _ CypressJsonParser parseStream: fileStream ]].
	(entries
		detect: [ :entry |
			entry name = 'README.md' ]
		ifNone: [ ]) ifNotNil: [ :commentEntry |
		commentEntry readStreamDo: [ :fileStream |
			classComment _ fileStream contents ]].
	classStructure _ self
		classStructureFrom: classPropertiesDict
		comment: classComment.
	self
		readMethodStructureFor: classStructure
		in: entries
		in: aFileDirectory.
	^ classStructure.! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:14' prior: 50349449!
                            readClassStructureFromEntry: classEntry in: aFileDirectory
	| classDirectory classPropertiesDict classComment entries classStructure |
	classDirectory _ aFileDirectory directoryNamed: classEntry name.
	((entries _ classDirectory entries)
		detect: [ :entry |
			entry name = 'properties.json' ]
		ifNone: [ ]) ifNotNil: [ :propertyEntry |
		aFileDirectory readOnlyFileNamed: propertyEntry name do: [ :fileStream |
			classPropertiesDict _ CypressJsonParser parseStream: fileStream ]].
	(entries
		detect: [ :entry |
			entry name = 'README.md' ]
		ifNone: [ ]) ifNotNil: [ :commentEntry |
		commentEntry readStreamDo: [ :fileStream |
			classComment _ fileStream contents ]].
	classStructure _ self
		classStructureFrom: classPropertiesDict
		comment: classComment.
	self
		readMethodStructureFor: classStructure
		in: entries
		in: aFileDirectory.
	^ classStructure.! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:14' prior: 50349479!
                               readClassStructureFromEntry: classEntry in: aFileDirectory
	| classDirectory classPropertiesDict classComment entries classStructure |
	classDirectory _ aFileDirectory directoryNamed: classEntry name.
	((entries _ classDirectory entries)
		detect: [ :entry |
			entry name = 'properties.json' ]
		ifNone: [ ]) ifNotNil: [ :propertyEntry |
		aFileDirectory readOnlyFileNamed: propertyEntry name do: [ :fileStream |
			classPropertiesDict _ CypressJsonParser parseStream: fileStream ]].
	(entries
		detect: [ :entry |
			entry name = 'README.md' ]
		ifNone: [ ]) ifNotNil: [ :commentEntry |
		aFileDirectory readOnlyFileNamed: commentEntry name do: [ :fileStream |
			classComment _ fileStream contents ]].
	classStructure _ self
		classStructureFrom: classPropertiesDict
		comment: classComment.
	self
		readMethodStructureFor: classStructure
		in: entries
		in: aFileDirectory.
	^ classStructure.! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:14' prior: 50349424!
  readExtensionClassStructureFromEntry: classEntry in: aFileDirectory
	| classDirectory classPropertiesDict entries classStructure |
	classDirectory _ aFileDirectory directoryNamed: classEntry name.
	((entries _ classDirectory entries)
		detect: [ :entry |
			entry name = 'properties.json' ]
		ifNone: [ ]) ifNotNil: [ :propertyEntry |
		propertyEntry readStreamDo: [ :fileStream |
			classPropertiesDict _ CypressJsonParser parseStream: fileStream ]].
	classStructure _ self classStructureFrom: classPropertiesDict.
	self
		readMethodStructureFor: classStructure
		in: entries
		in: aFileDirectory.
	^ classStructure.! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:14' prior: 50349541!
                         readExtensionClassStructureFromEntry: classEntry in: aFileDirectory
	| classDirectory classPropertiesDict entries classStructure |
	classDirectory _ aFileDirectory directoryNamed: classEntry name.
	((entries _ classDirectory entries)
		detect: [ :entry |
			entry name = 'properties.json' ]
		ifNone: [ ]) ifNotNil: [ :propertyEntry |
		aFileDirectory readOnlyFileNamed: propertyEntry name do: [ :fileStream |
			classPropertiesDict _ CypressJsonParser parseStream: fileStream ]].
	classStructure _ self classStructureFrom: classPropertiesDict.
	self
		readMethodStructureFor: classStructure
		in: entries
		in: aFileDirectory.
	^ classStructure.! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:15' prior: 50349323!
                            readMethodStructureFor: classStructure in: entries in: aFileDirectory

    entries
        do: [ :entry | 
            | methods isMeta |
		isMeta := false.
 		methods := entry name = 'class'
                ifTrue: [ 
			isMeta := true.
			classStructure classMethods ]
		    ifFalse: [ classStructure instanceMethods ].
            (entry name = 'instance' or: [ entry name = 'class' ])
                ifTrue: [
			((aFileDirectory directoryNamed: entry name) select: [ :each | each name endsWith: '.st' ])
                        do: [ :methodEntry | 
                            methodEntry
                                readStreamDo: [ :fileStream | 
                                    | category source selector |
                                    category := fileStream nextLine.
                                    source := fileStream upToEnd.
						selector := Parser new parseSelector: source.
                                     methods 
							at: selector
							put: ((CypressMethodStructure new)
									name: selector;
									isMetaclass: isMeta;
									selector: selector;
									category: category;
									source: source;
									yourself) ] ] ] ]! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:16' prior: 50349588!
   readMethodStructureFor: classStructure in: entries in: aFileDirectory

    entries
        do: [ :entry | 
            | methods isMeta |
		isMeta := false.
 		methods := entry name = 'class'
                ifTrue: [ 
			isMeta := true.
			classStructure classMethods ]
		    ifFalse: [ classStructure instanceMethods ].
            (entry name = 'instance' or: [ entry name = 'class' ])
                ifTrue: [
			((aFileDirectory directoryNamed: entry name) select: [ :each | each name endsWith: '.st' ])
                        do: [ :methodEntry | 
					aFileDirectory readOnlyFileNamed: methodEntry name do: [ :fileStream |
                                    | category source selector |
                                    category := fileStream nextLine.
                                    source := fileStream upToEnd.
						selector := Parser new parseSelector: source.
                                     methods 
							at: selector
							put: ((CypressMethodStructure new)
									name: selector;
									isMetaclass: isMeta;
									selector: selector;
									category: category;
									source: source;
									yourself) ] ] ] ]! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:16' prior: 50349628!
                              readMethodStructureFor: classStructure in: entries in: aFileDirectory
	entries do: [ :entry | | methods isMeta |
		isMeta _ false.
		methods _ entry name = 'class'
			ifTrue: [
				isMeta _ true.
				classStructure classMethods ]
			ifFalse: [ classStructure instanceMethods ].
		(entry name = 'instance' or: [ entry name = 'class' ]) ifTrue: [
			((aFileDirectory directoryNamed: entry name) select: [ :each |
				each name endsWith: '.st' ]) do: [ :methodEntry |
				aFileDirectory
					readOnlyFileNamed: methodEntry name
					do: [ :fileStream | | category source selector |
						category _ fileStream nextLine.
						source _ fileStream upToEnd.
						selector _ Parser new parseSelector: source.
						methods
							at: selector
							put:
								(CypressMethodStructure new
									 name: selector;
									 isMetaclass: isMeta;
									 selector: selector;
									 category: category;
									 source: source;
									 yourself) ]]]].! !

Smalltalk browseAllUnimplementedCalls!
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:18' prior: 50349510!
 readClassStructureFromEntry: classEntry in: aFileDirectory
	| classDirectory classPropertiesDict classComment entries classStructure |
	classDirectory _ aFileDirectory directoryNamed: classEntry name.
	((entries _ classDirectory entries)
		detect: [ :entry |
			entry name = 'properties.json' ]
		ifNone: [ ]) ifNotNil: [ :propertyEntry |
		classDirectory readOnlyFileNamed: propertyEntry name do: [ :fileStream |
			classPropertiesDict _ CypressJsonParser parseStream: fileStream ]].
	(entries
		detect: [ :entry |
			entry name = 'README.md' ]
		ifNone: [ ]) ifNotNil: [ :commentEntry |
		classDirectory readOnlyFileNamed: commentEntry name do: [ :fileStream |
			classComment _ fileStream contents ]].
	classStructure _ self
		classStructureFrom: classPropertiesDict
		comment: classComment.
	self
		readMethodStructureFor: classStructure
		in: entries
		in: aFileDirectory.
	^ classStructure.! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:19' prior: 50349564!
  readExtensionClassStructureFromEntry: classEntry in: aFileDirectory
	| classDirectory classPropertiesDict entries classStructure |
	classDirectory _ aFileDirectory directoryNamed: classEntry name.
	((entries _ classDirectory entries)
		detect: [ :entry |
			entry name = 'properties.json' ]
		ifNone: [ ]) ifNotNil: [ :propertyEntry |
		classDirectory readOnlyFileNamed: propertyEntry name do: [ :fileStream |
			classPropertiesDict _ CypressJsonParser parseStream: fileStream ]].
	classStructure _ self classStructureFrom: classPropertiesDict.
	self
		readMethodStructureFor: classStructure
		in: entries
		in: aFileDirectory.
	^ classStructure.! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:19' prior: 50349668!
                            readMethodStructureFor: classStructure in: entries in: aFileDirectory
	| subDir |
	entries do: [ :entry | | methods isMeta |
		isMeta _ false.
		methods _ entry name = 'class'
			ifTrue: [
				isMeta _ true.
				classStructure classMethods ]
			ifFalse: [ classStructure instanceMethods ].
		(entry name = 'instance' or: [ entry name = 'class' ]) ifTrue: [
			subDir _ aFileDirectory directoryNamed: entry name.
			(subDir select: [ :each |
				each name endsWith: '.st' ]) do: [ :methodEntry |
				subDir
					readOnlyFileNamed: methodEntry name
					do: [ :fileStream | | category source selector |
						category _ fileStream nextLine.
						source _ fileStream upToEnd.
						selector _ Parser new parseSelector: source.
						methods
							at: selector
							put:
								(CypressMethodStructure new
									 name: selector;
									 isMetaclass: isMeta;
									 selector: selector;
									 category: category;
									 source: source;
									 yourself) ]]]].! !
!CypressPackageReader methodsFor: 'private' stamp: 'jmv 5/12/2012 20:21' prior: 50346100!
                   classStructureFrom: classPropertiesDict 

	^(CypressClassStructure new)
		isClassExtension: true;
"		properties: classPropertiesDict;"	"?????"
		yourself! !
!CypressPackageReader methodsFor: 'reading' stamp: 'jmv 5/12/2012 20:22' prior: 50349757!
         readMethodStructureFor: classStructure in: entries in: aFileDirectory
	| subDir |
	entries do: [ :entry | | methods isMeta |
		isMeta _ false.
		methods _ entry name = 'class'
			ifTrue: [
				isMeta _ true.
				classStructure classMethods ]
			ifFalse: [ classStructure instanceMethods ].
		(entry name = 'instance' or: [ entry name = 'class' ]) ifTrue: [
			subDir _ aFileDirectory directoryNamed: entry name.
			(subDir entries select: [ :each |
				each name endsWith: '.st' ]) do: [ :methodEntry |
				subDir
					readOnlyFileNamed: methodEntry name
					do: [ :fileStream | | category source selector |
						category _ fileStream nextLine.
						source _ fileStream upToEnd.
						selector _ Parser new parseSelector: source.
						methods
							at: selector
							put:
								(CypressMethodStructure new
									 name: selector;
									 isMetaclass: isMeta;
									 selector: selector;
									 category: category;
									 source: source;
									 yourself) ]]]].! !

CypressPackageReader readPackageStructureFrom: ((((FileDirectory default directoryNamed: 'CampSmalltalk-Cypress-Mocks-0497a19') directoryNamed: 'pharo') directoryNamed: 'packages') directoryNamed: 'Cypress-Mocks.package')!

CypressPackageReader readPackageStructureFrom: ((((FileDirectory default directoryNamed: 'CampSmalltalk-Cypress-Mocks-0497a19') directoryNamed: 'pharo') directoryNamed: 'packages') directoryNamed: 'Cypress-Mocks.package')!

CypressPackageReader readPackageStructureFrom: ((((FileDirectory default directoryNamed: 'CampSmalltalk-Cypress-Mocks-0497a19') directoryNamed: 'pharo') directoryNamed: 'packages') directoryNamed: 'Cypress-Mocks.package')!

CypressPackageReader readPackageStructureFrom: ((((FileDirectory default directoryNamed: 'CampSmalltalk-Cypress-Mocks-0497a19') directoryNamed: 'pharo') directoryNamed: 'packages') directoryNamed: 'Cypress-Mocks.package')!
!CypressStructure methodsFor: 'accessing' stamp: 'jmv 5/12/2012 20:23'!
                             properties: aDictionary
	properties _ aDictionary! !
!CypressPackageReader methodsFor: 'private' stamp: 'jmv 5/12/2012 20:23' prior: 50349791!
                 classStructureFrom: classPropertiesDict 

	^(CypressClassStructure new)
		isClassExtension: true;
		properties: classPropertiesDict;
		yourself! !

CypressPackageReader readPackageStructureFrom: ((((FileDirectory default directoryNamed: 'CampSmalltalk-Cypress-Mocks-0497a19') directoryNamed: 'pharo') directoryNamed: 'packages') directoryNamed: 'Cypress-Mocks.package')!

CypressPackageReader readPackageStructureFrom: ((((FileDirectory default directoryNamed: 'CampSmalltalk-Cypress-Mocks-0497a19') directoryNamed: 'pharo') directoryNamed: 'packages') directoryNamed: 'Cypress-Mocks.package')!

----QUIT/NOSAVE----#(12 May 2012 8:27:20 pm) Cuis4.0-1280.image priorSource: 436066!

----STARTUP----#(12 May 2012 10:53:47 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0-1280.image!

!DamageRecorder methodsFor: 'recording' stamp: 'jmv 5/12/2012 23:01' prior: 16830477!
       recordInvalidRect: requestedRect
	"Record the given rectangle in my damage list, a list of rectangular areas of the display that should be redraw on the next display cycle."
	"Details: Damaged rectangles are often identical or overlap significantly. In these cases, we merge them to reduce the number of damage rectangles that must be processed when the display is updated. Moreover, above a certain threshold, we ignore the individual rectangles completely, and simply do a complete repaint on the next cycle.
	jmv: Important. There should be no overlapping rectangles in the list. If there are, translucent morphs might be drawn several times, with visible defects.
	WRT performance, the different paths for various intersections seem a bit complicated. I could not find strong evidence of the best way.
	Leave it as it is right now."

	| newRect mergeRect a indexToReuse |
	totalRepaint ifTrue: [^ self].  "planning full repaint; don't bother collecting damage"

	indexToReuse _ nil.
	newRect _ requestedRect truncated.
	invalidRects doWithIndex: [ :rect :index |
		rect ifNil: [
			indexToReuse ifNil: [ indexToReuse _ index ]]
		ifNotNil: [
			"No two rectangles should intersect"
			(rect intersects: newRect) ifTrue: [
				"requestedRect (possibly smaller than newRect) already in. Nothing to do then."
				(rect containsRect: requestedRect) ifTrue: [ 
					^self ].
				"Some rect included in newRect. Remove it and continue, as newRect could still intersect others."
				(newRect containsRect: rect) ifTrue: [
					invalidRects at: index put: nil.	"Effectively like 'invalidRects remove: rect', but without performance penalty."
					indexToReuse ifNil: [ indexToReuse _ index ]].			
				"Merge rectangles if they overlap significantly"
				a _ (rect intersect: newRect) area.
				(a > 40
					and: ["Avoid combining a vertical and horizontal rects.
						  Can make a big diff and we only test when likely."
						  a > (newRect area // 4) or: [ a > (rect area // 4)]])
				ifTrue: [
					"Merge into newRect, as any overlap with forecoming rectangles in the iteration is detected and treated."
					"Before modifying newRect, ensure making a copy: we don't want to break rectangles that belong to someone else (i.e. some morph bounds)"
					newRect == requestedRect ifTrue: [
						newRect _ (rect origin min: newRect origin) corner: (rect corner max: newRect corner) ]
					ifFalse: [
						newRect
							setOrigin: (rect origin min: newRect origin)
							corner: (rect corner max: newRect corner) ].
					invalidRects at: index put: nil.	"Effectively like 'invalidRects remove: rect', but without performance penalty."
					indexToReuse ifNil: [ indexToReuse _ index ]]
				ifFalse: [
					"Avoid intersections!!"
					newRect areasOutside: rect do: [ :nonIntersection |
						"We have brand new newRects. Start all over with each of them."
						self recordInvalidRect: nonIntersection ].
					"newRect no longer needed, then."
					^self ]]]].

	invalidRects size >= 15 ifTrue: [
		"if there are too many separate areas, merge them all"
		mergeRect _ Rectangle merging: invalidRects.
		self reset.
		mergeRect ifNotNil: [
			invalidRects addLast: mergeRect ].
		indexToReuse _ nil ].

	"Ensure making a copy: we don't want to break rectangles that belong to someone else (i.e. some morph bounds)
	(note: no need to send #truncated, because if that was needed, we'd already have a truncated copy!!)"
	newRect == requestedRect ifTrue: [
		newRect _ requestedRect origin corner: requestedRect corner ].
	"add the given rectangle to the damage list"
	indexToReuse
		ifNil: [
			invalidRects addLast: newRect ]
		ifNotNil: [
			invalidRects at: indexToReuse put: newRect ]! !
!MVCMenuMorph methodsFor: 'private' stamp: 'jmv 5/12/2012 23:02' prior: 16884808!
      selectMVCItem: item
	"Called by the MenuItemMorph that the user selects.
	Record the selection and set the done flag to end this interaction."

	mvcSelection _ item.
	done _ true.
! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 5/12/2012 23:03' prior: 16813546!
            deletePackage

	| current cs |
	current _ model selection.
	current ifNil: [ ^self ].
	model selectionIndex: 0.	"no selection"
	cs _ ChangeSet changeSetForPackage: current.
	cs isEmpty ifFalse: [
		cs name: cs hash asString, cs name.
		cs isForBaseSystem: true ].
	CodePackage deregister: current! !
!CodePackageFile methodsFor: 'services' stamp: 'jmv 5/12/2012 23:08' prior: 50343565!
                              install: aFileStream
	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."
	| localName newCodePackage |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].
	
	"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"

	"Crear, instalar y devolver una instancia de PackageInfo"
	newCodePackage_ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: true.
	newCodePackage
		fullFileName: fullName;
		sourceSystem: sourceSystem;
		description: description.

	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"
	"These were created in #fromFileStream: ... reuse?"
	localName _ FileDirectory localNameFor: fullName.
	ChangeSet installing: newCodePackage packageName do: [
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ]].
	newCodePackage hasUnsavedChanges: false.
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSorter removeChangeSet: (ChangeSet changeSetForPackage: newCodePackage).
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	"Tirar undeclared al transcript. warning si quedaron undeclared
	Es feo que tire an transcript undeclareds que despues no lo son..."
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	"Descartar la instancia de CodePackageFile"
	^newCodePackage! !

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #dateStamp!

#(1 0.1 0.01 0.001 0.0001 0.00001 0.000001 0.0000001 0.00000001 0.000000001) collect: [:prec | Utilities decimalPlacesForFloatPrecision: prec]!
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:16'!
                              setAuthor
	"Put up a dialog allowing the user to specify the author's initials.  "

	self setAuthorInitials:
		(FillInTheBlank request: 'Please type your initials: '
					initialAnswer: AuthorInitials)! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:16' prior: 50350116!
                       setAuthor
	"Put up a dialog allowing the user to specify the author's initials.  "
	self setAuthorInitials:
		(FillInTheBlank
			request: 'Please type your initials: '
			initialAnswer: AuthorInitials)! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:18' prior: 50350126!
                       setAuthor
	"Put up a dialog allowing the user to specify the author's initials.  "
	| authorName |
	self setAuthorInitials:
		(FillInTheBlank
			request: 'Please type your initials: '
			initialAnswer: AuthorInitials).
	authorName _ Smalltalk contributorInitialsAndNames
		detect: [ :pair | pair first = AuthorInitials ]
		ifNone: [ { AuthorInitials . FillInTheBlank 
			request: 'Please type your name:'
			initialAnswer: 'Your Name' }].
	authorName print! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:18' prior: 50350136!
                        setAuthor
	"Put up a dialog allowing the user to specify the author's initials.  "
	| authorName |
	self setAuthorInitials:
		(FillInTheBlank
			request: 'Please type your initials: '
			initialAnswer: AuthorInitials).
	authorName _ Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [ {AuthorInitials. FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name'} ].
	authorName print! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:19' prior: 50350154!
                      setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	self setAuthorInitials:
		(FillInTheBlank
			request: 'Please type your initials: '
			initialAnswer: AuthorInitials).
	authorName _ Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [ {AuthorInitials. FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name'} ].
	authorName print! !

	Utilities setAuthor!
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:20' prior: 50350172!
          setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	self setAuthorInitials:
		(FillInTheBlank
			request: 'Please type your initials: '
			initialAnswer: AuthorInitials).
	authorName _ Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [ AuthorName _ FillInTheBlank 
			request: 'Please type your name:'
			initialAnswer: 'Your Name' . ^ self ].
	authorName print! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:20' prior: 50350191!
                              setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	self setAuthorInitials:
		(FillInTheBlank
			request: 'Please type your initials: '
			initialAnswer: AuthorInitials).
	authorName _ Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name'.
			^ self ].
	authorName print! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:20' prior: 50350210!
                        setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	self setAuthorInitials:
		(FillInTheBlank
			request: 'Please type your initials: '
			initialAnswer: AuthorInitials).
	authorName _ (Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name'.
			^ self ]) second.
	authorName print! !

	Utilities setAuthor!
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:21' prior: 50350229!
                        setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	self setAuthorInitials:
		(FillInTheBlank
			request: 'Please type your initials: '
			initialAnswer: AuthorInitials).
	authorName _ (Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name'.
			^ self ]) second.
	(self confirm: 'Are you ', authorName, '?') print! !

	Utilities setAuthor!

	Utilities setAuthor!

PopUpMenu inform: 'I like Cuis'!
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:23' prior: 50350249!
                              setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	self setAuthorInitials:
		(FillInTheBlank
			request: 'Please type your initials: '
			initialAnswer: AuthorInitials).
	authorName _ (Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name'.
			^ self ]) second.
	(self confirm: 'Are you ', authorName, '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [ self inform: 'Please enter different initials, then'. self setAuthor]! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:23' prior: 50350272!
                           setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	self setAuthorInitials:
		(FillInTheBlank
			request: 'Please type your initials: '
			initialAnswer: AuthorInitials).
	authorName _ (Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name'.
			^ self ]) second.
	(self confirm: 'Are you ' , authorName , '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [
			self inform: 'Please enter different initials, then'.
			self setAuthor ]! !

	Utilities setAuthor!

AuthorName!

AuthorInitials!

	Utilities setAuthor!
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980966!
      authorInitials
	"Answer the initials to be used to identify the current code author.  "

	[AuthorInitials isEmpty] whileTrue: [self setAuthor].
	^ AuthorInitials! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980981!
                               authorName
	[AuthorName isEmpty] whileTrue: [self setAuthor].
	^ AuthorName! !

Utilities class removeSelector: #setAuthorName!
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/12/2012 23:25' prior: 16974839!
         helpMenu
        "Build the help menu for the world."
        |  menu |

  	menu := self menu: 'Help...'.

        self fillIn: menu from:
        {
                {'About this System...'. {Smalltalk. #aboutThisSystem}. 'current version information.'}.
                {'Preferences...'. {Preferences. #openPreferencesInspector}. 'view and change various options.'}.
                nil.
               {'Command-key Help'. { Utilities . #openCommandKeyHelp}. 'summary of keyboard shortcuts.'}
	}.

	self addGestureHelpItemsTo: menu.

	self fillIn: menu from:
	{
                {'World menu Help'. { self . #worldMenuHelp}. 'helps find menu items buried in submenus.'}.
                {'Useful Expressions' . { Utilities . #openStandardWorkspace}. 'a window full of useful expressions.'}.
                nil.

                {'Set Author...' . { Utilities . #setAuthor }. 'supply name and initials to be used to identify the author of code and other content.'}.
                {'VM Statistics' . { self . #vmStatistics}.  'obtain some intriguing data about the vm.'}.
			nil.
                {'Space Left' . { self . #garbageCollect}. 'perform a full garbage-collection and report how many bytes of space remain in the image.'}.
        }.

	^menu

! !

Utilities class removeSelector: #setAuthorInitials!
!Theme methodsFor: 'menus' stamp: 'jmv 5/12/2012 23:26' prior: 16975775!
                       miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history') -> #changesIcon.
		#('print PS to file...' ) -> #printIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' ) -> #cancelIcon.
		#('debug...' 'debug it' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'expand all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner') -> #weatherFewCloudsIcon.
		#('system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'what to show...') -> #preferencesIcon.
		#('command-key help') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'profile messages (m)') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance' 'inspect Pointers (P)') -> #instanceIcon.
		#('Use Selection for Find (h)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('update' 'turn on auto-update (a)' 'update list (u)') -> #updateIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...') -> #fontXGenericIcon.
	}! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:27'!
                         clearAuthor
	AuthorInitials _ ''.
	AuthorName _ ''! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 5/12/2012 23:27' prior: 16962604!
        openSourceFiles
	self imageName = LastImageName ifFalse: [
		"Reset the author initials to blank when the image gets moved"
		LastImageName _ self imageName.
		Utilities clearAuthor].
	"Warning: Do open the source files only if nil.
	If not nil, it is because they are internalized and the files should not be opened"
	FileDirectory
		openSources: self defaultSourcesName
		andChanges: self localChangesName
		forImage: LastImageName.
	CuisSourceFileArray install! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:28' prior: 50350296!
                 setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	AuthorInitials _ 
		(FillInTheBlank
			request: 'Please type your initials: '
			initialAnswer: AuthorInitials) withBlanksTrimmed.
	authorName _ (Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ (FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name')withBlanksTrimmed.
			^ self ]) second withBlanksTrimmed.
	(self confirm: 'Are you ' , authorName , '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [
			self inform: 'Please enter different initials, then'.
			self setAuthor ]! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:29' prior: 50350583!
 setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	AuthorInitials _ (FillInTheBlank
		request: 'Please type your initials: '
		initialAnswer: AuthorInitials) withBlanksTrimmed.
	authorName _ (Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ (FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name') withBlanksTrimmed.
			^ self ]) second withBlanksTrimmed.
	(self confirm: 'Are you ' , authorName , '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [
			self inform: 'Please enter different initials, then'.
			self setAuthor ]! !

Utilities class removeSelector: #setAuthorInitials:!

----QUIT/NOSAVE----#(12 May 2012 11:31:29 pm) Cuis4.0-1280.image priorSource: 436066!

----STARTUP----#(12 May 2012 11:31:48 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0-1280.image!


'From Cuis 4.0 of 21 April 2012 [latest update: #4220] on 11 May 2012 at 3:42:03 pm'!
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 5/11/2012 15:40' prior: 50345250!
             endPC
	"Answer the index of the last bytecode."
	| size flagByte |
	"Can't create a zero-sized CompiledMethod so no need to use last for the errorEmptyCollection check.
	 We can reuse size."
	size := self size.
	flagByte := self at: size.
	flagByte = 0 ifTrue: [
		"If last byte = 0, may be either 0, 0, 0, 0 or just 0"
		size-1 to: size-3 by: -1 do: [ :i |
			i < self initialPC ifTrue: [ ^ i ].
			(self at: i) = 0 ifFalse: [ ^ i ]].
		^size - 4].
	flagByte < 252 ifTrue: [
		"Magic sources (temp names encoded in last few bytes)"
		^flagByte <= 127
			ifTrue: [size - flagByte - 1]
			ifFalse: [size - (flagByte - 128 * 128) - (self at: size - 1) - 2]].
	"Normal 4-byte source pointer"
	^size - 4! !

----End fileIn of /Volumes/CANON_DC/Cuis/1280-CuisCore-JuanVuletich-2012May11-15h33m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1280] on 12 May 2012 at 11:31:06 pm'!
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:27'!
                         clearAuthor
	AuthorInitials _ ''.
	AuthorName _ ''! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:29'!
                              setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	AuthorInitials _ (FillInTheBlank
		request: 'Please type your initials: '
		initialAnswer: AuthorInitials) withBlanksTrimmed.
	authorName _ (Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ (FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name') withBlanksTrimmed.
			^ self ]) second withBlanksTrimmed.
	(self confirm: 'Are you ' , authorName , '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [
			self inform: 'Please enter different initials, then'.
			self setAuthor ]! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 5/12/2012 23:27' prior: 16962604!
                               openSourceFiles
	self imageName = LastImageName ifFalse: [
		"Reset the author initials to blank when the image gets moved"
		LastImageName _ self imageName.
		Utilities clearAuthor].
	"Warning: Do open the source files only if nil.
	If not nil, it is because they are internalized and the files should not be opened"
	FileDirectory
		openSources: self defaultSourcesName
		andChanges: self localChangesName
		forImage: LastImageName.
	CuisSourceFileArray install! !
!Theme methodsFor: 'menus' stamp: 'jmv 5/12/2012 23:26' prior: 16975775!
    miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history') -> #changesIcon.
		#('print PS to file...' ) -> #printIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' ) -> #cancelIcon.
		#('debug...' 'debug it' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'expand all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner') -> #weatherFewCloudsIcon.
		#('system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'what to show...') -> #preferencesIcon.
		#('command-key help') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'profile messages (m)') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance' 'inspect Pointers (P)') -> #instanceIcon.
		#('Use Selection for Find (h)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('update' 'turn on auto-update (a)' 'update list (u)') -> #updateIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...') -> #fontXGenericIcon.
	}! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980966!
         authorInitials
	"Answer the initials to be used to identify the current code author.  "

	[AuthorInitials isEmpty] whileTrue: [self setAuthor].
	^ AuthorInitials! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980981!
                               authorName
	[AuthorName isEmpty] whileTrue: [self setAuthor].
	^ AuthorName! !

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #dateStamp!

Utilities class removeSelector: #dateStamp!

Utilities class removeSelector: #setAuthorInitials!

Utilities class removeSelector: #setAuthorInitials!

Utilities class removeSelector: #setAuthorInitials:!

Utilities class removeSelector: #setAuthorInitials:!

Utilities class removeSelector: #setAuthorName!

Utilities class removeSelector: #setAuthorName!

----End fileIn of /Volumes/CANON_DC/Cuis/1282-AuthorNameAndInitialsTweaks-JuanVuletich-2012May12-23h08m-jmv.1.cs----!

Utilities authorInitials !

Utilities authorName!

----QUIT/NOSAVE----#(12 May 2012 11:33:29 pm) Cuis4.0-1280.image priorSource: 436066!

----STARTUP----#(13 May 2012 9:46:32 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0-1280.image!


'From Cuis 4.0 of 21 April 2012 [latest update: #1280] on 12 May 2012 at 11:08:45 pm'!
!CodePackageFile methodsFor: 'services' stamp: 'jmv 5/12/2012 23:08' prior: 50343565!
           install: aFileStream
	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."
	| localName newCodePackage |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].
	
	"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"

	"Crear, instalar y devolver una instancia de PackageInfo"
	newCodePackage_ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: true.
	newCodePackage
		fullFileName: fullName;
		sourceSystem: sourceSystem;
		description: description.

	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"
	"These were created in #fromFileStream: ... reuse?"
	localName _ FileDirectory localNameFor: fullName.
	ChangeSet installing: newCodePackage packageName do: [
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ]].
	newCodePackage hasUnsavedChanges: false.
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSorter removeChangeSet: (ChangeSet changeSetForPackage: newCodePackage).
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	"Tirar undeclared al transcript. warning si quedaron undeclared
	Es feo que tire an transcript undeclareds que despues no lo son..."
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	"Descartar la instancia de CodePackageFile"
	^newCodePackage! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 5/12/2012 23:03' prior: 16813546!
  deletePackage

	| current cs |
	current _ model selection.
	current ifNil: [ ^self ].
	model selectionIndex: 0.	"no selection"
	cs _ ChangeSet changeSetForPackage: current.
	cs isEmpty ifFalse: [
		cs name: cs hash asString, cs name.
		cs isForBaseSystem: true ].
	CodePackage deregister: current! !

----End fileIn of /Volumes/CANON_DC/Cuis/1281-ChangeSetTweaks-JuanVuletich-2012May12-22h55m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1280] on 12 May 2012 at 11:31:06 pm'!
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:27'!
     clearAuthor
	AuthorInitials _ ''.
	AuthorName _ ''! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:29'!
                              setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	AuthorInitials _ (FillInTheBlank
		request: 'Please type your initials: '
		initialAnswer: AuthorInitials) withBlanksTrimmed.
	authorName _ (Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ (FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name') withBlanksTrimmed.
			^ self ]) second withBlanksTrimmed.
	(self confirm: 'Are you ' , authorName , '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [
			self inform: 'Please enter different initials, then'.
			self setAuthor ]! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 5/12/2012 23:27' prior: 16962604!
                               openSourceFiles
	self imageName = LastImageName ifFalse: [
		"Reset the author initials to blank when the image gets moved"
		LastImageName _ self imageName.
		Utilities clearAuthor].
	"Warning: Do open the source files only if nil.
	If not nil, it is because they are internalized and the files should not be opened"
	FileDirectory
		openSources: self defaultSourcesName
		andChanges: self localChangesName
		forImage: LastImageName.
	CuisSourceFileArray install! !
!Theme methodsFor: 'menus' stamp: 'jmv 5/12/2012 23:26' prior: 16975775!
    miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history') -> #changesIcon.
		#('print PS to file...' ) -> #printIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' ) -> #cancelIcon.
		#('debug...' 'debug it' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'expand all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner') -> #weatherFewCloudsIcon.
		#('system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'what to show...') -> #preferencesIcon.
		#('command-key help') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'profile messages (m)') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance' 'inspect Pointers (P)') -> #instanceIcon.
		#('Use Selection for Find (h)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('update' 'turn on auto-update (a)' 'update list (u)') -> #updateIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...') -> #fontXGenericIcon.
	}! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980966!
         authorInitials
	"Answer the initials to be used to identify the current code author.  "

	[AuthorInitials isEmpty] whileTrue: [self setAuthor].
	^ AuthorInitials! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980981!
                               authorName
	[AuthorName isEmpty] whileTrue: [self setAuthor].
	^ AuthorName! !

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #dateStamp!

Utilities class removeSelector: #dateStamp!

Utilities class removeSelector: #setAuthorInitials!

Utilities class removeSelector: #setAuthorInitials!

Utilities class removeSelector: #setAuthorInitials:!

Utilities class removeSelector: #setAuthorInitials:!

Utilities class removeSelector: #setAuthorName!

Utilities class removeSelector: #setAuthorName!

----End fileIn of /Volumes/CANON_DC/Cuis/1282-AuthorNameAndInitialsTweaks-JuanVuletich-2012May12-23h08m-jmv.1.cs----!

ExtraOpenCommands!
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:50' prior: 16974931!
                 openMenu
	"Build the open window menu for the world."

	| menu |
	menu _ self menu: 'Open...'.

	ExtraOpenCommands ifNotNil: [
		self fillIn: menu from: ExtraOpenCommands ].

	self fillIn: menu from: {
		{'Text Editor' . {self . #openTextEditor}. 'A window for composing text' }.
		{'Workspace' . {self . #openWorkspace}. 'A window for evaluating Smalltalk expressions' }.
		{'Browser' . { self . #openBrowser}. 'A Smalltalk code browser, for studying and modifying the system'}.
		{'Message Names' . { self . #openMessageNames} . 'A tool for finding and editing methods that contain any given keyword in their names.'}.
		{'Transcript' . {self . #openTranscript}. 'A window showing contents of the System Transcript' }.
		{'File List' . {self . #openFileList} . 'An explorer of the File System' }.
		nil.
		{'Installed Packages' . { self . #openPackageList}. 'A tool for managing Packages (optional units of code) installed in the system'}.
		{'Change Sorter' . {self . #openChangeSorter1} . 'A tool allowing you to view the methods in a Change Set, especially changes to the Base System' }.
		nil.
		{ 'Process Browser' . { ProcessBrowserWindow . #openProcessBrowser } }.
		{ 'Emergency Evaluator'. { Transcripter. #emergencyEvaluator } }.
		nil.
		{'SUnit Test Runner' . {TestRunnerWindow . #openTestRunner} . 'A tool allowing you to compare and manipulate two change sets concurrently' }.
	}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:51' prior: 50351307!
          openMenu
	"Build the open window menu for the world."

	| menu |
	menu _ self menu: 'Open...'.

	ExtraOpenCommands ifNotNil: [
		self fillIn: menu from: ExtraOpenCommands ].

	self fillIn: menu from: {
		{'Text Editor' . {self . #openTextEditor}. 'A window for composing text' }.
		{'Workspace' . {self . #openWorkspace}. 'A window for evaluating Smalltalk expressions' }.
		{'Browser' . { self . #openBrowser}. 'A Smalltalk code browser, for studying and modifying the system'}.
		{'Message Names' . { self . #openMessageNames} . 'A tool for finding and editing methods that contain any given keyword in their names.'}.
		{'Transcript' . {self . #openTranscript}. 'A window showing contents of the System Transcript' }.
		nil.
		{'Installed Packages' . { self . #openPackageList}. 'A tool for managing Packages (optional units of code) installed in the system'}.
		{'Change Sorter' . {self . #openChangeSorter1} . 'A tool allowing you to view the methods in a Change Set, especially changes to the Base System' }.
		nil.
		{ 'Process Browser' . { ProcessBrowserWindow . #openProcessBrowser } }.
		{ 'Emergency Evaluator'. { Transcripter. #emergencyEvaluator } }.
		nil.
		{'File List' . {self . #openFileList} . 'An explorer of the File System' }.
		{'SUnit Test Runner' . {TestRunnerWindow . #openTestRunner} . 'A tool allowing you to compare and manipulate two change sets concurrently' }.
	}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:55' prior: 16974647!
          buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu := MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: { 
				{ 
					'Restore Display (r)'.
					{ World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil}.
	Preferences simpleMenus 
		ifFalse: 
			[self fillIn: menu
				from: { 
						{ 
							'Open...'.
							{ self. #openWindow}}.
						{ 
							'Windows...'.
							{ self. #windowsDo}}.
						{ 
							'Changes...'.
							{ self. #changesDo}}}].
	self fillIn: menu
		from: { 
				{ 
					'Help...'.
					{ self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 
					'Appearance...'.
					{ self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}}.
	Preferences simpleMenus 
		ifFalse: [
			self fillIn: menu
				from: { 
						{ 
							'Do...'.
							{ Utilities. #offerCommonRequestsInMorphic}.
							'put up an editible list of convenient expressions, and evaluate the one selected.'}}].
	self fillIn: menu
		from: { 
				nil.
				{ 
					'New morph...'.
					{ 
						self.
						#newMorph}.
					'Offers a variety of ways to create new objects'}.
				}.
	Preferences simpleMenus 
		ifFalse: [
			self fillIn: menu
				from: { 
						{ 
							'Debug...'.
							{ self. #debugDo}.
							'a menu of debugging items'}}].
	self fillIn: menu
		from: { 
				nil.
				{ 
					'Save'.
					{ Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 
					'Save as...'.
					{ Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 
					'Save as New Version'.
					{ Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 
					'Save and Quit'.
					{ self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 
					'Quit'.
					{ self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:56' prior: 50351401!
      buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu := MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: { 
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil}.
	Preferences simpleMenus 
		ifFalse: 
			[self fillIn: menu
				from: { 
						{ 'Open...'. { self. #openWindow}}.
						{ 'Windows...'. { self. #windowsDo}}.
						{ 'Changes...'. { self. #changesDo}}}].
	self fillIn: menu
		from: { 
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}}.
	Preferences simpleMenus 
		ifFalse: [
			self fillIn: menu
				from: { 
						{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
							'put up an editible list of convenient expressions, and evaluate the one selected.'}}].
	self fillIn: menu
		from: { 
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				}.
	Preferences simpleMenus 
		ifFalse: [
			self fillIn: menu
				from: { 
						{ 'Debug...'. { self. #debugDo}.
							'a menu of debugging items'}}].
	self fillIn: menu
		from: { 
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:57' prior: 50351473!
 buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu := MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: { 
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil}.
	Preferences simpleMenus 
		ifFalse: 
			[self fillIn: menu
				from: { 
						{ 'Open...'. { self. #openWindow}}.
						{ 'Windows...'. { self. #windowsDo}}.
						{ 'Changes...'. { self. #changesDo}}}].
	self fillIn: menu
		from: { 
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}}.
	self fillIn: menu
		from: { 
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				}.
	Preferences simpleMenus 
		ifFalse: [
			self fillIn: menu
				from: { 
						{ 'Debug...'. { self. #debugDo}.
							'a menu of debugging items'}}].
	Preferences simpleMenus 
		ifFalse: [
			self fillIn: menu
				from: { 
						{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
							'put up an editible list of convenient expressions, and evaluate the one selected.'}}].
	self fillIn: menu
		from: { 
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:57' prior: 50351539!
 buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu := MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: { 
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil}.
	Preferences simpleMenus 
		ifFalse: 
			[self fillIn: menu
				from: { 
						{ 'Open...'. { self. #openWindow}}.
						{ 'Windows...'. { self. #windowsDo}}.
						{ 'Changes...'. { self. #changesDo}}}].
	self fillIn: menu
		from: { 
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}}.
	self fillIn: menu
		from: { 
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				}.
	Preferences simpleMenus 
		ifFalse: [
			self fillIn: menu
				from: { 
						{ 'Debug...'. { self. #debugDo}.
							'a menu of debugging items'}}.
			self fillIn: menu
				from: { 
						{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
							'put up an editible list of convenient expressions, and evaluate the one selected.'}}].
	self fillIn: menu
		from: { 
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:58' prior: 50351605!
         buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu := MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: { 
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil}.
	Preferences simpleMenus 
		ifFalse: 
			[self fillIn: menu
				from: { 
						{ 'Open...'. { self. #openWindow}}.
						{ 'Windows...'. { self. #windowsDo}}.
						{ 'Changes...'. { self. #changesDo}}}].
	self fillIn: menu
		from: { 
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}}.
	self fillIn: menu
		from: { 
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				}.
	Preferences simpleMenus 
		ifFalse: [
			self fillIn: menu
				from: { 
						{ 'Debug...'. { self. #debugDo}.
							'a menu of debugging items'}.
						{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
							'put up an editible list of convenient expressions, and evaluate the one selected.'}}].
	self fillIn: menu
		from: { 
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:58' prior: 50351670!
            buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu := MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: { 
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil}.
	Preferences simpleMenus 
		ifFalse: 
			[self fillIn: menu
				from: { 
						{ 'Open...'. { self. #openWindow}}.
						{ 'Windows...'. { self. #windowsDo}}.
						{ 'Changes...'. { self. #changesDo}}}].
	self fillIn: menu
		from: { 
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}}.
	self fillIn: menu
		from: { 
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'} }.
	Preferences simpleMenus 
		ifFalse: [
			self fillIn: menu
				from: { 
						{ 'Debug...'. { self. #debugDo}.
							'a menu of debugging items'}.
						{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
							'put up an editible list of convenient expressions, and evaluate the one selected.'}}].
	self fillIn: menu
		from: { 
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:58' prior: 50351734!
                 buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu := MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: { 
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil }.
	Preferences simpleMenus 
		ifFalse: [
			self fillIn: menu
				from: { 
						{ 'Open...'. { self. #openWindow}}.
						{ 'Windows...'. { self. #windowsDo}}.
						{ 'Changes...'. { self. #changesDo}}}].
	self fillIn: menu
		from: { 
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}}.
	self fillIn: menu
		from: { 
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'} }.
	Preferences simpleMenus 
		ifFalse: [
			self fillIn: menu
				from: { 
						{ 'Debug...'. { self. #debugDo}.
							'a menu of debugging items'}.
						{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
							'put up an editible list of convenient expressions, and evaluate the one selected.'}}].
	self fillIn: menu
		from: { 
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:59' prior: 50351798!
                buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu := MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: { 
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil }.
	Preferences simpleMenus ifFalse: [
		self fillIn: menu
			from: { 
				{ 'Open...'. { self. #openWindow}}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Changes...'. { self. #changesDo}}}].
	self fillIn: menu
		from: { 
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}}.
	self fillIn: menu
		from: { 
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'} }.
	Preferences simpleMenus ifFalse: [
		self fillIn: menu
			from: { 
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}}].
	self fillIn: menu
		from: { 
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920783!
         cuisDefaults
	"
	Preferences cuisDefaults
	"
	self setPreferencesFrom:

	#(
		(balloonHelpEnabled true)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds false)
		(checkForSlips true)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic false)
		(menuKeyboardControl true)
		(optionalButtons true)
		(extraDebuggerButtons true)
		(smartUpdating true)
		(subPixelRenderFonts true)
		(thoroughSenders true)
	)! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920802!
                  slowMachine

	self setPreferencesFrom: #(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic true)
		(menuKeyboardControl false)
		(optionalButtons false)
		(smartUpdating false)
		(subPixelRenderFonts false)
		(thoroughSenders false)
	).
	ClassicTheme beCurrent! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920820!
                   smalltalk80
	"A traditional monochrome Smalltalk-80 look and feel, clean and austere, and lacking many features added to Squeak in recent years. Caution: this theme removes the standard Squeak flaps, turns off the 'smartUpdating' feature that keeps multiple browsers in synch, and much more."

	self setPreferencesFrom:

	#(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(smartUpdating false)
		(thoroughSenders false)
	)! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:00' prior: 50351862!
                buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu := MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: { 
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Open...'. { self. #openWindow}}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Changes...'. { self. #changesDo}}}.
	self fillIn: menu
		from: { 
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}}.
	self fillIn: menu
		from: { 
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'} }.
	Preferences simpleMenus ifFalse: [
		self fillIn: menu
			from: { 
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}}].
	self fillIn: menu
		from: { 
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:00' prior: 50351986!
               buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu := MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: { 
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Open...'. { self. #openWindow}}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}}.
	self fillIn: menu
		from: { 
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'} }.
	Preferences simpleMenus ifFalse: [
		self fillIn: menu
			from: { 
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}}].
	self fillIn: menu
		from: { 
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:01' prior: 50352047!
              buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu := MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: { 
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Open...'. { self. #openWindow}}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}.
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'} }.
	Preferences simpleMenus ifFalse: [
		self fillIn: menu
			from: { 
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}}].
	self fillIn: menu
		from: { 
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:01' prior: 50352107!
             buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu := MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: { 
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Open...'. { self. #openWindow}}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}.
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}}.
	self fillIn: menu
		from: { 
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:01' prior: 50352166!
                    buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu := MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: { 
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Open...'. { self. #openWindow}}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}.
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:01' prior: 50352223!
                   buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: { 
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Open...'. { self. #openWindow}}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}.
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !

Preferences class removeSelector: #simpleMenus!
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:02' prior: 50352279!
   buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}.
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:02' prior: 50352336!
                              buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}.
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}.
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:02' prior: 50352392!
                              buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Changes...'. { self. #changesDo}}.
				nil.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}.
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:03' prior: 50352448!
                              buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				{ 'Changes...'. { self. #changesDo}}.
				nil.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}.
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:03' prior: 50352504!
                              buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				nil.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}.
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2012 22:05' prior: 16802259!
                       changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu title: 'Change Set'.
	aMenu addStayUpIcons.

	aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove.
	aMenu add: 'File out and keep (k)' 					action: #fileOutAndKeep.
	aMenu add: 'Rename change set (r)' 			action: #rename.
	aMenu add: 'Destroy change set (x)' 			action: #remove.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble.
				aMenu add: 'Remove preamble' 	action: #removePreamble]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 		action: #addPreamble].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript.
				aMenu add: 'Remove postscript' 	action: #removePostscript]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript].
	].
	aMenu addLine.
	aMenu add: 'more...' 							target: self				action: #offerShiftedChangeSetMenu.
	^ aMenu! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2012 22:06' prior: 50352616!
                           changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu title: 'Change Set'.
	aMenu addStayUpIcons.

	aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove.
	aMenu add: 'File out and keep (k)' 					action: #fileOutAndKeep.
	aMenu add: 'Rename change set (r)' 			action: #rename.
	aMenu add: 'Destroy change set (x)' 			action: #remove.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble.
				aMenu add: 'Remove preamble' 	action: #removePreamble]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 		action: #addPreamble].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript.
				aMenu add: 'Remove postscript' 	action: #removePostscript]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript].
	].
	aMenu addLine.

	"CONFLICTS SECTION"
	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.
	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.
	aMenu addLine.

	"CHECKS SECTION"
	aMenu add: 'trim history' target: model action: #trimHistory.
	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes. ',
				'NOTE: can cause confusion if later filed in over an earlier version of these changes'.

	aMenu add: 'view affected class categories' target: model action: #viewAffectedClassCategories.
	aMenu balloonTextForLastItem: ' Show class categories affected by any contained change'.

	^ aMenu! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2012 22:07' prior: 50352656!
 changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu title: 'Change Set'.
	aMenu addStayUpIcons.

	aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove.
	aMenu add: 'File out and keep (k)' 				action: #fileOutAndKeep.
	aMenu addLine.

	aMenu add: 'Rename change set (r)' 			action: #rename.
	aMenu add: 'Destroy change set (x)' 			action: #remove.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble.
				aMenu add: 'Remove preamble' 	action: #removePreamble]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 		action: #addPreamble].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript.
				aMenu add: 'Remove postscript' 	action: #removePostscript]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript].
	].
	aMenu addLine.

	"CONFLICTS SECTION"
	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.
	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.
	aMenu addLine.

	"CHECKS SECTION"
	aMenu add: 'trim history' target: model action: #trimHistory.
	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes. ',
				'NOTE: can cause confusion if later filed in over an earlier version of these changes'.

	aMenu add: 'view affected class categories' target: model action: #viewAffectedClassCategories.
	aMenu balloonTextForLastItem: ' Show class categories affected by any contained change'.

	^ aMenu! !

ChangeSorterWindow removeSelector: #offerShiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #shiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerUnshiftedChangeSetMenu!
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:11' prior: 16802203!
                     buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| changeSetList list2 list3 upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.

	list2 _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: list2 proportionalWidth: 0.5.

	list3 _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: list3 proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:12' prior: 50352783!
                         buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| changeSetList classList list3 upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.5.

	list3 _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: list3 proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:12' prior: 50352837!
             buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.5.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:13' prior: 50352891!
                           buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #changeSetDirtyFlags
		indexGetter: #currentCngSet
		indexSetter: #showChangeSetNamed:.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.5.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:19' prior: 50352946!
                  buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.5.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:19' prior: 50353014!
              buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.5;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.5.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:19' prior: 50353081!
                    buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.4;
		addAdjusterAndMorph: classList proportionalWidth: 0.5.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:20' prior: 50353150!
                    buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
"		listGetter: #changeSetDirtyFlags"
		listGetter: #changeSetList
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.4;
		addAdjusterAndMorph: classList proportionalWidth: 0.5.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:20' prior: 50353219!
                      buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
"		listGetter: #changeSetDirtyFlags"
		listGetter: #changeSetList
		indexGetter: nil
		indexSetter: nil.
"	dirtyFlags color: Color white."
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.4;
		addAdjusterAndMorph: classList proportionalWidth: 0.5.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:20' prior: 50353289!
                    buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
"		listGetter: #changeSetDirtyFlags"
		listGetter: #changeSetList
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.4;
		addAdjusterAndMorph: classList proportionalWidth: 0.5.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:21' prior: 50353359!
                      buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
"		listGetter: #changeSetDirtyFlags"
		listGetter: #changeSetList
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.4;
		addAdjusterAndMorph: classList proportionalWidth: 0.5.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:21' prior: 50353429!
      buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
"		listGetter: #changeSetDirtyFlags"
		listGetter: #changeSetList
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: Color white.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: Color white.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.4;
		addAdjusterAndMorph: classList proportionalWidth: 0.5.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:22' prior: 50353513!
    buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
"		listGetter: #changeSetDirtyFlags"
		listGetter: #changeSetList
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: Color white.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: Color white.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.4;
		addAdjusterAndMorph: classList proportionalWidth: 0.5.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:22' prior: 50353599!
buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
"		listGetter: #changeSetDirtyFlags"
		listGetter: #changeSetList
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: Color white.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: Color white.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.6;
		addAdjusterAndMorph: classList proportionalWidth: 0.3.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:23' prior: 50353685!
buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
"		listGetter: #changeSetDirtyFlags"
		listGetter: #changeSetList
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: Color white.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: Color white.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:23'!
                initialExtent
	^720@480! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:24' prior: 50353771!
        buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
"		listGetter: #changeSetDirtyFlags"
		listGetter: #changeSetList
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: Color white.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: Color white.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: Color white.
	messageList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:26'!
             changeSetDirtyFlags

	^ 9 collect: [ :each |
		each hasUnsavedChanges
			ifTrue: [ '     --->']
			ifFalse: [ '       -' ]]! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:26' prior: 50353955!
        changeSetDirtyFlags

	^ (ChangeSorter allChangeSets collect: [ :each |
		each hasUnsavedChanges
			ifTrue: [ '     --->']
			ifFalse: [ '       -' ]]) reversed! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:27' prior: 50353861!
buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: Color white.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: Color white.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: Color white.
	messageList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:27' prior: 50353970!
                        buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: Color white.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: Color white.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: Color white.
	messageList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:28' prior: 50353962!
                            changeSetDirtyFlags

	^ (ChangeSorter allChangeSets collect: [ :each |
		(each isForBaseSystem and: [ each hasUnsavedChanges ])
			ifTrue: [ '     --->']
			ifFalse: [ '       -' ]]) reversed! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:31' prior: 16801656!
    fileOutAndKeep
	"File out the current change set."

	myChangeSet fileOut.
	self update! !

!classDefinition: #ChangeSorter category: #'Tools-Changes'!
CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:36' prior: 16801780!
          updateIfNecessary
	"Recompute all of my panes."

	| newList |

	myChangeSet ifNil: [^ self].  "Has been known to happen though shouldn't"
	myChangeSet isMoribund ifTrue: [
		self changed: #changeSetList.
		^ self showChangeSet: ChangeSet changeSetForBaseSystem ].

	newList _ self changeSetList.
	(priorChangeSetList == nil or: [priorChangeSetList ~= newList])
		ifTrue: [
			priorChangeSetList _ newList.
			self changed: #changeSetList].

	newList _ self changeSetDirtyFlags.
	(priorDirtyFlags == nil or: [priorDirtyFlags ~= newList])
		ifTrue: [
			priorDirtyFlags _ newList.
			self changed: #changeSetDirtyFlags]! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:37' prior: 50354182!
                          updateIfNecessary
	"Recompute all of my panes."

	| newList |

	myChangeSet ifNil: [^ self].  "Has been known to happen though shouldn't"
	myChangeSet isMoribund ifTrue: [
		self changed: #changeSetList.
		^ self showChangeSet: ChangeSet changeSetForBaseSystem ].

	newList _ self changeSetList.
	(priorChangeSetList == nil or: [priorChangeSetList ~= newList])
		ifTrue: [
			priorChangeSetList _ newList.
			self changed: #changeSetList ].

	newList _ self changeSetDirtyFlags.
	(priorDirtyFlags == nil or: [priorDirtyFlags ~= newList])
		ifTrue: [
			priorDirtyFlags _ newList.
			self changed: #changeSetDirtyFlags ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:42' prior: 16801541!
                  installing: aCodePackageOrChangeSetName do: aBlock

	| currentCS currentCSNumber newHighestUpdate |
	Installing _ 'Install-', aCodePackageOrChangeSetName.
	aBlock ensure: [ Installing _ nil ].

	SystemVersion current registerUpdate: aCodePackageOrChangeSetName.
	newHighestUpdate _  SystemVersion current highestUpdate.

	currentCSNumber _ self currentBaseCSNumber.
	currentCS _ self changeSetForBaseSystem.
	currentCS isEmpty ifTrue: [
		ChangeSorter removeChangeSet: currentCS.
		currentCSNumber > newHighestUpdate ifFalse: [
			CurrentBaseCSNumber _ newHighestUpdate + 1 ]]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:42' prior: 50343502!
                             changeSetForBaseSystem

	| csName numberToUse |
	Installing

		ifNil: [
			numberToUse _ self currentBaseCSNumber.
			ChangeSorter allChangeSets
				detect: [ :any | any name initialIntegerOrNil = numberToUse ]
				ifFound: [ :existing | ^existing ]
				ifNone: [
					csName _ (self baseSystemNameFor: numberToUse),
						(String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ]).
					^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: true ]]

		ifNotNil: [
			csName _ 'Affects-BaseSystem--', Installing.
			^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false
			"Changes are for the base system, but are not user's own changes..." ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:43' prior: 50343527!
            changeSetForPackage: aCodePackage

	| csName |
	aCodePackage ifNil: [
		^self changeSetForBaseSystem ].
	csName _ Installing
		ifNil: [ 'UnsavedChangesTo-', aCodePackage name ]
		ifNotNil: [
			Installing = ('Install-', aCodePackage packageName)
				ifTrue: [ Installing ]
				ifFalse: [ 'Affects-', aCodePackage name, '--', Installing ]].
	^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:45'!
                  runningTest: aTestName do: aBlock

	| |
	Installing _ 'RunningTest-', aTestName.
	aBlock ensure: [ Installing _ nil ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:46' prior: 50354291!
        runningTest: aTestName do: aBlock

	Installing _ 'RunningTest-', aTestName.
	aBlock ensure: [ Installing _ nil ]! !
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 22:46'!
                          array ^ #(nil true false)! !

ArrayLiteralTest removeSelector: #array!
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 22:46'!
       array ^ #(#nil #true #false #'nil' #'true' #'false')! !

ArrayLiteralTest removeSelector: #array!
!a subclass of Theme methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 22:47'!
         	shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 			-> #green.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 			-> #(blue muchDarker).
		#instVar 				-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 		-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 			-> #(gray muchDarker).
	}
! !
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 22:50'!
              array ^ #(nil true false)! !

ArrayLiteralTest removeSelector: #array!
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 22:50'!
       array ^ #(#nil #true #false #'nil' #'true' #'false')! !

ArrayLiteralTest removeSelector: #array!
!a subclass of Theme methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 22:51'!
         	shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 			-> #green.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 			-> #(blue muchDarker).
		#instVar 				-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 		-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 			-> #(gray muchDarker).
	}
! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 5/13/2012 22:51' prior: 16968792!
             runSuite: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ suite run ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
		name: 'TestRunner';
	      priority: Processor userBackgroundPriority;
	      resume.
! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 5/13/2012 22:51' prior: 50344217!
        runSuiteProfiled: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ MessageTally spyOn: [suite run] ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
		name: 'TestRunner';
	      priority: Processor userBackgroundPriority;
	      resume.
! !
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 22:51'!
           array ^ #(nil true false)! !

ArrayLiteralTest removeSelector: #array!
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 22:51'!
       array ^ #(#nil #true #false #'nil' #'true' #'false')! !

ArrayLiteralTest removeSelector: #array!
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 22:51'!
            array ^ #(nil true false)! !

ArrayLiteralTest removeSelector: #array!
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 22:51'!
       array ^ #(#nil #true #false #'nil' #'true' #'false')! !

ArrayLiteralTest removeSelector: #array!

Processor activeProcess name!
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:56'!
                inInstallOrTestRun

	^(Installing isNil or: [
		Processor activeProcess name ~= 'TestRunner' ]) not! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:57' prior: 50354441!
                          inInstallOrTestRun
"
	^(Installing isNil or: [
		Processor activeProcess name ~= 'TestRunner' ]) not"
	Installing notNil and: [ Processor activeProcess name ~= 'TestRunner' ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:57' prior: 50354448!
               inInstallOrTestRun
"
	^(Installing isNil or: [
		Processor activeProcess name ~= 'TestRunner' ]) not"
	^ Installing notNil and: [ Processor activeProcess name ~= 'TestRunner' ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:00' prior: 50354457!
             inInstallOrTestRun
"
	^(Installing isNil or: [
		Processor activeProcess name ~= 'TestRunner' ]) not"
	^ Installing notNil and: [ Processor activeProcess name ~= 'TestRunner' ]
	
	"
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name = 'TestRunner' ]			-> Test
	(Installing beginsWith: Install-')																		-> Install
	Installing isNil 																						-> Normal
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]			-> Normal
	"! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:00'!
                notInstallOrTestRun
"
	^(Installing isNil or: [
		Processor activeProcess name ~= 'TestRunner' ]) not"
	^ Installing notNil and: [ Processor activeProcess name ~= 'TestRunner' ]
	
	"
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name = 'TestRunner' ]			-> Test
	(Installing beginsWith: Install-')																		-> Install
	Installing isNil 																						-> Normal
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]			-> Normal
	"! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:01' prior: 50354485!
                               notInstallOrTestRun

	^Installing isNil or: [
		Processor activeProcess name ~= 'TestRunner' ]
	
	"
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name = 'TestRunner' ]			-> Test
	(Installing beginsWith: Install-')																		-> Install
	Installing isNil 																						-> Normal
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]			-> Normal
	"! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:01' prior: 50354505!
                  notInstallOrTestRun

	^Installing isNil or: [
		(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]]
	
	"
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name = 'TestRunner' ]			-> Test
	(Installing beginsWith: Install-')																		-> Install
	Installing isNil 																						-> Normal
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]			-> Normal
	"! !
!TestCase methodsFor: 'Running' stamp: 'jmv 5/13/2012 23:03' prior: 16968097!
                   run: aResult
	ChangeSet runningTest: self printString do: [
	aResult runCase: self ]
			! !
!TestCase methodsFor: 'Running' stamp: 'jmv 5/13/2012 23:03' prior: 50354540!
                      run: aResult
	ChangeSet
		runningTest: self printString
		do: [ aResult runCase: self ]
			! !
!TestCase methodsFor: 'Running' stamp: 'jmv 5/13/2012 23:04' prior: 50354546!
                   run: aResult
	ChangeSet
		runningTest: self printString
		do: [ aResult runCase: self ]
			! !
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 23:04'!
               array ^ #(nil true false)! !

ArrayLiteralTest removeSelector: #array!
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 23:04'!
       array ^ #(#nil #true #false #'nil' #'true' #'false')! !

ArrayLiteralTest removeSelector: #array!
!a subclass of Theme methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 23:04'!
         	shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 			-> #green.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 			-> #(blue muchDarker).
		#instVar 				-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 		-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 			-> #(gray muchDarker).
	}
! !
!TestCase methodsFor: 'Running' stamp: 'jmv 5/13/2012 23:05' prior: 50354552!
                  run: aResult
	ChangeSet
		runningTest: self printString
		do: [ aResult runCase: self ]
			! !
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 23:05'!
               array ^ #(nil true false)! !

ArrayLiteralTest removeSelector: #array!
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 23:05'!
       array ^ #(#nil #true #false #'nil' #'true' #'false')! !

ArrayLiteralTest removeSelector: #array!
!a subclass of Theme methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 23:05'!
         	shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 			-> #green.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 			-> #(blue muchDarker).
		#instVar 				-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 		-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 			-> #(gray muchDarker).
	}
! !

----QUIT/NOSAVE----#(13 May 2012 11:05:51 pm) Cuis4.0-1280.image priorSource: 436066!

----STARTUP----#(13 May 2012 11:05:56 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0-1280.image!


'From Cuis 4.0 of 21 April 2012 [latest update: #1280] on 12 May 2012 at 11:08:45 pm'!
!CodePackageFile methodsFor: 'services' stamp: 'jmv 5/12/2012 23:08' prior: 50343565!
 install: aFileStream
	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."
	| localName newCodePackage |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].
	
	"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"

	"Crear, instalar y devolver una instancia de PackageInfo"
	newCodePackage_ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: true.
	newCodePackage
		fullFileName: fullName;
		sourceSystem: sourceSystem;
		description: description.

	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"
	"These were created in #fromFileStream: ... reuse?"
	localName _ FileDirectory localNameFor: fullName.
	ChangeSet installing: newCodePackage packageName do: [
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ]].
	newCodePackage hasUnsavedChanges: false.
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSorter removeChangeSet: (ChangeSet changeSetForPackage: newCodePackage).
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	"Tirar undeclared al transcript. warning si quedaron undeclared
	Es feo que tire an transcript undeclareds que despues no lo son..."
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	"Descartar la instancia de CodePackageFile"
	^newCodePackage! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 5/12/2012 23:03' prior: 16813546!
  deletePackage

	| current cs |
	current _ model selection.
	current ifNil: [ ^self ].
	model selectionIndex: 0.	"no selection"
	cs _ ChangeSet changeSetForPackage: current.
	cs isEmpty ifFalse: [
		cs name: cs hash asString, cs name.
		cs isForBaseSystem: true ].
	CodePackage deregister: current! !

----End fileIn of /Volumes/CANON_DC/Cuis/1281-ChangeSetTweaks-JuanVuletich-2012May12-22h55m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1280] on 12 May 2012 at 11:31:06 pm'!
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:27'!
     clearAuthor
	AuthorInitials _ ''.
	AuthorName _ ''! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:29'!
                              setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	AuthorInitials _ (FillInTheBlank
		request: 'Please type your initials: '
		initialAnswer: AuthorInitials) withBlanksTrimmed.
	authorName _ (Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ (FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name') withBlanksTrimmed.
			^ self ]) second withBlanksTrimmed.
	(self confirm: 'Are you ' , authorName , '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [
			self inform: 'Please enter different initials, then'.
			self setAuthor ]! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 5/12/2012 23:27' prior: 16962604!
                               openSourceFiles
	self imageName = LastImageName ifFalse: [
		"Reset the author initials to blank when the image gets moved"
		LastImageName _ self imageName.
		Utilities clearAuthor].
	"Warning: Do open the source files only if nil.
	If not nil, it is because they are internalized and the files should not be opened"
	FileDirectory
		openSources: self defaultSourcesName
		andChanges: self localChangesName
		forImage: LastImageName.
	CuisSourceFileArray install! !
!Theme methodsFor: 'menus' stamp: 'jmv 5/12/2012 23:26' prior: 16975775!
    miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history') -> #changesIcon.
		#('print PS to file...' ) -> #printIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' ) -> #cancelIcon.
		#('debug...' 'debug it' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'expand all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner') -> #weatherFewCloudsIcon.
		#('system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'what to show...') -> #preferencesIcon.
		#('command-key help') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'profile messages (m)') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance' 'inspect Pointers (P)') -> #instanceIcon.
		#('Use Selection for Find (h)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('update' 'turn on auto-update (a)' 'update list (u)') -> #updateIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...') -> #fontXGenericIcon.
	}! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980966!
         authorInitials
	"Answer the initials to be used to identify the current code author.  "

	[AuthorInitials isEmpty] whileTrue: [self setAuthor].
	^ AuthorInitials! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980981!
                               authorName
	[AuthorName isEmpty] whileTrue: [self setAuthor].
	^ AuthorName! !

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #dateStamp!

Utilities class removeSelector: #dateStamp!

Utilities class removeSelector: #setAuthorInitials!

Utilities class removeSelector: #setAuthorInitials!

Utilities class removeSelector: #setAuthorInitials:!

Utilities class removeSelector: #setAuthorInitials:!

Utilities class removeSelector: #setAuthorName!

Utilities class removeSelector: #setAuthorName!

----End fileIn of /Volumes/CANON_DC/Cuis/1282-AuthorNameAndInitialsTweaks-JuanVuletich-2012May12-23h08m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1282] on 13 May 2012 at 10:08:55 pm'!
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2012 22:07' prior: 16802259!
      changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu title: 'Change Set'.
	aMenu addStayUpIcons.

	aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove.
	aMenu add: 'File out and keep (k)' 				action: #fileOutAndKeep.
	aMenu addLine.

	aMenu add: 'Rename change set (r)' 			action: #rename.
	aMenu add: 'Destroy change set (x)' 			action: #remove.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble.
				aMenu add: 'Remove preamble' 	action: #removePreamble]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 		action: #addPreamble].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript.
				aMenu add: 'Remove postscript' 	action: #removePostscript]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript].
	].
	aMenu addLine.

	"CONFLICTS SECTION"
	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.
	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.
	aMenu addLine.

	"CHECKS SECTION"
	aMenu add: 'trim history' target: model action: #trimHistory.
	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes. ',
				'NOTE: can cause confusion if later filed in over an earlier version of these changes'.

	aMenu add: 'view affected class categories' target: model action: #viewAffectedClassCategories.
	aMenu balloonTextForLastItem: ' Show class categories affected by any contained change'.

	^ aMenu! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920783!
                         cuisDefaults
	"
	Preferences cuisDefaults
	"
	self setPreferencesFrom:

	#(
		(balloonHelpEnabled true)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds false)
		(checkForSlips true)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic false)
		(menuKeyboardControl true)
		(optionalButtons true)
		(extraDebuggerButtons true)
		(smartUpdating true)
		(subPixelRenderFonts true)
		(thoroughSenders true)
	)! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920802!
                  slowMachine

	self setPreferencesFrom: #(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic true)
		(menuKeyboardControl false)
		(optionalButtons false)
		(smartUpdating false)
		(subPixelRenderFonts false)
		(thoroughSenders false)
	).
	ClassicTheme beCurrent! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920820!
                   smalltalk80
	"A traditional monochrome Smalltalk-80 look and feel, clean and austere, and lacking many features added to Squeak in recent years. Caution: this theme removes the standard Squeak flaps, turns off the 'smartUpdating' feature that keeps multiple browsers in synch, and much more."

	self setPreferencesFrom:

	#(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(smartUpdating false)
		(thoroughSenders false)
	)! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:03' prior: 16974647!
                buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				nil.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}.
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:51' prior: 16974931!
                              openMenu
	"Build the open window menu for the world."

	| menu |
	menu _ self menu: 'Open...'.

	ExtraOpenCommands ifNotNil: [
		self fillIn: menu from: ExtraOpenCommands ].

	self fillIn: menu from: {
		{'Text Editor' . {self . #openTextEditor}. 'A window for composing text' }.
		{'Workspace' . {self . #openWorkspace}. 'A window for evaluating Smalltalk expressions' }.
		{'Browser' . { self . #openBrowser}. 'A Smalltalk code browser, for studying and modifying the system'}.
		{'Message Names' . { self . #openMessageNames} . 'A tool for finding and editing methods that contain any given keyword in their names.'}.
		{'Transcript' . {self . #openTranscript}. 'A window showing contents of the System Transcript' }.
		nil.
		{'Installed Packages' . { self . #openPackageList}. 'A tool for managing Packages (optional units of code) installed in the system'}.
		{'Change Sorter' . {self . #openChangeSorter1} . 'A tool allowing you to view the methods in a Change Set, especially changes to the Base System' }.
		nil.
		{ 'Process Browser' . { ProcessBrowserWindow . #openProcessBrowser } }.
		{ 'Emergency Evaluator'. { Transcripter. #emergencyEvaluator } }.
		nil.
		{'File List' . {self . #openFileList} . 'An explorer of the File System' }.
		{'SUnit Test Runner' . {TestRunnerWindow . #openTestRunner} . 'A tool allowing you to compare and manipulate two change sets concurrently' }.
	}.
	^menu! !

Preferences class removeSelector: #simpleMenus!

Preferences class removeSelector: #simpleMenus!

ChangeSorterWindow removeSelector: #offerShiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerShiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerUnshiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerUnshiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #shiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #shiftedChangeSetMenu!

----End fileIn of /Volumes/CANON_DC/Cuis/1283-MenuTweaks-JuanVuletich-2012May13-21h47m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1282] on 13 May 2012 at 10:38:14 pm'!

!classDefinition: #ChangeSorter category: #'Tools-Changes'!
CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags '
	classVariableNames: 'AllChangeSets '
	poolDictionaries: ''
	category: 'Tools-Changes'!
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:28'!
                  changeSetDirtyFlags

	^ (ChangeSorter allChangeSets collect: [ :each |
		(each isForBaseSystem and: [ each hasUnsavedChanges ])
			ifTrue: [ '     --->']
			ifFalse: [ '       -' ]]) reversed! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:23'!
                initialExtent
	^720@480! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:31' prior: 16801656!
            fileOutAndKeep
	"File out the current change set."

	myChangeSet fileOut.
	self update! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:37' prior: 16801780!
             updateIfNecessary
	"Recompute all of my panes."

	| newList |

	myChangeSet ifNil: [^ self].  "Has been known to happen though shouldn't"
	myChangeSet isMoribund ifTrue: [
		self changed: #changeSetList.
		^ self showChangeSet: ChangeSet changeSetForBaseSystem ].

	newList _ self changeSetList.
	(priorChangeSetList == nil or: [priorChangeSetList ~= newList])
		ifTrue: [
			priorChangeSetList _ newList.
			self changed: #changeSetList ].

	newList _ self changeSetDirtyFlags.
	(priorDirtyFlags == nil or: [priorDirtyFlags ~= newList])
		ifTrue: [
			priorDirtyFlags _ newList.
			self changed: #changeSetDirtyFlags ]! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:27' prior: 16802203!
                    buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: Color white.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: Color white.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: Color white.
	messageList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !

!classDefinition: #ChangeSorter category: #'Tools-Changes'!
CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

----End fileIn of /Volumes/CANON_DC/Cuis/1284-DirtyFlagVisibleInChangeSorter-JuanVuletich-2012May13-22h08m-jmv.6.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1282] on 13 May 2012 at 11:05:07 pm'!
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:00'!
          inInstallOrTestRun
"
	^(Installing isNil or: [
		Processor activeProcess name ~= 'TestRunner' ]) not"
	^ Installing notNil and: [ Processor activeProcess name ~= 'TestRunner' ]
	
	"
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name = 'TestRunner' ]			-> Test
	(Installing beginsWith: Install-')																		-> Install
	Installing isNil 																						-> Normal
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]			-> Normal
	"! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:01'!
                notInstallOrTestRun

	^Installing isNil or: [
		(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]]
	
	"
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name = 'TestRunner' ]			-> Test
	(Installing beginsWith: Install-')																		-> Install
	Installing isNil 																						-> Normal
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]			-> Normal
	"! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:46'!
                  runningTest: aTestName do: aBlock

	Installing _ 'RunningTest-', aTestName.
	aBlock ensure: [ Installing _ nil ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:42' prior: 50343502!
             changeSetForBaseSystem

	| csName numberToUse |
	Installing

		ifNil: [
			numberToUse _ self currentBaseCSNumber.
			ChangeSorter allChangeSets
				detect: [ :any | any name initialIntegerOrNil = numberToUse ]
				ifFound: [ :existing | ^existing ]
				ifNone: [
					csName _ (self baseSystemNameFor: numberToUse),
						(String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ]).
					^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: true ]]

		ifNotNil: [
			csName _ 'Affects-BaseSystem--', Installing.
			^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false
			"Changes are for the base system, but are not user's own changes..." ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:43' prior: 50343527!
            changeSetForPackage: aCodePackage

	| csName |
	aCodePackage ifNil: [
		^self changeSetForBaseSystem ].
	csName _ Installing
		ifNil: [ 'UnsavedChangesTo-', aCodePackage name ]
		ifNotNil: [
			Installing = ('Install-', aCodePackage packageName)
				ifTrue: [ Installing ]
				ifFalse: [ 'Affects-', aCodePackage name, '--', Installing ]].
	^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:42' prior: 16801541!
  installing: aCodePackageOrChangeSetName do: aBlock

	| currentCS currentCSNumber newHighestUpdate |
	Installing _ 'Install-', aCodePackageOrChangeSetName.
	aBlock ensure: [ Installing _ nil ].

	SystemVersion current registerUpdate: aCodePackageOrChangeSetName.
	newHighestUpdate _  SystemVersion current highestUpdate.

	currentCSNumber _ self currentBaseCSNumber.
	currentCS _ self changeSetForBaseSystem.
	currentCS isEmpty ifTrue: [
		ChangeSorter removeChangeSet: currentCS.
		currentCSNumber > newHighestUpdate ifFalse: [
			CurrentBaseCSNumber _ newHighestUpdate + 1 ]]! !
!TestCase methodsFor: 'Running' stamp: 'jmv 5/13/2012 23:05' prior: 16968097!
              run: aResult
	ChangeSet
		runningTest: self printString
		do: [ aResult runCase: self ]
			! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 5/13/2012 22:51' prior: 16968792!
              runSuite: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ suite run ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
		name: 'TestRunner';
	      priority: Processor userBackgroundPriority;
	      resume.
! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 5/13/2012 22:51' prior: 50344217!
        runSuiteProfiled: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ MessageTally spyOn: [suite run] ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
		name: 'TestRunner';
	      priority: Processor userBackgroundPriority;
	      resume.
! !

----End fileIn of /Volumes/CANON_DC/Cuis/1285-CuisCore-JuanVuletich-2012May13-22h38m-jmv.3.cs----!

----QUIT/NOSAVE----#(13 May 2012 11:08:32 pm) Cuis4.0-1280.image priorSource: 436066!

----STARTUP----#(13 May 2012 11:08:43 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0-1280.image!


'From Cuis 4.0 of 21 April 2012 [latest update: #1280] on 12 May 2012 at 11:08:45 pm'!
!CodePackageFile methodsFor: 'services' stamp: 'jmv 5/12/2012 23:08' prior: 50343565!
                          install: aFileStream
	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."
	| localName newCodePackage |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].
	
	"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"

	"Crear, instalar y devolver una instancia de PackageInfo"
	newCodePackage_ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: true.
	newCodePackage
		fullFileName: fullName;
		sourceSystem: sourceSystem;
		description: description.

	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"
	"These were created in #fromFileStream: ... reuse?"
	localName _ FileDirectory localNameFor: fullName.
	ChangeSet installing: newCodePackage packageName do: [
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ]].
	newCodePackage hasUnsavedChanges: false.
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSorter removeChangeSet: (ChangeSet changeSetForPackage: newCodePackage).
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	"Tirar undeclared al transcript. warning si quedaron undeclared
	Es feo que tire an transcript undeclareds que despues no lo son..."
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	"Descartar la instancia de CodePackageFile"
	^newCodePackage! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 5/12/2012 23:03' prior: 16813546!
  deletePackage

	| current cs |
	current _ model selection.
	current ifNil: [ ^self ].
	model selectionIndex: 0.	"no selection"
	cs _ ChangeSet changeSetForPackage: current.
	cs isEmpty ifFalse: [
		cs name: cs hash asString, cs name.
		cs isForBaseSystem: true ].
	CodePackage deregister: current! !

----End fileIn of /Volumes/CANON_DC/Cuis/1281-ChangeSetTweaks-JuanVuletich-2012May12-22h55m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1280] on 12 May 2012 at 11:31:06 pm'!
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:27'!
     clearAuthor
	AuthorInitials _ ''.
	AuthorName _ ''! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:29'!
                              setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	AuthorInitials _ (FillInTheBlank
		request: 'Please type your initials: '
		initialAnswer: AuthorInitials) withBlanksTrimmed.
	authorName _ (Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ (FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name') withBlanksTrimmed.
			^ self ]) second withBlanksTrimmed.
	(self confirm: 'Are you ' , authorName , '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [
			self inform: 'Please enter different initials, then'.
			self setAuthor ]! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 5/12/2012 23:27' prior: 16962604!
                               openSourceFiles
	self imageName = LastImageName ifFalse: [
		"Reset the author initials to blank when the image gets moved"
		LastImageName _ self imageName.
		Utilities clearAuthor].
	"Warning: Do open the source files only if nil.
	If not nil, it is because they are internalized and the files should not be opened"
	FileDirectory
		openSources: self defaultSourcesName
		andChanges: self localChangesName
		forImage: LastImageName.
	CuisSourceFileArray install! !
!Theme methodsFor: 'menus' stamp: 'jmv 5/12/2012 23:26' prior: 16975775!
    miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history') -> #changesIcon.
		#('print PS to file...' ) -> #printIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' ) -> #cancelIcon.
		#('debug...' 'debug it' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'expand all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner') -> #weatherFewCloudsIcon.
		#('system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'what to show...') -> #preferencesIcon.
		#('command-key help') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'profile messages (m)') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance' 'inspect Pointers (P)') -> #instanceIcon.
		#('Use Selection for Find (h)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('update' 'turn on auto-update (a)' 'update list (u)') -> #updateIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...') -> #fontXGenericIcon.
	}! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980966!
         authorInitials
	"Answer the initials to be used to identify the current code author.  "

	[AuthorInitials isEmpty] whileTrue: [self setAuthor].
	^ AuthorInitials! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980981!
                               authorName
	[AuthorName isEmpty] whileTrue: [self setAuthor].
	^ AuthorName! !

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #dateStamp!

Utilities class removeSelector: #dateStamp!

Utilities class removeSelector: #setAuthorInitials!

Utilities class removeSelector: #setAuthorInitials!

Utilities class removeSelector: #setAuthorInitials:!

Utilities class removeSelector: #setAuthorInitials:!

Utilities class removeSelector: #setAuthorName!

Utilities class removeSelector: #setAuthorName!

----End fileIn of /Volumes/CANON_DC/Cuis/1282-AuthorNameAndInitialsTweaks-JuanVuletich-2012May12-23h08m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1282] on 13 May 2012 at 10:08:55 pm'!
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2012 22:07' prior: 16802259!
      changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu title: 'Change Set'.
	aMenu addStayUpIcons.

	aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove.
	aMenu add: 'File out and keep (k)' 				action: #fileOutAndKeep.
	aMenu addLine.

	aMenu add: 'Rename change set (r)' 			action: #rename.
	aMenu add: 'Destroy change set (x)' 			action: #remove.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble.
				aMenu add: 'Remove preamble' 	action: #removePreamble]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 		action: #addPreamble].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript.
				aMenu add: 'Remove postscript' 	action: #removePostscript]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript].
	].
	aMenu addLine.

	"CONFLICTS SECTION"
	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.
	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.
	aMenu addLine.

	"CHECKS SECTION"
	aMenu add: 'trim history' target: model action: #trimHistory.
	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes. ',
				'NOTE: can cause confusion if later filed in over an earlier version of these changes'.

	aMenu add: 'view affected class categories' target: model action: #viewAffectedClassCategories.
	aMenu balloonTextForLastItem: ' Show class categories affected by any contained change'.

	^ aMenu! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920783!
                         cuisDefaults
	"
	Preferences cuisDefaults
	"
	self setPreferencesFrom:

	#(
		(balloonHelpEnabled true)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds false)
		(checkForSlips true)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic false)
		(menuKeyboardControl true)
		(optionalButtons true)
		(extraDebuggerButtons true)
		(smartUpdating true)
		(subPixelRenderFonts true)
		(thoroughSenders true)
	)! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920802!
                  slowMachine

	self setPreferencesFrom: #(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic true)
		(menuKeyboardControl false)
		(optionalButtons false)
		(smartUpdating false)
		(subPixelRenderFonts false)
		(thoroughSenders false)
	).
	ClassicTheme beCurrent! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920820!
                   smalltalk80
	"A traditional monochrome Smalltalk-80 look and feel, clean and austere, and lacking many features added to Squeak in recent years. Caution: this theme removes the standard Squeak flaps, turns off the 'smartUpdating' feature that keeps multiple browsers in synch, and much more."

	self setPreferencesFrom:

	#(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(smartUpdating false)
		(thoroughSenders false)
	)! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:03' prior: 16974647!
                buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				nil.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}.
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:51' prior: 16974931!
                              openMenu
	"Build the open window menu for the world."

	| menu |
	menu _ self menu: 'Open...'.

	ExtraOpenCommands ifNotNil: [
		self fillIn: menu from: ExtraOpenCommands ].

	self fillIn: menu from: {
		{'Text Editor' . {self . #openTextEditor}. 'A window for composing text' }.
		{'Workspace' . {self . #openWorkspace}. 'A window for evaluating Smalltalk expressions' }.
		{'Browser' . { self . #openBrowser}. 'A Smalltalk code browser, for studying and modifying the system'}.
		{'Message Names' . { self . #openMessageNames} . 'A tool for finding and editing methods that contain any given keyword in their names.'}.
		{'Transcript' . {self . #openTranscript}. 'A window showing contents of the System Transcript' }.
		nil.
		{'Installed Packages' . { self . #openPackageList}. 'A tool for managing Packages (optional units of code) installed in the system'}.
		{'Change Sorter' . {self . #openChangeSorter1} . 'A tool allowing you to view the methods in a Change Set, especially changes to the Base System' }.
		nil.
		{ 'Process Browser' . { ProcessBrowserWindow . #openProcessBrowser } }.
		{ 'Emergency Evaluator'. { Transcripter. #emergencyEvaluator } }.
		nil.
		{'File List' . {self . #openFileList} . 'An explorer of the File System' }.
		{'SUnit Test Runner' . {TestRunnerWindow . #openTestRunner} . 'A tool allowing you to compare and manipulate two change sets concurrently' }.
	}.
	^menu! !

Preferences class removeSelector: #simpleMenus!

Preferences class removeSelector: #simpleMenus!

ChangeSorterWindow removeSelector: #offerShiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerShiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerUnshiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerUnshiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #shiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #shiftedChangeSetMenu!

----End fileIn of /Volumes/CANON_DC/Cuis/1283-MenuTweaks-JuanVuletich-2012May13-21h47m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1282] on 13 May 2012 at 10:38:14 pm'!

!classDefinition: #ChangeSorter category: #'Tools-Changes'!
CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags '
	classVariableNames: 'AllChangeSets '
	poolDictionaries: ''
	category: 'Tools-Changes'!
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:28'!
                  changeSetDirtyFlags

	^ (ChangeSorter allChangeSets collect: [ :each |
		(each isForBaseSystem and: [ each hasUnsavedChanges ])
			ifTrue: [ '     --->']
			ifFalse: [ '       -' ]]) reversed! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:23'!
                initialExtent
	^720@480! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:31' prior: 16801656!
            fileOutAndKeep
	"File out the current change set."

	myChangeSet fileOut.
	self update! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:37' prior: 16801780!
             updateIfNecessary
	"Recompute all of my panes."

	| newList |

	myChangeSet ifNil: [^ self].  "Has been known to happen though shouldn't"
	myChangeSet isMoribund ifTrue: [
		self changed: #changeSetList.
		^ self showChangeSet: ChangeSet changeSetForBaseSystem ].

	newList _ self changeSetList.
	(priorChangeSetList == nil or: [priorChangeSetList ~= newList])
		ifTrue: [
			priorChangeSetList _ newList.
			self changed: #changeSetList ].

	newList _ self changeSetDirtyFlags.
	(priorDirtyFlags == nil or: [priorDirtyFlags ~= newList])
		ifTrue: [
			priorDirtyFlags _ newList.
			self changed: #changeSetDirtyFlags ]! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:27' prior: 16802203!
                    buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: Color white.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: Color white.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: Color white.
	messageList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !

!classDefinition: #ChangeSorter category: #'Tools-Changes'!
CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

----End fileIn of /Volumes/CANON_DC/Cuis/1284-DirtyFlagVisibleInChangeSorter-JuanVuletich-2012May13-22h08m-jmv.6.cs----!
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:46'!
  runningTest: aTestName do: aBlock

	Installing _ 'RunningTest-', aTestName.
	aBlock ensure: [ Installing _ nil ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:42' prior: 50343502!
             changeSetForBaseSystem

	| csName numberToUse |
	Installing

		ifNil: [
			numberToUse _ self currentBaseCSNumber.
			ChangeSorter allChangeSets
				detect: [ :any | any name initialIntegerOrNil = numberToUse ]
				ifFound: [ :existing | ^existing ]
				ifNone: [
					csName _ (self baseSystemNameFor: numberToUse),
						(String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ]).
					^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: true ]]

		ifNotNil: [
			csName _ 'Affects-BaseSystem--', Installing.
			^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false
			"Changes are for the base system, but are not user's own changes..." ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:43' prior: 50343527!
            changeSetForPackage: aCodePackage

	| csName |
	aCodePackage ifNil: [
		^self changeSetForBaseSystem ].
	csName _ Installing
		ifNil: [ 'UnsavedChangesTo-', aCodePackage name ]
		ifNotNil: [
			Installing = ('Install-', aCodePackage packageName)
				ifTrue: [ Installing ]
				ifFalse: [ 'Affects-', aCodePackage name, '--', Installing ]].
	^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:42' prior: 16801541!
  installing: aCodePackageOrChangeSetName do: aBlock

	| currentCS currentCSNumber newHighestUpdate |
	Installing _ 'Install-', aCodePackageOrChangeSetName.
	aBlock ensure: [ Installing _ nil ].

	SystemVersion current registerUpdate: aCodePackageOrChangeSetName.
	newHighestUpdate _  SystemVersion current highestUpdate.

	currentCSNumber _ self currentBaseCSNumber.
	currentCS _ self changeSetForBaseSystem.
	currentCS isEmpty ifTrue: [
		ChangeSorter removeChangeSet: currentCS.
		currentCSNumber > newHighestUpdate ifFalse: [
			CurrentBaseCSNumber _ newHighestUpdate + 1 ]]! !
!TestCase methodsFor: 'Running' stamp: 'jmv 5/13/2012 23:05' prior: 16968097!
              run: aResult
	ChangeSet
		runningTest: self printString
		do: [ aResult runCase: self ]
			! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 5/13/2012 22:51' prior: 16968792!
              runSuite: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ suite run ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
		name: 'TestRunner';
	      priority: Processor userBackgroundPriority;
	      resume.
! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 5/13/2012 22:51' prior: 50344217!
        runSuiteProfiled: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ MessageTally spyOn: [suite run] ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
		name: 'TestRunner';
	      priority: Processor userBackgroundPriority;
	      resume.
! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:01'!
              notInstallOrTestRun

	^Installing isNil or: [
		(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]]
	
	"
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name = 'TestRunner' ]			-> Test
	(Installing beginsWith: Install-')																		-> Install
	Installing isNil 																						-> Normal
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]			-> Normal
	"! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:10' prior: 50356371!
  changeSetForBaseSystem

	| csName numberToUse |
	self notInstallOrTestRun
		ifTrue: [
			numberToUse _ self currentBaseCSNumber.
			ChangeSorter allChangeSets
				detect: [ :any | any name initialIntegerOrNil = numberToUse ]
				ifFound: [ :existing | ^existing ]
				ifNone: [
					csName _ (self baseSystemNameFor: numberToUse),
						(String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ]).
					^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: true ]]

		ifFalse: [
			csName _ 'Affects-BaseSystem--', Installing.
			^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false
			"Changes are for the base system, but are not user's own changes..." ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:11' prior: 50356396!
                               changeSetForPackage: aCodePackage

	| csName |
	aCodePackage ifNil: [
		^self changeSetForBaseSystem ].
	csName _ 	self notInstallOrTestRun
		ifTrue: [ 'UnsavedChangesTo-', aCodePackage name ]
		ifFalse: [
			Installing = ('Install-', aCodePackage packageName)
				ifTrue: [ Installing ]
				ifFalse: [ 'Affects-', aCodePackage name, '--', Installing ]].
	^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false! !
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 23:12'!
array ^ #(nil true false)! !

ArrayLiteralTest removeSelector: #array!
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 23:12'!
       array ^ #(#nil #true #false #'nil' #'true' #'false')! !

ArrayLiteralTest removeSelector: #array!
!Morph methodsFor: 'menus' stamp: 'jmv 5/13/2012 23:12' prior: 16898517!
                     addAddHandMenuItemsForHalo: aMenu hand: aHandMorph
	"The former charter of this method was to add halo menu items that pertained specifically to the hand.  Over time this charter has withered, and most morphs reimplement this method simply to add their morph-specific menu items.  So in the latest round, all other implementors in the standard image have been removed.  However, this is left here as a hook for the benefit of existing code in client uses."

 ! !
!a subclass of Theme methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2012 23:12'!
                            	shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 			-> #green.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 			-> #(blue muchDarker).
		#instVar 				-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 		-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 			-> #(gray muchDarker).
	}
! !

----QUIT/NOSAVE----#(13 May 2012 11:13:09 pm) Cuis4.0-1280.image priorSource: 436066!

----STARTUP----#(14 May 2012 9:20:07 am) as /Volumes/CANON_DC/Cuis/Cuis4.0-1280.image!


'From Cuis 4.0 of 21 April 2012 [latest update: #1280] on 12 May 2012 at 11:08:45 pm'!
!CodePackageFile methodsFor: 'services' stamp: 'jmv 5/12/2012 23:08' prior: 50343565!
  install: aFileStream
	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."
	| localName newCodePackage |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].
	
	"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"

	"Crear, instalar y devolver una instancia de PackageInfo"
	newCodePackage_ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: true.
	newCodePackage
		fullFileName: fullName;
		sourceSystem: sourceSystem;
		description: description.

	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"
	"These were created in #fromFileStream: ... reuse?"
	localName _ FileDirectory localNameFor: fullName.
	ChangeSet installing: newCodePackage packageName do: [
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ]].
	newCodePackage hasUnsavedChanges: false.
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSorter removeChangeSet: (ChangeSet changeSetForPackage: newCodePackage).
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	"Tirar undeclared al transcript. warning si quedaron undeclared
	Es feo que tire an transcript undeclareds que despues no lo son..."
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	"Descartar la instancia de CodePackageFile"
	^newCodePackage! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 5/12/2012 23:03' prior: 16813546!
  deletePackage

	| current cs |
	current _ model selection.
	current ifNil: [ ^self ].
	model selectionIndex: 0.	"no selection"
	cs _ ChangeSet changeSetForPackage: current.
	cs isEmpty ifFalse: [
		cs name: cs hash asString, cs name.
		cs isForBaseSystem: true ].
	CodePackage deregister: current! !

----End fileIn of /Volumes/CANON_DC/Cuis/1281-ChangeSetTweaks-JuanVuletich-2012May12-22h55m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1280] on 12 May 2012 at 11:31:06 pm'!
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:27'!
     clearAuthor
	AuthorInitials _ ''.
	AuthorName _ ''! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:29'!
                              setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	AuthorInitials _ (FillInTheBlank
		request: 'Please type your initials: '
		initialAnswer: AuthorInitials) withBlanksTrimmed.
	authorName _ (Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ (FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name') withBlanksTrimmed.
			^ self ]) second withBlanksTrimmed.
	(self confirm: 'Are you ' , authorName , '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [
			self inform: 'Please enter different initials, then'.
			self setAuthor ]! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 5/12/2012 23:27' prior: 16962604!
                               openSourceFiles
	self imageName = LastImageName ifFalse: [
		"Reset the author initials to blank when the image gets moved"
		LastImageName _ self imageName.
		Utilities clearAuthor].
	"Warning: Do open the source files only if nil.
	If not nil, it is because they are internalized and the files should not be opened"
	FileDirectory
		openSources: self defaultSourcesName
		andChanges: self localChangesName
		forImage: LastImageName.
	CuisSourceFileArray install! !
!Theme methodsFor: 'menus' stamp: 'jmv 5/12/2012 23:26' prior: 16975775!
    miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history') -> #changesIcon.
		#('print PS to file...' ) -> #printIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' ) -> #cancelIcon.
		#('debug...' 'debug it' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'expand all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner') -> #weatherFewCloudsIcon.
		#('system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'what to show...') -> #preferencesIcon.
		#('command-key help') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'profile messages (m)') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance' 'inspect Pointers (P)') -> #instanceIcon.
		#('Use Selection for Find (h)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('update' 'turn on auto-update (a)' 'update list (u)') -> #updateIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...') -> #fontXGenericIcon.
	}! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980966!
         authorInitials
	"Answer the initials to be used to identify the current code author.  "

	[AuthorInitials isEmpty] whileTrue: [self setAuthor].
	^ AuthorInitials! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980981!
                               authorName
	[AuthorName isEmpty] whileTrue: [self setAuthor].
	^ AuthorName! !

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #dateStamp!

Utilities class removeSelector: #dateStamp!

Utilities class removeSelector: #setAuthorInitials!

Utilities class removeSelector: #setAuthorInitials!

Utilities class removeSelector: #setAuthorInitials:!

Utilities class removeSelector: #setAuthorInitials:!

Utilities class removeSelector: #setAuthorName!

Utilities class removeSelector: #setAuthorName!

----End fileIn of /Volumes/CANON_DC/Cuis/1282-AuthorNameAndInitialsTweaks-JuanVuletich-2012May12-23h08m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1282] on 13 May 2012 at 10:08:55 pm'!
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2012 22:07' prior: 16802259!
      changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu title: 'Change Set'.
	aMenu addStayUpIcons.

	aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove.
	aMenu add: 'File out and keep (k)' 				action: #fileOutAndKeep.
	aMenu addLine.

	aMenu add: 'Rename change set (r)' 			action: #rename.
	aMenu add: 'Destroy change set (x)' 			action: #remove.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble.
				aMenu add: 'Remove preamble' 	action: #removePreamble]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 		action: #addPreamble].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript.
				aMenu add: 'Remove postscript' 	action: #removePostscript]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript].
	].
	aMenu addLine.

	"CONFLICTS SECTION"
	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.
	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.
	aMenu addLine.

	"CHECKS SECTION"
	aMenu add: 'trim history' target: model action: #trimHistory.
	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes. ',
				'NOTE: can cause confusion if later filed in over an earlier version of these changes'.

	aMenu add: 'view affected class categories' target: model action: #viewAffectedClassCategories.
	aMenu balloonTextForLastItem: ' Show class categories affected by any contained change'.

	^ aMenu! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920783!
                         cuisDefaults
	"
	Preferences cuisDefaults
	"
	self setPreferencesFrom:

	#(
		(balloonHelpEnabled true)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds false)
		(checkForSlips true)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic false)
		(menuKeyboardControl true)
		(optionalButtons true)
		(extraDebuggerButtons true)
		(smartUpdating true)
		(subPixelRenderFonts true)
		(thoroughSenders true)
	)! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920802!
                  slowMachine

	self setPreferencesFrom: #(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic true)
		(menuKeyboardControl false)
		(optionalButtons false)
		(smartUpdating false)
		(subPixelRenderFonts false)
		(thoroughSenders false)
	).
	ClassicTheme beCurrent! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920820!
                   smalltalk80
	"A traditional monochrome Smalltalk-80 look and feel, clean and austere, and lacking many features added to Squeak in recent years. Caution: this theme removes the standard Squeak flaps, turns off the 'smartUpdating' feature that keeps multiple browsers in synch, and much more."

	self setPreferencesFrom:

	#(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(smartUpdating false)
		(thoroughSenders false)
	)! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:03' prior: 16974647!
                buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				nil.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}.
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:51' prior: 16974931!
                              openMenu
	"Build the open window menu for the world."

	| menu |
	menu _ self menu: 'Open...'.

	ExtraOpenCommands ifNotNil: [
		self fillIn: menu from: ExtraOpenCommands ].

	self fillIn: menu from: {
		{'Text Editor' . {self . #openTextEditor}. 'A window for composing text' }.
		{'Workspace' . {self . #openWorkspace}. 'A window for evaluating Smalltalk expressions' }.
		{'Browser' . { self . #openBrowser}. 'A Smalltalk code browser, for studying and modifying the system'}.
		{'Message Names' . { self . #openMessageNames} . 'A tool for finding and editing methods that contain any given keyword in their names.'}.
		{'Transcript' . {self . #openTranscript}. 'A window showing contents of the System Transcript' }.
		nil.
		{'Installed Packages' . { self . #openPackageList}. 'A tool for managing Packages (optional units of code) installed in the system'}.
		{'Change Sorter' . {self . #openChangeSorter1} . 'A tool allowing you to view the methods in a Change Set, especially changes to the Base System' }.
		nil.
		{ 'Process Browser' . { ProcessBrowserWindow . #openProcessBrowser } }.
		{ 'Emergency Evaluator'. { Transcripter. #emergencyEvaluator } }.
		nil.
		{'File List' . {self . #openFileList} . 'An explorer of the File System' }.
		{'SUnit Test Runner' . {TestRunnerWindow . #openTestRunner} . 'A tool allowing you to compare and manipulate two change sets concurrently' }.
	}.
	^menu! !

Preferences class removeSelector: #simpleMenus!

Preferences class removeSelector: #simpleMenus!

ChangeSorterWindow removeSelector: #offerShiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerShiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerUnshiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerUnshiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #shiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #shiftedChangeSetMenu!

----End fileIn of /Volumes/CANON_DC/Cuis/1283-MenuTweaks-JuanVuletich-2012May13-21h47m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1282] on 13 May 2012 at 10:38:14 pm'!

!classDefinition: #ChangeSorter category: #'Tools-Changes'!
CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags '
	classVariableNames: 'AllChangeSets '
	poolDictionaries: ''
	category: 'Tools-Changes'!
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:28'!
                  changeSetDirtyFlags

	^ (ChangeSorter allChangeSets collect: [ :each |
		(each isForBaseSystem and: [ each hasUnsavedChanges ])
			ifTrue: [ '     --->']
			ifFalse: [ '       -' ]]) reversed! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:23'!
                initialExtent
	^720@480! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:31' prior: 16801656!
            fileOutAndKeep
	"File out the current change set."

	myChangeSet fileOut.
	self update! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:37' prior: 16801780!
             updateIfNecessary
	"Recompute all of my panes."

	| newList |

	myChangeSet ifNil: [^ self].  "Has been known to happen though shouldn't"
	myChangeSet isMoribund ifTrue: [
		self changed: #changeSetList.
		^ self showChangeSet: ChangeSet changeSetForBaseSystem ].

	newList _ self changeSetList.
	(priorChangeSetList == nil or: [priorChangeSetList ~= newList])
		ifTrue: [
			priorChangeSetList _ newList.
			self changed: #changeSetList ].

	newList _ self changeSetDirtyFlags.
	(priorDirtyFlags == nil or: [priorDirtyFlags ~= newList])
		ifTrue: [
			priorDirtyFlags _ newList.
			self changed: #changeSetDirtyFlags ]! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:27' prior: 16802203!
                    buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: Color white.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: Color white.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: Color white.
	messageList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !

!classDefinition: #ChangeSorter category: #'Tools-Changes'!
CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

----End fileIn of /Volumes/CANON_DC/Cuis/1284-DirtyFlagVisibleInChangeSorter-JuanVuletich-2012May13-22h08m-jmv.6.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1284] on 13 May 2012 at 11:12:09 pm'!
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:01'!
          notInstallOrTestRun

	^Installing isNil or: [
		(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]]
	
	"
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name = 'TestRunner' ]			-> Test
	(Installing beginsWith: Install-')																		-> Install
	Installing isNil 																						-> Normal
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]			-> Normal
	"! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:46'!
                  runningTest: aTestName do: aBlock

	Installing _ 'RunningTest-', aTestName.
	aBlock ensure: [ Installing _ nil ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:10' prior: 50343502!
             changeSetForBaseSystem

	| csName numberToUse |
	self notInstallOrTestRun
		ifTrue: [
			numberToUse _ self currentBaseCSNumber.
			ChangeSorter allChangeSets
				detect: [ :any | any name initialIntegerOrNil = numberToUse ]
				ifFound: [ :existing | ^existing ]
				ifNone: [
					csName _ (self baseSystemNameFor: numberToUse),
						(String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ]).
					^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: true ]]

		ifFalse: [
			csName _ 'Affects-BaseSystem--', Installing.
			^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false
			"Changes are for the base system, but are not user's own changes..." ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:11' prior: 50343527!
                               changeSetForPackage: aCodePackage

	| csName |
	aCodePackage ifNil: [
		^self changeSetForBaseSystem ].
	csName _ 	self notInstallOrTestRun
		ifTrue: [ 'UnsavedChangesTo-', aCodePackage name ]
		ifFalse: [
			Installing = ('Install-', aCodePackage packageName)
				ifTrue: [ Installing ]
				ifFalse: [ 'Affects-', aCodePackage name, '--', Installing ]].
	^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:42' prior: 16801541!
                   installing: aCodePackageOrChangeSetName do: aBlock

	| currentCS currentCSNumber newHighestUpdate |
	Installing _ 'Install-', aCodePackageOrChangeSetName.
	aBlock ensure: [ Installing _ nil ].

	SystemVersion current registerUpdate: aCodePackageOrChangeSetName.
	newHighestUpdate _  SystemVersion current highestUpdate.

	currentCSNumber _ self currentBaseCSNumber.
	currentCS _ self changeSetForBaseSystem.
	currentCS isEmpty ifTrue: [
		ChangeSorter removeChangeSet: currentCS.
		currentCSNumber > newHighestUpdate ifFalse: [
			CurrentBaseCSNumber _ newHighestUpdate + 1 ]]! !
!TestCase methodsFor: 'Running' stamp: 'jmv 5/13/2012 23:05' prior: 16968097!
              run: aResult
	ChangeSet
		runningTest: self printString
		do: [ aResult runCase: self ]
			! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 5/13/2012 22:51' prior: 16968792!
              runSuite: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ suite run ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
		name: 'TestRunner';
	      priority: Processor userBackgroundPriority;
	      resume.
! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 5/13/2012 22:51' prior: 50344217!
        runSuiteProfiled: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ MessageTally spyOn: [suite run] ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
		name: 'TestRunner';
	      priority: Processor userBackgroundPriority;
	      resume.
! !

----End fileIn of /Volumes/CANON_DC/Cuis/1285-TestRunnerCreatedCodeInOwnChangeSet-JuanVuletich-2012May13-23h09m-jmv.1.cs----!

----STARTUP----#(22 May 2012 10:30:43 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0-1280.image!


'From Cuis 4.0 of 21 April 2012 [latest update: #1280] on 12 May 2012 at 11:08:45 pm'!
!CodePackageFile methodsFor: 'services' stamp: 'jmv 5/12/2012 23:08' prior: 50343565!
                      install: aFileStream
	"Installs the package. Replace all existing code in the PackageInfo, removing any code that is not included in us."
	| localName newCodePackage |

	"Give reasonable warnings if there is stuff that can't be properly cleaned. Give the user the chance to abort."
	'=============' print.
	classesToRemove notEmpty ifTrue: [
		('classesToRemove: ', classesToRemove printString) print.
		'=============' print ].
	methodsToRemove notEmpty ifTrue: [
		'methodsToRemove: ' print.
		methodsToRemove do: [ :methodReference | methodReference print ].
		'=============' print ].
	
	"Tirar warning si hay que borrar cosas que no se puede, si hay referencias, etc. Quizas si vamos a borrar el ultimo implementor de un mensaje enviado?"

	"Crear, instalar y devolver una instancia de PackageInfo"
	newCodePackage_ CodePackage
		named: packageName
		createIfAbsent: true
		registerIfNew: true.
	newCodePackage
		fullFileName: fullName;
		sourceSystem: sourceSystem;
		description: description.

	"Esto crea el change set y carga ahi. OJO. En ese CS, hay que borrar todo lo que hay que borrar"
	"These were created in #fromFileStream: ... reuse?"
	localName _ FileDirectory localNameFor: fullName.
	ChangeSet installing: newCodePackage packageName do: [
		aFileStream fileInAnnouncing: 'Installing ', localName, '...'.
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ]].
	newCodePackage hasUnsavedChanges: false.
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSorter removeChangeSet: (ChangeSet changeSetForPackage: newCodePackage).
	Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
	
	"Tirar undeclared al transcript. warning si quedaron undeclared
	Es feo que tire an transcript undeclareds que despues no lo son..."
	Smalltalk cleanOutUndeclared.
	Undeclared notEmpty ifTrue: [
		('Undeclared: ', Undeclared printString) print ].

	"Descartar la instancia de CodePackageFile"
	^newCodePackage! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 5/12/2012 23:03' prior: 16813546!
  deletePackage

	| current cs |
	current _ model selection.
	current ifNil: [ ^self ].
	model selectionIndex: 0.	"no selection"
	cs _ ChangeSet changeSetForPackage: current.
	cs isEmpty ifFalse: [
		cs name: cs hash asString, cs name.
		cs isForBaseSystem: true ].
	CodePackage deregister: current! !

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1285/1281-ChangeSetTweaks-JuanVuletich-2012May12-22h55m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1280] on 12 May 2012 at 11:31:06 pm'!
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:27'!
                clearAuthor
	AuthorInitials _ ''.
	AuthorName _ ''! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:29'!
                              setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	AuthorInitials _ (FillInTheBlank
		request: 'Please type your initials: '
		initialAnswer: AuthorInitials) withBlanksTrimmed.
	authorName _ (Smalltalk contributorInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ (FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name') withBlanksTrimmed.
			^ self ]) second withBlanksTrimmed.
	(self confirm: 'Are you ' , authorName , '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [
			self inform: 'Please enter different initials, then'.
			self setAuthor ]! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 5/12/2012 23:27' prior: 16962604!
                               openSourceFiles
	self imageName = LastImageName ifFalse: [
		"Reset the author initials to blank when the image gets moved"
		LastImageName _ self imageName.
		Utilities clearAuthor].
	"Warning: Do open the source files only if nil.
	If not nil, it is because they are internalized and the files should not be opened"
	FileDirectory
		openSources: self defaultSourcesName
		andChanges: self localChangesName
		forImage: LastImageName.
	CuisSourceFileArray install! !
!Theme methodsFor: 'menus' stamp: 'jmv 5/12/2012 23:26' prior: 16975775!
    miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history') -> #changesIcon.
		#('print PS to file...' ) -> #printIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' ) -> #cancelIcon.
		#('debug...' 'debug it' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'expand all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner') -> #weatherFewCloudsIcon.
		#('system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'what to show...') -> #preferencesIcon.
		#('command-key help') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'profile messages (m)') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance' 'inspect Pointers (P)') -> #instanceIcon.
		#('Use Selection for Find (h)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('update' 'turn on auto-update (a)' 'update list (u)') -> #updateIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...') -> #fontXGenericIcon.
	}! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980966!
         authorInitials
	"Answer the initials to be used to identify the current code author.  "

	[AuthorInitials isEmpty] whileTrue: [self setAuthor].
	^ AuthorInitials! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/12/2012 23:25' prior: 16980981!
                               authorName
	[AuthorName isEmpty] whileTrue: [self setAuthor].
	^ AuthorName! !

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorName:!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #authorNamePerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #changeStampPerSe!

Utilities class removeSelector: #dateStamp!

Utilities class removeSelector: #dateStamp!

Utilities class removeSelector: #setAuthorInitials!

Utilities class removeSelector: #setAuthorInitials!

Utilities class removeSelector: #setAuthorInitials:!

Utilities class removeSelector: #setAuthorInitials:!

Utilities class removeSelector: #setAuthorName!

Utilities class removeSelector: #setAuthorName!

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1285/1282-AuthorNameAndInitialsTweaks-JuanVuletich-2012May12-23h08m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1282] on 13 May 2012 at 10:08:55 pm'!
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 5/13/2012 22:07' prior: 16802259!
                 changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu title: 'Change Set'.
	aMenu addStayUpIcons.

	aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove.
	aMenu add: 'File out and keep (k)' 				action: #fileOutAndKeep.
	aMenu addLine.

	aMenu add: 'Rename change set (r)' 			action: #rename.
	aMenu add: 'Destroy change set (x)' 			action: #remove.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble.
				aMenu add: 'Remove preamble' 	action: #removePreamble]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 		action: #addPreamble].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript.
				aMenu add: 'Remove postscript' 	action: #removePostscript]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript].
	].
	aMenu addLine.

	"CONFLICTS SECTION"
	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.
	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.
	aMenu addLine.

	"CHECKS SECTION"
	aMenu add: 'trim history' target: model action: #trimHistory.
	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes. ',
				'NOTE: can cause confusion if later filed in over an earlier version of these changes'.

	aMenu add: 'view affected class categories' target: model action: #viewAffectedClassCategories.
	aMenu balloonTextForLastItem: ' Show class categories affected by any contained change'.

	^ aMenu! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920783!
                         cuisDefaults
	"
	Preferences cuisDefaults
	"
	self setPreferencesFrom:

	#(
		(balloonHelpEnabled true)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds false)
		(checkForSlips true)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic false)
		(menuKeyboardControl true)
		(optionalButtons true)
		(extraDebuggerButtons true)
		(smartUpdating true)
		(subPixelRenderFonts true)
		(thoroughSenders true)
	)! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920802!
                  slowMachine

	self setPreferencesFrom: #(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic true)
		(menuKeyboardControl false)
		(optionalButtons false)
		(smartUpdating false)
		(subPixelRenderFonts false)
		(thoroughSenders false)
	).
	ClassicTheme beCurrent! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 5/13/2012 22:00' prior: 16920820!
                   smalltalk80
	"A traditional monochrome Smalltalk-80 look and feel, clean and austere, and lacking many features added to Squeak in recent years. Caution: this theme removes the standard Squeak flaps, turns off the 'smartUpdating' feature that keeps multiple browsers in synch, and much more."

	self setPreferencesFrom:

	#(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(collapseWindowsInPlace false)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(smartUpdating false)
		(thoroughSenders false)
	)! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 22:03' prior: 16974647!
                buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Appearance...'. { self. #appearanceDo}.
					'put up a menu offering many controls over appearance.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				nil.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Do...'. { Utilities. #offerCommonRequestsInMorphic}.
					'put up an editible list of convenient expressions, and evaluate the one selected.'}.
				{ 'Restore Display (r)'. { World. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name and save it under that name on disk.'}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the current image on disk, and quit out of Cuis.'}.
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/13/2012 21:51' prior: 16974931!
                              openMenu
	"Build the open window menu for the world."

	| menu |
	menu _ self menu: 'Open...'.

	ExtraOpenCommands ifNotNil: [
		self fillIn: menu from: ExtraOpenCommands ].

	self fillIn: menu from: {
		{'Text Editor' . {self . #openTextEditor}. 'A window for composing text' }.
		{'Workspace' . {self . #openWorkspace}. 'A window for evaluating Smalltalk expressions' }.
		{'Browser' . { self . #openBrowser}. 'A Smalltalk code browser, for studying and modifying the system'}.
		{'Message Names' . { self . #openMessageNames} . 'A tool for finding and editing methods that contain any given keyword in their names.'}.
		{'Transcript' . {self . #openTranscript}. 'A window showing contents of the System Transcript' }.
		nil.
		{'Installed Packages' . { self . #openPackageList}. 'A tool for managing Packages (optional units of code) installed in the system'}.
		{'Change Sorter' . {self . #openChangeSorter1} . 'A tool allowing you to view the methods in a Change Set, especially changes to the Base System' }.
		nil.
		{ 'Process Browser' . { ProcessBrowserWindow . #openProcessBrowser } }.
		{ 'Emergency Evaluator'. { Transcripter. #emergencyEvaluator } }.
		nil.
		{'File List' . {self . #openFileList} . 'An explorer of the File System' }.
		{'SUnit Test Runner' . {TestRunnerWindow . #openTestRunner} . 'A tool allowing you to compare and manipulate two change sets concurrently' }.
	}.
	^menu! !

Preferences class removeSelector: #simpleMenus!

Preferences class removeSelector: #simpleMenus!

ChangeSorterWindow removeSelector: #offerShiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerShiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerUnshiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #offerUnshiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #shiftedChangeSetMenu!

ChangeSorterWindow removeSelector: #shiftedChangeSetMenu!

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1285/1283-MenuTweaks-JuanVuletich-2012May13-21h47m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1282] on 13 May 2012 at 10:38:14 pm'!

!classDefinition: #ChangeSorter category: #'Tools-Changes'!
CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags '
	classVariableNames: 'AllChangeSets '
	poolDictionaries: ''
	category: 'Tools-Changes'!
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:28'!
                             changeSetDirtyFlags

	^ (ChangeSorter allChangeSets collect: [ :each |
		(each isForBaseSystem and: [ each hasUnsavedChanges ])
			ifTrue: [ '     --->']
			ifFalse: [ '       -' ]]) reversed! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:23'!
                initialExtent
	^720@480! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:31' prior: 16801656!
            fileOutAndKeep
	"File out the current change set."

	myChangeSet fileOut.
	self update! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 5/13/2012 22:37' prior: 16801780!
             updateIfNecessary
	"Recompute all of my panes."

	| newList |

	myChangeSet ifNil: [^ self].  "Has been known to happen though shouldn't"
	myChangeSet isMoribund ifTrue: [
		self changed: #changeSetList.
		^ self showChangeSet: ChangeSet changeSetForBaseSystem ].

	newList _ self changeSetList.
	(priorChangeSetList == nil or: [priorChangeSetList ~= newList])
		ifTrue: [
			priorChangeSetList _ newList.
			self changed: #changeSetList ].

	newList _ self changeSetDirtyFlags.
	(priorDirtyFlags == nil or: [priorDirtyFlags ~= newList])
		ifTrue: [
			priorDirtyFlags _ newList.
			self changed: #changeSetDirtyFlags ]! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/13/2012 22:27' prior: 16802203!
                    buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: Color white.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: Color white.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: Color white.
	messageList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !

!classDefinition: #ChangeSorter category: #'Tools-Changes'!
CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

CodeProvider subclass: #ChangeSorter
	instanceVariableNames: 'myChangeSet currentClassName currentSelector priorChangeSetList priorDirtyFlags'
	classVariableNames: 'AllChangeSets'
	poolDictionaries: ''
	category: 'Tools-Changes'!

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1285/1284-DirtyFlagVisibleInChangeSorter-JuanVuletich-2012May13-22h08m-jmv.6.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1284] on 13 May 2012 at 11:12:09 pm'!
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:01'!
                     notInstallOrTestRun

	^Installing isNil or: [
		(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]]
	
	"
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name = 'TestRunner' ]			-> Test
	(Installing beginsWith: Install-')																		-> Install
	Installing isNil 																						-> Normal
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]			-> Normal
	"! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:46'!
                  runningTest: aTestName do: aBlock

	Installing _ 'RunningTest-', aTestName.
	aBlock ensure: [ Installing _ nil ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:10' prior: 50343502!
             changeSetForBaseSystem

	| csName numberToUse |
	self notInstallOrTestRun
		ifTrue: [
			numberToUse _ self currentBaseCSNumber.
			ChangeSorter allChangeSets
				detect: [ :any | any name initialIntegerOrNil = numberToUse ]
				ifFound: [ :existing | ^existing ]
				ifNone: [
					csName _ (self baseSystemNameFor: numberToUse),
						(String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ]).
					^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: true ]]

		ifFalse: [
			csName _ 'Affects-BaseSystem--', Installing.
			^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false
			"Changes are for the base system, but are not user's own changes..." ]! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 23:11' prior: 50343527!
                               changeSetForPackage: aCodePackage

	| csName |
	aCodePackage ifNil: [
		^self changeSetForBaseSystem ].
	csName _ 	self notInstallOrTestRun
		ifTrue: [ 'UnsavedChangesTo-', aCodePackage name ]
		ifFalse: [
			Installing = ('Install-', aCodePackage packageName)
				ifTrue: [ Installing ]
				ifFalse: [ 'Affects-', aCodePackage name, '--', Installing ]].
	^ChangeSorter existingOrNewChangeSetNamed: csName forBaseSystem: false! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2012 22:42' prior: 16801541!
                   installing: aCodePackageOrChangeSetName do: aBlock

	| currentCS currentCSNumber newHighestUpdate |
	Installing _ 'Install-', aCodePackageOrChangeSetName.
	aBlock ensure: [ Installing _ nil ].

	SystemVersion current registerUpdate: aCodePackageOrChangeSetName.
	newHighestUpdate _  SystemVersion current highestUpdate.

	currentCSNumber _ self currentBaseCSNumber.
	currentCS _ self changeSetForBaseSystem.
	currentCS isEmpty ifTrue: [
		ChangeSorter removeChangeSet: currentCS.
		currentCSNumber > newHighestUpdate ifFalse: [
			CurrentBaseCSNumber _ newHighestUpdate + 1 ]]! !
!TestCase methodsFor: 'Running' stamp: 'jmv 5/13/2012 23:05' prior: 16968097!
              run: aResult
	ChangeSet
		runningTest: self printString
		do: [ aResult runCase: self ]
			! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 5/13/2012 22:51' prior: 16968792!
              runSuite: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ suite run ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
		name: 'TestRunner';
	      priority: Processor userBackgroundPriority;
	      resume.
! !
!TestRunner methodsFor: 'processing' stamp: 'jmv 5/13/2012 22:51' prior: 50344217!
        runSuiteProfiled: suite
	running ifNotNil: [ ^self inform: 'already running' ].
	suite addDependent: self.
	totalTests _ suite tests size.
	completedTests _ 0.
	runSemaphore initSignals.
	running _ [
            [ result _ MessageTally spyOn: [suite run] ]
	            ensure: [
		            running _ nil.
				suite removeDependent: self.
				runSemaphore signal.
				WorldState addDeferredUIMessage: [
					self updateWindow: result.
			      	self changed: #runTests.
			      	self changed: #runOneTest.
				].
	            ].
     ] newProcess.
	self runWindow.
      self changed: #runTests.
      self changed: #runOneTest.
      running
		name: 'TestRunner';
	      priority: Processor userBackgroundPriority;
	      resume.
! !

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1285/1285-TestRunnerCreatedCodeInOwnChangeSet-JuanVuletich-2012May13-23h09m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1286] on 15 May 2012 at 11:06:34 am'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 5/15/2012 11:05' prior: 16897419!
                            focusKeyboardFor: aKeyboardEvent

	"If aKeyboardEvent ctrl-tab or shift-ctrl-tab use it to navigate keyboard focus.
	Warning: This doesn't work on Windows... the event is not sent"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent controlKeyPressed and: [ aKeyboardEvent rawMacOptionKeyPressed not ]])
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifTrue: [ aKeyboardEvent hand keyboardFocusPrevious ]
				ifFalse: [ aKeyboardEvent hand keyboardFocusNext ].
			^ true ].
	"On Windows use at least some keystroke to navigate morphs... even shift-Tab that should navigate backwards"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent shiftPressed and: [ aKeyboardEvent rawMacOptionKeyPressed not ]])
		ifTrue: [
			aKeyboardEvent hand keyboardFocusNext.
			^ true ].

	"Cycle through windows with cmdAlt + < and cmdAlt + >.
	VM and platform peculiarities are hidden in #isCmdAltLessThan and #isCmdAltGreaterThan"
	"This was done as an attempt to mimic the Mac OSX keystrokes for 'Move focus to next window in active application'. Unfortunately, it only works if OS X is set to use any other keys for this. If (as for example, with German defaults), OS-X uses these keystrokes, then they are not sent to the VM. This is a long standing issues in Chromium and PhotoShop, for example..."
	self disableCode: [
		aKeyboardEvent isCmdAltLessThan ifTrue: [
			aKeyboardEvent hand activatePreviousWindow.
			^true ].
		aKeyboardEvent isCmdAltGreaterThan ifTrue: [
			aKeyboardEvent hand activateNextWindow.
			^true ]].
	"Alternative for Mac OS-X: option-Tab and option-shift-Tab"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent rawMacOptionKeyPressed ])
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifTrue: [ aKeyboardEvent hand activatePreviousWindow ]
				ifFalse: [ aKeyboardEvent hand activateNextWindow ].
			^ true ].
	"Alternative for non-Mac OS-X: alt-< and alt->"
	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent keyCharacter = $< ]) ifTrue: [
		aKeyboardEvent hand activatePreviousWindow.
		^true ].
	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent keyCharacter = $> ]) ifTrue: [
		aKeyboardEvent hand activateNextWindow.
		^true ].
	^false! !

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1285/1286-KeyboardNavigationTweaks-JuanVuletich-2012May15-09h49m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1286] on 15 May 2012 at 10:23:27 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/15/2012 18:00'!
                   unknownContributors
	"Answer a collection of authorInitials for whom there is code in the system 
	(either in core or in loaded packages), but we don't knwo their full name.
	Smalltalk unknownContributors
	"

	| all ok |
	all _ Smalltalk allContributors asSet.
	ok _ (Smalltalk contributorInitialsAndNames collect: [ :pair | pair first ]) asSet.
	^(all difference: ok) asArray sort! !

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1285/1287-UnknownContributors-JuanVuletich-2012May15-22h21m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1287] on 17 May 2012 at 10:08:11 am'!
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 5/17/2012 09:06'!
                             noteRecategorizationOfClass: aClass
	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."

	aClass wantsChangeSetLogging ifFalse: [^ self].
	self atClass: aClass add: #change.
	self addCoherency: aClass name.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'method changes' stamp: 'jmv 5/17/2012 09:41' prior: 50343128!
              removeSelectorChanges: selector class: class 
	"Remove all memory of changes associated with the argument, selector, in 
	this class."

	| chgRecord |
	self hasUnsavedChanges: true.	"set the flag in any case"
	(chgRecord _ changeRecords at: class name ifAbsent: [^ self])
		removeSelector: selector.
	chgRecord hasNoChanges ifTrue: [changeRecords removeKey: class name]! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 5/17/2012 09:45' prior: 50343142!
                      noteClassForgotten: className
	"Remove from structures if class is not a superclass of some other one we are remembering"

	self hasUnsavedChanges: true.	"set the flag in any case"
	structures ifNil: [^ self].
	Smalltalk at: className ifPresent: [:cls |
		cls subclasses do: [:sub | (structures includesKey: sub) ifTrue: [
			^ self]]].  "No delete"
	structures removeKey: className ifAbsent: nil! !
!ChangeSet methodsFor: 'system change notifications' stamp: 'jmv 5/17/2012 09:04' prior: 50343274!
             classRecategorized: aClass from: oldCategory to: newCategory

	self noteRecategorizationOfClass: aClass! !
!ChangeSet class methodsFor: 'system change notifications' stamp: 'jmv 5/17/2012 09:20' prior: 16801317!
            classRecategorized: aClass from: oldCategory to: newCategory
	"If the class was moved to a dfferent package, out of the base system, record the fact in the change set.
	The actual class redefinition is done at #classDefinitionChangedFrom:to: that is also called (if the class really changed)."

	| oldPackageOrNil newPackageOrNil newChangeSet |
	newPackageOrNil _ CodePackage
		packageOfSystemCategory: newCategory
		ifNone:	nil.
	newPackageOrNil ifNotNil: [ newPackageOrNil hasUnsavedChanges: true ].
	newChangeSet _ ChangeSet changeSetForPackage: newPackageOrNil.
	newChangeSet noteRecategorizationOfClass: aClass.

	oldPackageOrNil _ CodePackage
		packageOfSystemCategory: oldCategory
		ifNone: nil.
	oldPackageOrNil
		ifNotNil: [ oldPackageOrNil hasUnsavedChanges: true ]
		ifNil: [
			"If destination is a package, but source isn't, then record the change in the base system changeset"
			newPackageOrNil ifNotNil: [
				self changeSetForBaseSystem noteClassMoveToOtherPackage: aClass ]]! !
!ChangeSet class methodsFor: 'system change notifications' stamp: 'jmv 5/17/2012 09:43' prior: 16801454!
                   selectorRecategorized: selector from: oldCategory to: newCategory inClass: aClass
	"If the method was moved to a dfferent package, affect the package that lost the it. Tell it that it lost the method.
	The actual method redefinition is done at one of the method definition methods, that is also called."

	| newPackageOrNil newChangeSet oldPackageOrNil |
	newPackageOrNil _ CodePackage
		packageOfMethodCategory: newCategory
		ofClass: aClass
		ifNone:	nil.
	newPackageOrNil ifNotNil: [ newPackageOrNil hasUnsavedChanges: true ].
	newChangeSet _ ChangeSet changeSetForPackage: newPackageOrNil.
	newChangeSet selectorRecategorized: selector from: oldCategory to: newCategory inClass: aClass.

	oldPackageOrNil _ CodePackage
		packageOfMethodCategory: oldCategory
		ofClass: aClass
		ifNone: nil.
	oldPackageOrNil
		ifNotNil: [ oldPackageOrNil hasUnsavedChanges: true ]
		ifNil: [
			"If destination is a package, but source isn't, then record the change in the base system changeset"
			newPackageOrNil ifNotNil: [
				self changeSetForBaseSystem noteMethodMoveToOtherPackage: selector forClass: aClass ]]! !
!CodePackage class methodsFor: 'packages access' stamp: 'jmv 5/17/2012 10:03' prior: 50343310!
             register: aCodePackage
	"
	Usually call #named:createIfAbsent:registerIfNew: instead
	CodePackage register: (CodePackage newNamed: 'Tests-Files')
	"
	| any base |
	InstalledPackages at: aCodePackage packageName put: aCodePackage.

	"Anything that now belongs in this package, was moved out of the base system!!"
	base _ ChangeSet changeSetForBaseSystem.
	any _ false.
	aCodePackage classes do: [ :cls |
		any _ true.
		base noteClassMoveToOtherPackage: cls ].
	aCodePackage extensionMethods do: [ :methodReference |
		methodReference isValid ifTrue: [
			any _ true.
			base
				noteMethodMoveToOtherPackage: methodReference selector
				forClass: methodReference actualClass ]].
	any ifTrue: [
		aCodePackage hasUnsavedChanges: true ].

	self triggerEvent: #installedPackagesChanged! !

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates1261-1285/1288-PackageAndChangeSetFixes-JuanVuletich-2012May17-10h06m-jmv.1.cs----!

----SNAPSHOT----#(22 May 2012 10:31:50 pm) Cuis4.0-1288.image priorSource: 436066!

----QUIT/NOSAVE----#(22 May 2012 10:31:59 pm) Cuis4.0-1288.image priorSource: 866683!

----STARTUP----#(22 May 2012 10:32:10 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0-1288.image!


Object withAllSubclassesDo: [ :cls | cls organization classComment ]!

Object withAllSubclassesDo: [ :cls | cls organization classComment ]!

----QUIT/NOSAVE----#(22 May 2012 10:33:35 pm) Cuis4.0-1288.image priorSource: 866683!

----STARTUP----#(22 May 2012 10:39:56 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0-1288.image!


SourceFiles!

Connected!

WaitingForConnection!

| stream result |
stream := SocketStream openConnectionToHostNamed: 'www.squeak.org' port: 80.
[[stream nextPutAll: 'GET / HTTP/1.0'; newLine; newLine; flush.
result := stream upToEnd. "Give us all data until the socket is closed."
Transcript show: result withCuisLineEndings; newLine.]
	ensure: [stream close]]
		on: ConnectionTimedOut
		do: [:ex | Transcript show: ex asString; newLine. ex resume]!

| stream result |
stream := SocketStream openConnectionToHostNamed: 'www.squeak.org' port: 80.
[[stream nextPutAll: 'GET / HTTP/1.0'; newLine; newLine; flush.
result := stream upToEnd. "Give us all data until the socket is closed."
Transcript show: result withCuisLineEndings; newLine.]
	ensure: [stream close]]
		on: ConnectionTimedOut
		do: [:ex | Transcript show: ex asString; newLine. ex resume]!

----QUIT/NOSAVE----#(22 May 2012 11:17:16 pm) Cuis4.0-1288.image priorSource: 866683!

----STARTUP----#(23 May 2012 5:26:52 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0-1288.image!


'From Cuis 4.0 of 21 April 2012 [latest update: #1288] on 22 May 2012 at 8:45:21 pm'!

'Description Please enter a description for this package '!

!classDefinition: #WintermuteTheme category: #'Cuis-ExtraThemes'!
Theme subclass: #WintermuteTheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cuis-ExtraThemes'!

Theme subclass: #WintermuteTheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cuis-ExtraThemes'!

!classDefinition: 'WintermuteTheme class' category: #'Cuis-ExtraThemes'!
WintermuteTheme class
	instanceVariableNames: ''!

WintermuteTheme class
	instanceVariableNames: ''!
!WintermuteTheme commentStamp: '<historical>' prior: 0!
          Most colors are the based on ColorTheme:
	baseColor adjustSaturation: -0.1 brightness: -0.7!
!WintermuteTheme methodsFor: 'colors' stamp: 'DSG 5/21/2012 14:24'!
                               background
	^ Color darkGray! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/21/2012 14:35'!
                       buttonGradientTopFactor
	"Will only be used for color themes that answer true to #roundButtons"
	^0.95! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/21/2012 14:25'!
             buttonLabel
	^Color darkGray! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/21/2012 13:18'!
                       defaultWindowColor
	^ Color lightGray! !
!WintermuteTheme methodsFor: 'other options' stamp: 'DSG 5/21/2012 13:29'!
            embossedTitles
	^false! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/21/2012 14:29'!
                             menu
	^ Color gray! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/20/2012 12:04'!
 menuText
	^Color gray: 0.9! !
!WintermuteTheme methodsFor: 'colors' stamp: 'DSG 5/21/2012 12:57'!
                              paneBackgroundFrom: aColor
	^ Color r: 28 g: 28 b: 28 range: 255! !
!WintermuteTheme methodsFor: 'other options' stamp: 'DSG 5/20/2012 12:04'!
                 roundWindowCorners
	^true! !
!WintermuteTheme methodsFor: 'colors' stamp: 'DSG 5/22/2012 10:37'!
                               roundedButtonRadius
	"Only effective if #roundButtons answers true.
	Provide a reasonable default for subclasses."
	^5! !
!WintermuteTheme methodsFor: 'colors' stamp: 'DSG 5/20/2012 12:06'!
  roundedWindowRadius
	"Only effective if #roundWindowCorners answers true.
	Provide a reasonable default for subclasses."
	^5! !
!WintermuteTheme methodsFor: 'shout' stamp: 'DSG 5/22/2012 11:14'!
                             shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> (Color r: 249 g: 238 b: 152 range: 255).
		#undefined 				-> (Color r: 155 g: 133 b: 157 range: 255).
		#methodTags 			-> (Color r: 115 g: 110 b: 115 range: 255).
		#pseudoVariables 		-> (Color r: 117 g: 175 b: 166 range: 255).
		#messages 				-> (Color r: 143 g: 157 b: 106 range: 255).
		#instVar 					-> (Color r: 207 g: 106 b: 76 range: 255).
		#incompleteMessages -> (Color r: 230 g: 230 b: 230 range: 255).
		#blockLevelFour 		-> #white.
		#blockLevelFive 		-> #green.
		#blockLevelSix 			-> #blue.
		#blockLevelSeven 		-> #red.
		#tempBar 				-> (Color r: 218 g: 239 b: 163 range: 255).
		#tempVars 				-> (Color r: 218 g: 239 b: 163 range: 255).
	}! !
!WintermuteTheme methodsFor: 'colors' stamp: 'DSG 5/22/2012 20:39'!
                               text
	^ Color veryLightGray! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/22/2012 10:21'!
                        textHighlight

	^Color r: 0.7 g: 1.0 b: 0.7 alpha: 0.2! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/21/2012 22:25'!
                             unfocusedTextHighlightFrom: aColor
	^aColor adjustSaturation: -0.35 brightness: -0.13! !
!WintermuteTheme methodsFor: 'other options' stamp: 'DSG 5/20/2012 12:04'!
                            useButtonGradient
	^true! !
!WintermuteTheme methodsFor: 'tool colors' stamp: 'DSG 5/21/2012 13:28'!
                           useUniformColors
	^true! !
!WintermuteTheme methodsFor: 'other options' stamp: 'DSG 5/20/2012 12:04'!
                          useWindowTitleGradient
	^true! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/21/2012 13:30'!
                      windowLabel
	^Color gray: 0.3! !

----End fileIn of /Volumes/CANON_DC/Cuis/davidgraham-Cuis-ExtraThemes-93e1c42/Cuis-ExtraThemes.pck----!

self windowColor!

self widgetsColor!
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:02'!
        buttonColor

	^Theme current buttonColorFrom: self windowColor! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:02' prior: 16795512!
      buildMorphicSwitches
	| instanceSwitch commentSwitch classSwitch row buttonColor |
	instanceSwitch := PluggableButtonMorph 
				model: model
				stateGetter: #instanceMessagesIndicated
				action: #indicateInstanceMessages.
	instanceSwitch
		label: 'instance'.
	commentSwitch := PluggableButtonMorph 
				model: model
				stateGetter: #classCommentIndicated
				action: #plusButtonHit.
	commentSwitch
		label: '?';
		setBalloonText: 'class comment'.
	classSwitch := PluggableButtonMorph 
				model: model
				stateGetter: #classMessagesIndicated
				action: #indicateClassMessages.
	classSwitch
		label: 'class'.
	row _ LayoutMorph newRow.
	row
		addMorph: instanceSwitch proportionalWidth: 0.45;
		addMorph: commentSwitch proportionalWidth: 0.22;
		addMorph: classSwitch proportionalWidth: 0.33.
	buttonColor _ self buttonColor.
	row color: buttonColor.
	{ 
		instanceSwitch.
		commentSwitch.
		classSwitch} do: [:m | 
				m color: buttonColor ].
	^row! !
!ChangeListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:02' prior: 16799310!
        optionalButtonRow
	"Answer a row of buttons to occur in a tool pane"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: model
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		buttons add: button.
		button setBalloonText: tuple fourth].
	buttons add: self lineDiffButton.
	widths add: 14.
	buttons add: self wordDiffButton.
	widths add: 16.
	model wantsPrettyDiffOption ifTrue: [
		buttons add:  self prettyLineDiffButton.
		widths add: 21.
		buttons add:  self prettyWordDiffButton.
		widths add: 23 ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!CodeWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:02' prior: 16815041!
         decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColor aButton flags buttonColor |
	(aButton _ self inheritanceButton) ifNil: [^ self].

	buttonColor _ self buttonColor.

	Preferences decorateBrowserButtons
		ifFalse: [ ^aButton color: buttonColor ].
	cm _ model currentCompiledMethod.
	(cm isKindOf: CompiledMethod)
		ifFalse: [ ^aButton color: buttonColor ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColor _ {

		"This is NOTan override. There is no super implementation."
		buttonColor.							"no sends to super. there is not override in any subclass"
		Color tan.							"no sends to super. there is an override in some subclass"
		Color red.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		Color red.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		Color red muchLighter.			"doesn't have sub; has super but doesn't call it"
		Color r: 0.94 g: 0.823 b: 0.673.		"has sub; has super but doesn't call it"
		Color green muchLighter.			"doesn't have sub; has super and callsl it"
		Color blue muchLighter.			"has sub; has super and callsl it"

	} at: flags + 1.
	aButton color: aColor! !
!CodeWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:02' prior: 50358992!
         decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColor aButton flags buttonColor |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColor _ self buttonColor.

	Preferences decorateBrowserButtons
		ifFalse: [ ^aButton color: buttonColor ].
	cm _ model currentCompiledMethod.
	(cm isKindOf: CompiledMethod)
		ifFalse: [ ^aButton color: buttonColor ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColor _ {

		"This is NOTan override. There is no super implementation."
		buttonColor.							"no sends to super. there is not override in any subclass"
		Color tan.							"no sends to super. there is an override in some subclass"
		Color red.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		Color red.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		Color red muchLighter.			"doesn't have sub; has super but doesn't call it"
		Color r: 0.94 g: 0.823 b: 0.673.		"has sub; has super but doesn't call it"
		Color green muchLighter.			"doesn't have sub; has super and callsl it"
		Color blue muchLighter.			"has sub; has super and callsl it"

	} at: flags + 1.
	aButton color: aColor! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16814896!
      optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16834872!
        customButtonRow
	"Answer a button pane affording the user one-touch access to certain functions; the pane is given the formal name 'customButtonPane' by which it can be retrieved by code wishing to send messages to widgets residing on the pane"

	| button buttons row buttonColor |
	
	buttons _ OrderedCollection new.
	buttonColor _ self buttonColor.
	"button with target = self"
	button _ PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #proceed.
	button color: buttonColor.
	button label: 'Proceed'.
	button setBalloonText: 'close the debugger and proceed.'.
	buttons add: button.
	"buttons with model target"
	self customButtonSpecs do: [ :tuple |
		button _ PluggableButtonMorph 
					model: model
					stateGetter: nil
					action: tuple second.
		button color: buttonColor.
		button label: tuple first asString.
		tuple size > 2 ifTrue: [button setBalloonText: tuple third].
		buttons add: button].

	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons.
	^row! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16851975!
                      optionalButtonRow
	"Answer the button row associated with a file list"

	| row buttonColor |
	row _ LayoutMorph newRow.
	buttonColor _ self buttonColor.
	row setProperty: #buttonRow toValue: true.  "Used for dynamic retrieval later on"
	row color: buttonColor.
	self updateButtonRow: row.
	^row! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16969152!
                           optionalButtonRow
	| row button buttons widths buttonColor |

	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | 
		widths add: tuple first.
		button _ PluggableButtonMorph 
			model: model
			stateGetter: nil
			action: tuple third.
		button color: buttonColor.
		button
			label: tuple second.
		buttons add: button].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16851920!
                     buttonToTriggerIn: aFileList for: service
	"Answer a button that will trigger the receiver service in a file list"

	| aButton |
	service argumentProvider: aFileList.
	aButton := PluggableButtonMorph 
				model: service
				stateGetter: nil
				action: #performService.
	aButton label: service buttonLabel.
	aButton color: self buttonColor.
	aButton setBalloonText: service description.
	^aButton! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:06' prior: 16975390!
                               acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.5 g: 0.8 b: 0.5 ])! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:06' prior: 16852813!
        createAcceptButton
	"create the [accept] button"
	| result buttonColor theme |
	theme _ Theme current.
	buttonColor _ theme acceptButton.
	result _ PluggableButtonMorph new
		 model: self;
		 color: buttonColor;
		 label: 'Accept';
		 action: #acceptClicked.
	result bounds: (29@90 corner: 122@117).
	self addMorph: result.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:06' prior: 50359213!
               createAcceptButton
	"create the [accept] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current acceptButton;
		 label: 'Accept';
		 action: #acceptClicked.
	result bounds: (29@90 corner: 122@117).
	self addMorph: result.
	^ result! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:07' prior: 16975395!
                            cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.8 g: 0.5 b: 0.5 ])! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:08' prior: 16852830!
        createCancelButton
	"create the [cancel] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current cancelButton;
		 label: 'Cancel';
		 action: #cancelClicked.
	result bounds: (149@90 corner: 242@117).
	self addMorph: result.
	^ result! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:09' prior: 50359239!
                           cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.9 g: 0.3 b: 0.3 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:09' prior: 50359205!
                       acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.3 g: 0.9 b: 0.3 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:10' prior: 50359267!
                       acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.1 g: 0.9 b: 0.3 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:10' prior: 50359259!
                       cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.9 g: 0.1 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:10' prior: 50359283!
                       cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.6 g: 0.1 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:10' prior: 50359291!
                       cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.7 g: 0.1 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:10' prior: 50359299!
                       cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.8 g: 0.1 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:10' prior: 50359307!
                       cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.8 g: 0.2 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:10' prior: 50359275!
                       acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.1 g: 0.8 b: 0.2 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:11' prior: 50359323!
                       acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.1 g: 0.6 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:11' prior: 50359331!
                       acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.1 g: 0.7 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:11' prior: 50359315!
                       cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.75 g: 0.2 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:12' prior: 50359347!
                      cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.75 g: 0.15 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:12' prior: 50359355!
                     cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.7 g: 0.1 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:12' prior: 50359363!
                       cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.7 g: 0.1 b: 0.05 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:12' prior: 50359371!
                      cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.7 g: 0.05 b: 0.05 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:13' prior: 50359379!
                     cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.75 g: 0.05 b: 0.05 ])! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:17' prior: 50358923!
              buttonColor

	^Theme current buttonColorFrom: self widgetsColor! !

self widgetsColor: Color blue!
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:18' prior: 16969210!
      updateColors
	| aTestResult theColor |
	theColor _ self widgetsColor.
	model ifNotNil: [
		model runButtonState ifFalse: [
			aTestResult _ model result.
			theColor _ aTestResult errors size + aTestResult failures size = 0
				ifTrue: [ Color green lighter ]
				ifFalse: [
					aTestResult errors size > 0
						ifTrue: [ Color red lighter ]
						ifFalse: [ Color yellow lighter ]]].
		self updatePartColors: theColor ]! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:18' prior: 16969193!
                               refreshWindow
	| pc |
	pc _ self widgetsColor.
	passFailText color: pc.
	detailsText color: pc.
	model refreshTR! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:18' prior: 50359418!
                     refreshWindow
	| pc |
	pc _ self windowColor.
	passFailText color: pc.
	detailsText color: pc.
	model refreshTR! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:18' prior: 50359401!
                      updateColors
	| aTestResult theColor |
	theColor _ self windowColor.
	model ifNotNil: [
		model runButtonState ifFalse: [
			aTestResult _ model result.
			theColor _ aTestResult errors size + aTestResult failures size = 0
				ifTrue: [ Color green lighter ]
				ifFalse: [
					aTestResult errors size > 0
						ifTrue: [ Color red lighter ]
						ifFalse: [ Color yellow lighter ]]].
		self updatePartColors: theColor ]! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:19' prior: 50359432!
updateColors
	| aTestResult theColor |
	theColor _ self widgetsColor.
	model ifNotNil: [
		model runButtonState ifFalse: [
			aTestResult _ model result.
			theColor _ aTestResult errors size + aTestResult failures size = 0
				ifTrue: [ Color green lighter ]
				ifFalse: [
					aTestResult errors size > 0
						ifTrue: [ Color red lighter ]
						ifFalse: [ Color yellow lighter ]]].
		self updatePartColors: theColor ]! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:19' prior: 50359425!
                               refreshWindow
	| pc |
	pc _ self widgetsColor.
	passFailText color: pc.
	detailsText color: pc.
	model refreshTR! !
!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 18:20' prior: 16965514!
                            widgetsColor
	| cc |
	widgetsColor ifNotNil: [ ^ widgetsColor ].
	cc _ Color white.
	Display depth > 2 ifTrue: [
		cc _ self windowColor ].
	self widgetsColor: cc.
	^ cc.! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:20' prior: 16813416!
                  buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow description summary buttonRow browseChangesButton saveButton browseButton createButton deleteButton |
	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	names _ PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: Color white.
	names _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: 16;
		addMorphUseAll: names.

	fileNames _ PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: Color white.
	fileNames _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: 16;
		addMorphUseAll: fileNames.

	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: names proportionalWidth: 0.2;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.7.

	description _ TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary _ TextModelMorph
		textProvider: model
		textGetter: #summary.

	saveButton _ PluggableButtonMorph model: model action: #save label: 'Save (overwrite)'.
	createButton _ PluggableButtonMorph model: self action: #createPackage label: 'Create Package'.
	deleteButton _ PluggableButtonMorph model: self action: #deletePackage label: 'Delete (merge in Cuis)'.
	browseChangesButton _ PluggableButtonMorph model: self action: #browseChanges label: 'Browse unsaved changes'.
	browseButton _ PluggableButtonMorph model: self action: #browse label: 'Browse package code'.
	buttonRow _ LayoutMorph newRow.
	buttonRow
		color: self widgetsColor quiteWhiter;
		addMorph: saveButton proportionalWidth: 0.6;
		addMorph: createButton proportionalWidth: 0.6;
		addMorph: deleteButton proportionalWidth: 0.6;
		addMorph: browseChangesButton proportionalWidth: 0.6;
		addMorph: browseButton proportionalWidth: 0.6.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: summary proportionalHeight: 0.13;
		addAdjusterAndMorph: description proportionalHeight: 0.3;
		addAdjusterAndMorph: buttonRow proportionalHeight: 0.07.
	self setLabel: 'Installed Packages'! !

----QUIT/NOSAVE----#(23 May 2012 6:22:21 pm) Cuis4.0-1288.image priorSource: 866683!

----STARTUP----#(23 May 2012 6:22:47 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0-1288.image!

!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:06' prior: 16852813!
               createAcceptButton
	"create the [accept] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current acceptButton;
		 label: 'Accept';
		 action: #acceptClicked.
	result bounds: (29@90 corner: 122@117).
	self addMorph: result.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:08' prior: 16852830!
             createCancelButton
	"create the [cancel] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current cancelButton;
		 label: 'Cancel';
		 action: #cancelClicked.
	result bounds: (149@90 corner: 242@117).
	self addMorph: result.
	^ result! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:11' prior: 16975390!
                           acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.1 g: 0.7 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:13' prior: 16975395!
                       cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.75 g: 0.05 b: 0.05 ])! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16969152!
          optionalButtonRow
	| row button buttons widths buttonColor |

	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | 
		widths add: tuple first.
		button _ PluggableButtonMorph 
			model: model
			stateGetter: nil
			action: tuple third.
		button color: buttonColor.
		button
			label: tuple second.
		buttons add: button].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:19' prior: 16969193!
                       refreshWindow
	| pc |
	pc _ self widgetsColor.
	passFailText color: pc.
	detailsText color: pc.
	model refreshTR! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:19' prior: 16969210!
                     updateColors
	| aTestResult theColor |
	theColor _ self widgetsColor.
	model ifNotNil: [
		model runButtonState ifFalse: [
			aTestResult _ model result.
			theColor _ aTestResult errors size + aTestResult failures size = 0
				ifTrue: [ Color green lighter ]
				ifFalse: [
					aTestResult errors size > 0
						ifTrue: [ Color red lighter ]
						ifFalse: [ Color yellow lighter ]]].
		self updatePartColors: theColor ]! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:17'!
               buttonColor

	^Theme current buttonColorFrom: self widgetsColor! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:19' prior: 50359648!
      updateColors
	| aTestResult theColor |
	theColor _ self widgetsColor.
	model ifNotNil: [
		model runButtonState ifFalse: [
			aTestResult _ model result.
			theColor _ aTestResult errors size + aTestResult failures size = 0
				ifTrue: [ Color green lighter ]
				ifFalse: [
					aTestResult errors size > 0
						ifTrue: [ Color red lighter ]
						ifFalse: [ Color yellow lighter ]]].
		self updatePartColors: theColor ]! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 4/16/2011 14:12' prior: 50359641!
                               refreshWindow
	| pc |
	pc _ self windowColor.
	passFailText color: pc.
	detailsText color: pc.
	model refreshTR! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 4/23/2011 23:17' prior: 50359621!
                  optionalButtonRow
	| row button buttons widths buttonColor |

	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ Theme current buttonColorFrom: self windowColor.
	self optionalModelButtonTuples do: [ :tuple | 
		widths add: tuple first.
		button _ PluggableButtonMorph 
			model: model
			stateGetter: nil
			action: tuple third.
		button color: buttonColor.
		button
			label: tuple second.
		buttons add: button].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 18:20' prior: 16965514!
                               widgetsColor
	| cc |
	widgetsColor ifNotNil: [ ^ widgetsColor ].
	cc _ Color white.
	Display depth > 2 ifTrue: [
		cc _ self windowColor ].
	self widgetsColor: cc.
	^ cc.! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16814896!
                             optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 4/23/2011 22:48' prior: 50359723!
            optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ Theme current buttonColorFrom: self windowColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:27' prior: 50359664!
           buttonColor
self widgetsColor = self windowColor ifFalse: [].
	^Theme current buttonColorFrom: self windowColor! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:27' prior: 50359613!
                            cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.75 g: 0.15 b: 0.15 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:28' prior: 50359777!
                    cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.75 g: 0.1 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:28' prior: 50359785!
                      cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.7 g: 0.1 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:13' prior: 50359793!
                       cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.75 g: 0.05 b: 0.05 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:29' prior: 50359801!
                    cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ (Color r: 0.75 g: 0.05 b: 0.05) blacker ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:29' prior: 50359605!
          acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ (Color r: 0.1 g: 0.7 b: 0.1)blacker ])! !

(Color r: 0.1 g: 0.7 b: 0.1)blacker !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:29' prior: 50359817!
       acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ (Color r: 0.1 g: 0.6 b: 0.1)blacker ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:30' prior: 50359809!
              cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ (Color r: 0.7 g: 0.05 b: 0.05) blacker ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:30' prior: 50359834!
           cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ (Color r: 0.7 g: 0.05 b: 0.05)  ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:30' prior: 50359826!
                  acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ (Color r: 0.1 g: 0.6 b: 0.1) ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:30' prior: 50359850!
                     acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [  self defaultWindowColor ]
			ifFalse: [ Color r: 0.1 g: 0.6 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:30' prior: 50359858!
                       acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.1 g: 0.6 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:30' prior: 50359842!
                        cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.7 g: 0.05 b: 0.05 ])! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 50359746!
                  optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 50359882!
            optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !

----QUIT/NOSAVE----#(23 May 2012 6:32:14 pm) Cuis4.0-1288.image priorSource: 866683!

----STARTUP----#(23 May 2012 6:32:18 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0-1288.image!

!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 18:20' prior: 16965514!
  widgetsColor
	| cc |
	widgetsColor ifNotNil: [ ^ widgetsColor ].
	cc _ Color white.
	Display depth > 2 ifTrue: [
		cc _ self windowColor ].
	self widgetsColor: cc.
	^ cc.! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:27'!
           buttonColor
self widgetsColor = self windowColor ifFalse: [].
	^Theme current buttonColorFrom: self windowColor! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16814896!
                        optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 4/23/2011 22:48' prior: 50359948!
            optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ Theme current buttonColorFrom: self windowColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:33' prior: 50359941!
           buttonColor
"self widgetsColor = self windowColor ifFalse: []."
	^Theme current buttonColorFrom: self windowColor! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 50359971!
                      optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:34' prior: 50359995!
          buttonColor
self widgetsColor = self windowColor ifFalse: [].
	^Theme current buttonColorFrom: self windowColor! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:35' prior: 50360025!
                      buttonColor
'' print.
self windowColor print.
self widgetsColor print.
self windowColor print.
	^Theme current buttonColorFrom: self windowColor! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:35' prior: 50360032!
                     buttonColor
'' print.
self windowColor print.
self widgetsColor print.
self windowColor print.
	^(Theme current buttonColorFrom: self windowColor) print! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:36' prior: 50360040!
             buttonColor
| z |
z _ Theme current buttonColorFrom: self windowColor.
'' print.
self windowColor print.
self widgetsColor print.
self windowColor print.
"	^(Theme current buttonColorFrom: self windowColor) print"
^z! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:36' prior: 50360048!
             buttonColor
| z |
z _ Theme current buttonColorFrom: self windowColor.
'' print.
self windowColor print.
"self widgetsColor print."
self windowColor print.
"	^(Theme current buttonColorFrom: self windowColor) print"
^z! !
!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 18:40' prior: 50359933!
                  widgetsColor
	| cc |
	widgetsColor ifNotNil: [ ^ widgetsColor ].
	cc _ Color white.
	Display depth > 2 ifTrue: [
		cc _ self windowColor print ].
	self widgetsColor: cc.
	^ cc.! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:41' prior: 50360058!
                     buttonColor
| z |
z _ Theme current buttonColorFrom: self windowColor.
'' print.
self windowColor print.
self widgetsColor print.
self windowColor print.
"	^(Theme current buttonColorFrom: self windowColor) print"
^z! !

self widgetsColor!

self widgetsColor: self widgetsColor!
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:43' prior: 16965269!
                openInWorld
	"Ensure all widgets have proper colors before opening"
	self widgetsColor: self widgetsColor.
	super openInWorld! !
!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 18:43' prior: 50360068!
               widgetsColor
	| cc |
	widgetsColor ifNotNil: [ ^ widgetsColor ].
	cc _ Color white.
	Display depth > 2 ifTrue: [
		cc _ self windowColor print ].
"	self widgetsColor: cc."
	^ cc.! !
!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 18:44' prior: 50360096!
                          widgetsColor
	| cc |
	widgetsColor ifNotNil: [ ^ widgetsColor ].
	cc _ Color white.
	Display depth > 2 ifTrue: [
		cc _ self windowColor ].
	^ cc.! !
!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 18:44' prior: 50360105!
                          widgetsColor
	| cc |
	widgetsColor ifNotNil: [ ^ widgetsColor ].
	cc _ Color white.
	Display depth > 2 ifTrue: [
		cc _ self windowColor ].
	^ cc! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:44' prior: 50360077!
                    buttonColor

	^(Theme current buttonColorFrom: self windowColor) print! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:44' prior: 50360121!
                               buttonColor

	^ Theme current buttonColorFrom: self windowColor! !

----QUIT/NOSAVE----#(23 May 2012 6:44:55 pm) Cuis4.0-1288.image priorSource: 866683!

----STARTUP----#(23 May 2012 6:45:02 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0-1288.image!

!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:44'!
       buttonColor

	^ Theme current buttonColorFrom: self windowColor! !
!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 18:44' prior: 16965514!
             widgetsColor
	| cc |
	widgetsColor ifNotNil: [ ^ widgetsColor ].
	cc _ Color white.
	Display depth > 2 ifTrue: [
		cc _ self windowColor ].
	^ cc! !
!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 18:46' prior: 50360142!
                           widgetsColor

	widgetsColor ifNotNil: [ ^ widgetsColor ].
	^Display depth > 2
		ifTrue: [ self windowColor ]
		ifFalse: [ Color white ]! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:43' prior: 16965269!
                            openInWorld
	"Ensure all widgets have proper colors before opening"
	self widgetsColor: self widgetsColor.
	super openInWorld! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16814896!
          optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:06' prior: 16852813!
 createAcceptButton
	"create the [accept] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current acceptButton;
		 label: 'Accept';
		 action: #acceptClicked.
	result bounds: (29@90 corner: 122@117).
	self addMorph: result.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:08' prior: 16852830!
             createCancelButton
	"create the [cancel] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current cancelButton;
		 label: 'Cancel';
		 action: #cancelClicked.
	result bounds: (149@90 corner: 242@117).
	self addMorph: result.
	^ result! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:30' prior: 16975390!
                           acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.1 g: 0.6 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:30' prior: 16975395!
                        cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.7 g: 0.05 b: 0.05 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:49' prior: 50360212!
                      acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.2 g: 0.6 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:50' prior: 50360220!
                        cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.7 g: 0.2 b: 0.2 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:50' prior: 50360236!
                        cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.8 g: 0.2 b: 0.2 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:50' prior: 50360244!
                        cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.6 g: 0.2 b: 0.2 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:51' prior: 50360252!
                        cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.9 g: 0.3 b: 0.3 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:51' prior: 50360260!
                        cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.9 g: 0.2 b: 0.2 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:51' prior: 50360268!
                        cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.8 g: 0.2 b: 0.2 ])! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:17' prior: 50360137!
                  buttonColor

	^Theme current buttonColorFrom: self widgetsColor! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:20' prior: 16813416!
                             buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow description summary buttonRow browseChangesButton saveButton browseButton createButton deleteButton |
	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	names _ PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: Color white.
	names _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: 16;
		addMorphUseAll: names.

	fileNames _ PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: Color white.
	fileNames _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: 16;
		addMorphUseAll: fileNames.

	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: names proportionalWidth: 0.2;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.7.

	description _ TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary _ TextModelMorph
		textProvider: model
		textGetter: #summary.

	saveButton _ PluggableButtonMorph model: model action: #save label: 'Save (overwrite)'.
	createButton _ PluggableButtonMorph model: self action: #createPackage label: 'Create Package'.
	deleteButton _ PluggableButtonMorph model: self action: #deletePackage label: 'Delete (merge in Cuis)'.
	browseChangesButton _ PluggableButtonMorph model: self action: #browseChanges label: 'Browse unsaved changes'.
	browseButton _ PluggableButtonMorph model: self action: #browse label: 'Browse package code'.
	buttonRow _ LayoutMorph newRow.
	buttonRow
		color: self widgetsColor quiteWhiter;
		addMorph: saveButton proportionalWidth: 0.6;
		addMorph: createButton proportionalWidth: 0.6;
		addMorph: deleteButton proportionalWidth: 0.6;
		addMorph: browseChangesButton proportionalWidth: 0.6;
		addMorph: browseButton proportionalWidth: 0.6.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: summary proportionalHeight: 0.13;
		addAdjusterAndMorph: description proportionalHeight: 0.3;
		addAdjusterAndMorph: buttonRow proportionalHeight: 0.07.
	self setLabel: 'Installed Packages'! !
!CodeWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:02' prior: 16815041!
             decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColor aButton flags buttonColor |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColor _ self buttonColor.

	Preferences decorateBrowserButtons
		ifFalse: [ ^aButton color: buttonColor ].
	cm _ model currentCompiledMethod.
	(cm isKindOf: CompiledMethod)
		ifFalse: [ ^aButton color: buttonColor ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColor _ {

		"This is NOTan override. There is no super implementation."
		buttonColor.							"no sends to super. there is not override in any subclass"
		Color tan.							"no sends to super. there is an override in some subclass"
		Color red.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		Color red.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		Color red muchLighter.			"doesn't have sub; has super but doesn't call it"
		Color r: 0.94 g: 0.823 b: 0.673.		"has sub; has super but doesn't call it"
		Color green muchLighter.			"doesn't have sub; has super and callsl it"
		Color blue muchLighter.			"has sub; has super and callsl it"

	} at: flags + 1.
	aButton color: aColor! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:02' prior: 16795512!
   buildMorphicSwitches
	| instanceSwitch commentSwitch classSwitch row buttonColor |
	instanceSwitch := PluggableButtonMorph 
				model: model
				stateGetter: #instanceMessagesIndicated
				action: #indicateInstanceMessages.
	instanceSwitch
		label: 'instance'.
	commentSwitch := PluggableButtonMorph 
				model: model
				stateGetter: #classCommentIndicated
				action: #plusButtonHit.
	commentSwitch
		label: '?';
		setBalloonText: 'class comment'.
	classSwitch := PluggableButtonMorph 
				model: model
				stateGetter: #classMessagesIndicated
				action: #indicateClassMessages.
	classSwitch
		label: 'class'.
	row _ LayoutMorph newRow.
	row
		addMorph: instanceSwitch proportionalWidth: 0.45;
		addMorph: commentSwitch proportionalWidth: 0.22;
		addMorph: classSwitch proportionalWidth: 0.33.
	buttonColor _ self buttonColor.
	row color: buttonColor.
	{ 
		instanceSwitch.
		commentSwitch.
		classSwitch} do: [:m | 
				m color: buttonColor ].
	^row! !
!ChangeListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:02' prior: 16799310!
        optionalButtonRow
	"Answer a row of buttons to occur in a tool pane"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: model
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		buttons add: button.
		button setBalloonText: tuple fourth].
	buttons add: self lineDiffButton.
	widths add: 14.
	buttons add: self wordDiffButton.
	widths add: 16.
	model wantsPrettyDiffOption ifTrue: [
		buttons add:  self prettyLineDiffButton.
		widths add: 21.
		buttons add:  self prettyWordDiffButton.
		widths add: 23 ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16834872!
 customButtonRow
	"Answer a button pane affording the user one-touch access to certain functions; the pane is given the formal name 'customButtonPane' by which it can be retrieved by code wishing to send messages to widgets residing on the pane"

	| button buttons row buttonColor |
	
	buttons _ OrderedCollection new.
	buttonColor _ self buttonColor.
	"button with target = self"
	button _ PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #proceed.
	button color: buttonColor.
	button label: 'Proceed'.
	button setBalloonText: 'close the debugger and proceed.'.
	buttons add: button.
	"buttons with model target"
	self customButtonSpecs do: [ :tuple |
		button _ PluggableButtonMorph 
					model: model
					stateGetter: nil
					action: tuple second.
		button color: buttonColor.
		button label: tuple first asString.
		tuple size > 2 ifTrue: [button setBalloonText: tuple third].
		buttons add: button].

	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons.
	^row! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16851920!
                      buttonToTriggerIn: aFileList for: service
	"Answer a button that will trigger the receiver service in a file list"

	| aButton |
	service argumentProvider: aFileList.
	aButton := PluggableButtonMorph 
				model: service
				stateGetter: nil
				action: #performService.
	aButton label: service buttonLabel.
	aButton color: self buttonColor.
	aButton setBalloonText: service description.
	^aButton! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16851975!
                       optionalButtonRow
	"Answer the button row associated with a file list"

	| row buttonColor |
	row _ LayoutMorph newRow.
	buttonColor _ self buttonColor.
	row setProperty: #buttonRow toValue: true.  "Used for dynamic retrieval later on"
	row color: buttonColor.
	self updateButtonRow: row.
	^row! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16969152!
                           optionalButtonRow
	| row button buttons widths buttonColor |

	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | 
		widths add: tuple first.
		button _ PluggableButtonMorph 
			model: model
			stateGetter: nil
			action: tuple third.
		button color: buttonColor.
		button
			label: tuple second.
		buttons add: button].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:19' prior: 16969193!
                       refreshWindow
	| pc |
	pc _ self widgetsColor.
	passFailText color: pc.
	detailsText color: pc.
	model refreshTR! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:19' prior: 16969210!
                     updateColors
	| aTestResult theColor |
	theColor _ self widgetsColor.
	model ifNotNil: [
		model runButtonState ifFalse: [
			aTestResult _ model result.
			theColor _ aTestResult errors size + aTestResult failures size = 0
				ifTrue: [ Color green lighter ]
				ifFalse: [
					aTestResult errors size > 0
						ifTrue: [ Color red lighter ]
						ifFalse: [ Color yellow lighter ]]].
		self updatePartColors: theColor ]! !
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/23/2012 18:54'!
    array ^ #(nil true false)! !

ArrayLiteralTest removeSelector: #array!
!ArrayLiteralTest methodsFor: 'as yet unclassified' stamp: 'jmv 5/23/2012 18:54'!
       array ^ #(#nil #true #false #'nil' #'true' #'false')! !

ArrayLiteralTest removeSelector: #array!
!a subclass of Theme methodsFor: 'as yet unclassified' stamp: 'jmv 5/23/2012 18:54'!
         	shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 			-> #green.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 			-> #(blue muchDarker).
		#instVar 				-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 		-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 			-> #(gray muchDarker).
	}
! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 5/23/2012 18:55' prior: 16976584!
        changeTheme

	| themes set menu result |
		themes _ Theme allSubclasses copyWith: Theme.
		set _ themes collect: [ :i | { i asString . i } ].
		menu _ SelectionMenu fromArray: set asArray.
		result _ menu startUpWithCaption: 'Choose a theme'.

	result ifNotNil: [ result beCurrent ]! !

'From Cuis 4.0 of 21 April 2012 [latest update: #1288] on 22 May 2012 at 8:45:21 pm'!

'Description Please enter a description for this package '!

!classDefinition: #WintermuteTheme category: #'Cuis-ExtraThemes'!
Theme subclass: #WintermuteTheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cuis-ExtraThemes'!

Theme subclass: #WintermuteTheme
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Cuis-ExtraThemes'!

!classDefinition: 'WintermuteTheme class' category: #'Cuis-ExtraThemes'!
WintermuteTheme class
	instanceVariableNames: ''!

WintermuteTheme class
	instanceVariableNames: ''!
!WintermuteTheme commentStamp: '<historical>' prior: 0!
                 Most colors are the based on ColorTheme:
	baseColor adjustSaturation: -0.1 brightness: -0.7!
!WintermuteTheme methodsFor: 'colors' stamp: 'DSG 5/21/2012 14:24'!
                               background
	^ Color darkGray! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/21/2012 14:35'!
                       buttonGradientTopFactor
	"Will only be used for color themes that answer true to #roundButtons"
	^0.95! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/21/2012 14:25'!
             buttonLabel
	^Color darkGray! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/21/2012 13:18'!
                       defaultWindowColor
	^ Color lightGray! !
!WintermuteTheme methodsFor: 'other options' stamp: 'DSG 5/21/2012 13:29'!
            embossedTitles
	^false! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/21/2012 14:29'!
                             menu
	^ Color gray! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/20/2012 12:04'!
 menuText
	^Color gray: 0.9! !
!WintermuteTheme methodsFor: 'colors' stamp: 'DSG 5/21/2012 12:57'!
                              paneBackgroundFrom: aColor
	^ Color r: 28 g: 28 b: 28 range: 255! !
!WintermuteTheme methodsFor: 'other options' stamp: 'DSG 5/20/2012 12:04'!
                 roundWindowCorners
	^true! !
!WintermuteTheme methodsFor: 'colors' stamp: 'DSG 5/22/2012 10:37'!
                               roundedButtonRadius
	"Only effective if #roundButtons answers true.
	Provide a reasonable default for subclasses."
	^5! !
!WintermuteTheme methodsFor: 'colors' stamp: 'DSG 5/20/2012 12:06'!
  roundedWindowRadius
	"Only effective if #roundWindowCorners answers true.
	Provide a reasonable default for subclasses."
	^5! !
!WintermuteTheme methodsFor: 'shout' stamp: 'DSG 5/22/2012 11:14'!
                             shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> (Color r: 249 g: 238 b: 152 range: 255).
		#undefined 				-> (Color r: 155 g: 133 b: 157 range: 255).
		#methodTags 			-> (Color r: 115 g: 110 b: 115 range: 255).
		#pseudoVariables 		-> (Color r: 117 g: 175 b: 166 range: 255).
		#messages 				-> (Color r: 143 g: 157 b: 106 range: 255).
		#instVar 					-> (Color r: 207 g: 106 b: 76 range: 255).
		#incompleteMessages -> (Color r: 230 g: 230 b: 230 range: 255).
		#blockLevelFour 		-> #white.
		#blockLevelFive 		-> #green.
		#blockLevelSix 			-> #blue.
		#blockLevelSeven 		-> #red.
		#tempBar 				-> (Color r: 218 g: 239 b: 163 range: 255).
		#tempVars 				-> (Color r: 218 g: 239 b: 163 range: 255).
	}! !
!WintermuteTheme methodsFor: 'colors' stamp: 'DSG 5/22/2012 20:39'!
                               text
	^ Color veryLightGray! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/22/2012 10:21'!
                        textHighlight

	^Color r: 0.7 g: 1.0 b: 0.7 alpha: 0.2! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/21/2012 22:25'!
                             unfocusedTextHighlightFrom: aColor
	^aColor adjustSaturation: -0.35 brightness: -0.13! !
!WintermuteTheme methodsFor: 'other options' stamp: 'DSG 5/20/2012 12:04'!
                            useButtonGradient
	^true! !
!WintermuteTheme methodsFor: 'tool colors' stamp: 'DSG 5/21/2012 13:28'!
                           useUniformColors
	^true! !
!WintermuteTheme methodsFor: 'other options' stamp: 'DSG 5/20/2012 12:04'!
                          useWindowTitleGradient
	^true! !
!WintermuteTheme methodsFor: 'menu colors' stamp: 'DSG 5/21/2012 13:30'!
                      windowLabel
	^Color gray: 0.3! !

----End fileIn of /Volumes/CANON_DC/Cuis/davidgraham-Cuis-ExtraThemes-93e1c42/Cuis-ExtraThemes.pck----!
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:59'!
               textBackgroundColor

	^Theme current paneBackgroundFrom: self widgetsColor! !
!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 19:00' prior: 16965524!
  widgetsColor: aColor
	"aColor will be used for titles, borders, etc.
	A variation of it, #paneColorFrom:, will be used for panes background"
	widgetsColor _ aColor.
	self color: self textBackgroundColor.
	self adoptWidgetsColor: widgetsColor! !
!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 19:00' prior: 50360793!
                           widgetsColor: aColor
	"aColor will be used for titles, borders, etc.
	A variation of it, #paneColorFrom:, will be used for panes background"

	widgetsColor _ aColor.
	self color: self textBackgroundColor.
	self adoptWidgetsColor: widgetsColor! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:01' prior: 50358208!
             buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].
	backColor _ self textBackgroundColor.

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: Color white.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: Color white.
	messageList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:01' prior: 50360815!
           buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].
	backColor _ self textBackgroundColor.

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !

	Color veryLightGray!

	Color veryLightGray * 1.001!

	Color veryLightGray * 1.01!
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:04' prior: 50360910!
                           buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor |
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].
	backColor _ self textBackgroundColor.

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !

	CodePackageListWindow open: CodePackageList new!
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:07' prior: 50360290!
                    buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow description summary buttonRow browseChangesButton saveButton browseButton createButton deleteButton backColor labelBackground |
	backColor _ self textBackgroundColor.	"Instead of white"
	labelBackground _ Theme current background.	"instead of veryLightGray"
	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: Color white.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	names _ PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: Color white.
	names _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: 16;
		addMorphUseAll: names.

	fileNames _ PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: Color white.
	fileNames _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: 16;
		addMorphUseAll: fileNames.

	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: names proportionalWidth: 0.2;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.7.

	description _ TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary _ TextModelMorph
		textProvider: model
		textGetter: #summary.

	saveButton _ PluggableButtonMorph model: model action: #save label: 'Save (overwrite)'.
	createButton _ PluggableButtonMorph model: self action: #createPackage label: 'Create Package'.
	deleteButton _ PluggableButtonMorph model: self action: #deletePackage label: 'Delete (merge in Cuis)'.
	browseChangesButton _ PluggableButtonMorph model: self action: #browseChanges label: 'Browse unsaved changes'.
	browseButton _ PluggableButtonMorph model: self action: #browse label: 'Browse package code'.
	buttonRow _ LayoutMorph newRow.
	buttonRow
		color: self widgetsColor quiteWhiter;
		addMorph: saveButton proportionalWidth: 0.6;
		addMorph: createButton proportionalWidth: 0.6;
		addMorph: deleteButton proportionalWidth: 0.6;
		addMorph: browseChangesButton proportionalWidth: 0.6;
		addMorph: browseButton proportionalWidth: 0.6.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: summary proportionalHeight: 0.13;
		addAdjusterAndMorph: description proportionalHeight: 0.3;
		addAdjusterAndMorph: buttonRow proportionalHeight: 0.07.
	self setLabel: 'Installed Packages'! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:07' prior: 50361008!
     buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.	"Instead of white"
	labelBackground _ Theme current background.	"instead of veryLightGray"
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:08' prior: 50361105!
                            buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow description summary buttonRow browseChangesButton saveButton browseButton createButton deleteButton backColor labelBackground |
	backColor _ self textBackgroundColor.	"Instead of white"
	labelBackground _ Theme current background.	"instead of veryLightGray"
	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	names _ PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: 16;
		addMorphUseAll: names.

	fileNames _ PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: 16;
		addMorphUseAll: fileNames.

	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: names proportionalWidth: 0.2;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.7.

	description _ TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary _ TextModelMorph
		textProvider: model
		textGetter: #summary.

	saveButton _ PluggableButtonMorph model: model action: #save label: 'Save (overwrite)'.
	createButton _ PluggableButtonMorph model: self action: #createPackage label: 'Create Package'.
	deleteButton _ PluggableButtonMorph model: self action: #deletePackage label: 'Delete (merge in Cuis)'.
	browseChangesButton _ PluggableButtonMorph model: self action: #browseChanges label: 'Browse unsaved changes'.
	browseButton _ PluggableButtonMorph model: self action: #browse label: 'Browse package code'.
	buttonRow _ LayoutMorph newRow.
	buttonRow
		color: self widgetsColor quiteWhiter;
		addMorph: saveButton proportionalWidth: 0.6;
		addMorph: createButton proportionalWidth: 0.6;
		addMorph: deleteButton proportionalWidth: 0.6;
		addMorph: browseChangesButton proportionalWidth: 0.6;
		addMorph: browseButton proportionalWidth: 0.6.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: summary proportionalHeight: 0.13;
		addAdjusterAndMorph: description proportionalHeight: 0.3;
		addAdjusterAndMorph: buttonRow proportionalHeight: 0.07.
	self setLabel: 'Installed Packages'! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:09' prior: 50361204!
           buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.	"Instead of white"
	labelBackground _ Theme current background.	"instead of veryLightGray"
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: Color veryLightGray;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:09' prior: 50361303!
    buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow description summary buttonRow browseChangesButton saveButton browseButton createButton deleteButton backColor labelBackground |
	backColor _ self textBackgroundColor.	"Instead of white"
	labelBackground _ Theme current background.	"instead of veryLightGray"
	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	names _ PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: 16;
		addMorphUseAll: names.

	fileNames _ PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: 16;
		addMorphUseAll: fileNames.

	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: names proportionalWidth: 0.2;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.7.

	description _ TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary _ TextModelMorph
		textProvider: model
		textGetter: #summary.

	saveButton _ PluggableButtonMorph model: model action: #save label: 'Save (overwrite)'.
	createButton _ PluggableButtonMorph model: self action: #createPackage label: 'Create Package'.
	deleteButton _ PluggableButtonMorph model: self action: #deletePackage label: 'Delete (merge in Cuis)'.
	browseChangesButton _ PluggableButtonMorph model: self action: #browseChanges label: 'Browse unsaved changes'.
	browseButton _ PluggableButtonMorph model: self action: #browse label: 'Browse package code'.
	buttonRow _ LayoutMorph newRow.
	buttonRow
		color: self widgetsColor quiteWhiter;
		addMorph: saveButton proportionalWidth: 0.6;
		addMorph: createButton proportionalWidth: 0.6;
		addMorph: deleteButton proportionalWidth: 0.6;
		addMorph: browseChangesButton proportionalWidth: 0.6;
		addMorph: browseButton proportionalWidth: 0.6.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: summary proportionalHeight: 0.13;
		addAdjusterAndMorph: description proportionalHeight: 0.3;
		addAdjusterAndMorph: buttonRow proportionalHeight: 0.07.
	self setLabel: 'Installed Packages'! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:09' prior: 50361402!
                       buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.	"Instead of white"
	labelBackground _ Theme current background.	"instead of veryLightGray"
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:10' prior: 50361500!
        buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow description summary buttonRow browseChangesButton saveButton browseButton createButton deleteButton backColor labelBackground |
	backColor _ self textBackgroundColor.	"Instead of white"
	labelBackground _ Theme current background.
	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	names _ PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: 16;
		addMorphUseAll: names.

	fileNames _ PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: 16;
		addMorphUseAll: fileNames.

	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: names proportionalWidth: 0.2;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.7.

	description _ TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary _ TextModelMorph
		textProvider: model
		textGetter: #summary.

	saveButton _ PluggableButtonMorph model: model action: #save label: 'Save (overwrite)'.
	createButton _ PluggableButtonMorph model: self action: #createPackage label: 'Create Package'.
	deleteButton _ PluggableButtonMorph model: self action: #deletePackage label: 'Delete (merge in Cuis)'.
	browseChangesButton _ PluggableButtonMorph model: self action: #browseChanges label: 'Browse unsaved changes'.
	browseButton _ PluggableButtonMorph model: self action: #browse label: 'Browse package code'.
	buttonRow _ LayoutMorph newRow.
	buttonRow
		color: self widgetsColor quiteWhiter;
		addMorph: saveButton proportionalWidth: 0.6;
		addMorph: createButton proportionalWidth: 0.6;
		addMorph: deleteButton proportionalWidth: 0.6;
		addMorph: browseChangesButton proportionalWidth: 0.6;
		addMorph: browseButton proportionalWidth: 0.6.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: summary proportionalHeight: 0.13;
		addAdjusterAndMorph: description proportionalHeight: 0.3;
		addAdjusterAndMorph: buttonRow proportionalHeight: 0.07.
	self setLabel: 'Installed Packages'! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:11' prior: 50361599!
                  buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.	"Instead of white"
	labelBackground _ Theme current background.
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:11' prior: 50361697!
   buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow description summary buttonRow browseChangesButton saveButton browseButton createButton deleteButton backColor labelBackground |
	backColor _ self textBackgroundColor.	
	labelBackground _ Theme current background.
	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	names _ PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: 16;
		addMorphUseAll: names.

	fileNames _ PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: 16;
		addMorphUseAll: fileNames.

	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: names proportionalWidth: 0.2;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.7.

	description _ TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary _ TextModelMorph
		textProvider: model
		textGetter: #summary.

	saveButton _ PluggableButtonMorph model: model action: #save label: 'Save (overwrite)'.
	createButton _ PluggableButtonMorph model: self action: #createPackage label: 'Create Package'.
	deleteButton _ PluggableButtonMorph model: self action: #deletePackage label: 'Delete (merge in Cuis)'.
	browseChangesButton _ PluggableButtonMorph model: self action: #browseChanges label: 'Browse unsaved changes'.
	browseButton _ PluggableButtonMorph model: self action: #browse label: 'Browse package code'.
	buttonRow _ LayoutMorph newRow.
	buttonRow
		color: self widgetsColor quiteWhiter;
		addMorph: saveButton proportionalWidth: 0.6;
		addMorph: createButton proportionalWidth: 0.6;
		addMorph: deleteButton proportionalWidth: 0.6;
		addMorph: browseChangesButton proportionalWidth: 0.6;
		addMorph: browseButton proportionalWidth: 0.6.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: summary proportionalHeight: 0.13;
		addAdjusterAndMorph: description proportionalHeight: 0.3;
		addAdjusterAndMorph: buttonRow proportionalHeight: 0.07.
	self setLabel: 'Installed Packages'! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:12' prior: 50361795!
    buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.
	labelBackground _ Theme current background.
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:14' prior: 16852957!
                             drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas roundRect: bounds color: color radius: Theme current roundedWindowRadius ]
		ifFalse: [
			super drawOn: aCanvas ].
	aCanvas fillRectangle: textPane bounds colorOrInfiniteForm: ("Color gray: 0.88" Theme current background)! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:18' prior: 50362086!
            drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas roundRect: bounds color: color radius: Theme current roundedWindowRadius ]
		ifFalse: [
			super drawOn: aCanvas ].
	aCanvas fillRectangle: textPane bounds colorOrInfiniteForm: ("Color gray: 0.88" "Theme current background" color)! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:19' prior: 50362100!
    drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas roundRect: bounds color: color radius: Theme current roundedWindowRadius ]
		ifFalse: [
			super drawOn: aCanvas ].
	aCanvas fillRectangle: textPane bounds colorOrInfiniteForm: ("Color gray: 0.88" "Theme current background" Theme current paneBackgroundFrom:color)! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:20' prior: 50362114!
   drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas roundRect: bounds color: color radius: Theme current roundedWindowRadius ]
		ifFalse: [
			super drawOn: aCanvas ].
	aCanvas fillRectangle: textPane bounds colorOrInfiniteForm: (Theme current paneBackgroundFrom:color)! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:20' prior: 50362129!
                 drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas
				roundRect: bounds
				color: color
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ].
	aCanvas
		fillRectangle: textPane bounds
		colorOrInfiniteForm: (Theme current paneBackgroundFrom: color)! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 5/23/2012 19:23' prior: 16975339!
             messageNames

	self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.53 g: 0.77 b: 0.382 ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 5/23/2012 19:23' prior: 50362157!
                     messageNames

	^self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.53 g: 0.77 b: 0.382 ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 5/23/2012 19:23' prior: 50362164!
                    messageNames

	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.53 g: 0.77 b: 0.382 ]! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:25' prior: 50344254!
       buildUpperControls
	| refreshButton filterButton stopButton runOneButton runButton runProfiledButton row column1 column2 column3 theTestsList |

	refreshButton _ self buildRefreshButton.
	filterButton _ self buildFilterButton.
	stopButton _ self buildStopButton.
	column1 _ LayoutMorph newColumn.
	column1 addMorphs: { refreshButton . filterButton . stopButton }.

	theTestsList _ PluggableListMorphOfMany
				model: model
				listGetter: #tests
				primarySelectionGetter: #selectedSuite
				primarySelectionSetter: #selectedSuite:
				listSelectionGetter: #listSelectionAt:
				listSelectionSetter: #listSelectionAt:put:
				mainView: self
				menuGetter: #listMenu
				keystrokeAction: nil.
	theTestsList autoDeselect: false.
	theTestsList color: self textBackgroundColor.
	column2 _ LayoutMorph newColumn.
	column2
		addMorph: theTestsList proportionalHeight: 1;
		addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight.

	runOneButton _ self buildRunOneButton.
	runButton _ self buildRunButton.
	runProfiledButton := self buildRunProfiledButton.	
	column3 _ LayoutMorph newColumn.
	column3 addMorphs: { runOneButton . runButton . runProfiledButton }.
	
	row _ LayoutMorph newRow.
	row
		addMorph: column1 fixedWidth: 80;
		addMorph: column2 proportionalWidth: 1;
		addMorph: column3 fixedWidth: 120.

	^row

! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:28'!
                             drawLabelOn: aCanvas

	| availableW center colorForLabel f l labelMargin targetSize w x y |
	label ifNotNil: [
		colorForLabel _ Theme current buttonLabel.
		self isPressed
			ifFalse: [
				self mouseIsOver
					ifFalse: [ colorForLabel _ colorForLabel adjustSaturation: -0.10 brightness: 0.10 ]]
			ifTrue: [ colorForLabel _ colorForLabel adjustSaturation: 0.0 brightness: -0.07 ].
		f _ self fontToUse.
		center _ bounds center.
		labelMargin _ 3.
		w _ f widthOfString: label.
		availableW _ bounds width-labelMargin-labelMargin.
		availableW >= w
			ifTrue: [
				l _ label ]
			ifFalse: [
				x _ bounds left + labelMargin.
				targetSize _ label size * availableW // w.
				l _ label squeezedTo: targetSize.
				(f widthOfString: l) > availableW ifTrue: [
					targetSize _ targetSize - 1.
					l _ label squeezedTo: targetSize ]].
		
		w _ f widthOfString: l.
		x _ center x - (w // 2).
		y _ center y - (f height // 2).
		aCanvas
			drawStringEmbossed: l
			in: (x@y extent: bounds extent - (labelMargin*2-2@4))
			font: f
			color: colorForLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:29' prior: 50362223!
 drawLabelOn: aCanvas

	| w f center x y borderStyleSymbol c availableW l labelMargin |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: bounds
		colorOrInfiniteForm: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol.

	f _ self fontToUse.
	center _ bounds center.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ bounds width-labelMargin-labelMargin-1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ bounds left + labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			in: (x@y extent: bounds extent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:30' prior: 50362259!
                             drawLabelOn: aCanvas

	| w f center x y  availableW l labelMargin |

	f _ self fontToUse.
	center _ bounds center.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ bounds width-labelMargin-labelMargin-1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ bounds left + labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			in: (x@y extent: bounds extent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:30'!
    drawRegularLabelOn: aCanvas

	| w f center x y  availableW l labelMargin |

	f _ self fontToUse.
	center _ bounds center.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ bounds width-labelMargin-labelMargin-1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ bounds left + labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			in: (x@y extent: bounds extent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !

PluggableButtonMorph removeSelector: #drawLabelOn:!
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:30' prior: 16913500!
                        draw3DLookOn: aCanvas

	| f center borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: bounds
		colorOrInfiniteForm: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol.

	f _ self fontToUse.
	center _ bounds center.

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:31' prior: 50362341!
                    draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: bounds
		colorOrInfiniteForm: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol.

	self drawRegularLabelOn: aCanvas! !
!Theme methodsFor: 'other options' stamp: 'jmv 5/23/2012 19:33'!
     embossedButtonLabels
	"Currently only apply to rounded buttons!!"

	^true! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:33' prior: 16913585!
                         drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	rect _ bounds insetBy: 1@3.
	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!WintermuteTheme methodsFor: 'other options' stamp: 'jmv 5/23/2012 19:34'!
                  embossedButtonLabels
	"Currently only apply to rounded buttons!!"

	^false! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:36' prior: 16976511!
         shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(red muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:37' prior: 50362420!
                       shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:37' prior: 50362440!
                      shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue muchDarker).
		#messageArguments 	-> #(magenta muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:42' prior: 50362460!
       shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue muchDarker).
		#arguments 				-> #(magenta muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 5/23/2012 19:42' prior: 16975549!
                        generateShoutConfig

	| styles colors |
	
	styles := OrderedCollection new.
	colors := self shout as: Dictionary.

	{
		{self undefined. colors at: #undefined}.
		{self literals . colors at: #pseudoVariables}.
		{self defaults . colors at: #defaults}.
		{self pseudoVariables . colors at: #pseudoVariables}.
		{self blockLevelFour . colors at: #blockLevelFour}.
		{self instVar . colors at: #instVar}.
		{self messages . colors at: #messages}.
		{self blockLevelFive . colors at: #blockLevelFive}.
		{self blockLevelSix . colors at: #blockLevelSix}.
		{self blockLevelSeven . colors at: #blockLevelSeven}.
		{self tempBar . colors at: #tempBar}.
		{self methodTags . colors at: #methodTags . #bold}.
		{self globals . colors at: #defaults . #bold}.
		{self incompleteMessages . colors at: #incompleteMessages . #underlined}.
		{self argumentTypes . colors at: #arguments . #italic}.
		{self symbols . colors at: #messages . #bold}.
		{self nilly . nil . #bold}. "This one is odd.  --cbr"
		{self tempVars . colors at: #tempVars . #italic }.
		{self blockTemps . colors at: #tempBar . #italic}
	} do: [:style|
		styles addAll:
			(style first
				collect: [:category|
					Array withAll:
						(style asOrderedCollection
							removeFirst;
							addFirst: category;
							yourself)])].

	"Miscellaneous remainder after factoring out commonality:"
	self flag: #todo. "investigate meaning of nil in this context"
	styles addAll: {
		{#unfinishedString . colors at: #undefined . #normal}.
		{#undefinedIdentifier . colors at: #undefined . #bold}.
		{#unfinishedComment . colors at: #pseudoVariables . #italic}.
		{#comment . colors at: #methodTags . #italic}.
		{#string . colors at: #instVar . #normal}.
		{#literal . nil . #italic}.
		{#incompleteIdentifier . colors at: #tempVars . {#italic. #underlined}}.
		{#classVar . colors at: #tempVars . #bold}.
	}.

	^ styles! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:42' prior: 50362481!
      shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue muchDarker).
		#arguments 				-> #(yellow muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 5/23/2012 19:44' prior: 50362503!
                         generateShoutConfig

	| styles colors |
	
	styles := OrderedCollection new.
	colors := self shout as: Dictionary.

	{
		{self undefined. colors at: #undefined}.
		{self literals . colors at: #pseudoVariables}.
		{self defaults . colors at: #defaults}.
		{self pseudoVariables . colors at: #pseudoVariables}.
		{self blockLevelFour . colors at: #blockLevelFour}.
		{self instVar . colors at: #instVar}.
		{self messages . colors at: #messages}.
		{self blockLevelFive . colors at: #blockLevelFive}.
		{self blockLevelSix . colors at: #blockLevelSix}.
		{self blockLevelSeven . colors at: #blockLevelSeven}.
		{self tempBar . colors at: #tempBar}.
		{self methodTags . colors at: #methodTags . #bold}.
		{self globals . colors at: #defaults . #bold}.
		{self incompleteMessages . colors at: #incompleteMessages . #underlined}.
		{self argumentTypes . colors at: #arguments . #italic}.
		{self symbols . colors at: #messages . #bold}.
		{self nilly . nil . #bold}. "This one is odd.  --cbr"
		{self tempVars . colors at: #tempVars . #italic }.
		{self blockTemps . colors at: #tempBar . #italic}
	} do: [:style|
		styles addAll:
			(style first
				collect: [ :category | | elements |
					elements _ style asOrderedCollection
							removeFirst;
							addFirst: category;
							yourself.
					Array withAll: elements ])].

	"Miscellaneous remainder after factoring out commonality:"
	self flag: #todo. "investigate meaning of nil in this context"
	styles addAll: {
		{#unfinishedString . colors at: #undefined . #normal}.
		{#undefinedIdentifier . colors at: #undefined . #bold}.
		{#unfinishedComment . colors at: #pseudoVariables . #italic}.
		{#comment . colors at: #methodTags . #italic}.
		{#string . colors at: #instVar . #normal}.
		{#literal . nil . #italic}.
		{#incompleteIdentifier . colors at: #tempVars . {#italic. #underlined}}.
		{#classVar . colors at: #tempVars . #bold}.
	}.

	^ styles! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 5/23/2012 19:46' prior: 50362586!
                 generateShoutConfig

	| styles colors |
	
	styles := OrderedCollection new.
	colors := self shout as: Dictionary.

	{
		{self undefined. colors at: #undefined}.
		{self literals . colors at: #pseudoVariables}.
		{self defaults . colors at: #defaults}.
		{self pseudoVariables . colors at: #pseudoVariables}.
		{self blockLevelFour . colors at: #blockLevelFour}.
		{self instVar . colors at: #instVar}.
		{self messages . colors at: #messages}.
		{self blockLevelFive . colors at: #blockLevelFive}.
		{self blockLevelSix . colors at: #blockLevelSix}.
		{self blockLevelSeven . colors at: #blockLevelSeven}.
		{self tempBar . colors at: #tempBar}.
		{self methodTags . colors at: #methodTags . #bold}.
		{self globals . colors at: #defaults . #bold}.
		{self incompleteMessages . colors at: #incompleteMessages . #underlined}.
		{self argumentTypes . colors at: #arguments . #italic}.
		{self symbols . colors at: #messages . #bold}.
		{self nilly . nil . #bold}. "This one is odd.  --cbr"
		{self tempVars . colors at: #tempVars . #italic }.
		{self blockTemps . colors at: #tempBar . #italic}
	} do: [:style|
		styles addAll:
			(style first
				collect: [ :category | | elements |
					elements _ style asOrderedCollection.
					elements at: 1 put: category.
					Array withAll: elements ])].

	"Miscellaneous remainder after factoring out commonality:"
	self flag: #todo. "investigate meaning of nil in this context"
	styles addAll: {
		{#unfinishedString . colors at: #undefined . #normal}.
		{#undefinedIdentifier . colors at: #undefined . #bold}.
		{#unfinishedComment . colors at: #pseudoVariables . #italic}.
		{#comment . colors at: #methodTags . #italic}.
		{#string . colors at: #instVar . #normal}.
		{#literal . nil . #italic}.
		{#incompleteIdentifier . colors at: #tempVars . {#italic. #underlined}}.
		{#classVar . colors at: #tempVars . #bold}.
	}.

	^ styles! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:47'!
                italizeArguments

	^true! !
!WintermuteTheme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:47'!
 italizeArguments

	^false! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 5/23/2012 19:48' prior: 50362649!
       generateShoutConfig

	| styles colors |
	
	styles := OrderedCollection new.
	colors := self shout as: Dictionary.

	{
		{self undefined. colors at: #undefined}.
		{self literals . colors at: #pseudoVariables}.
		{self defaults . colors at: #defaults}.
		{self pseudoVariables . colors at: #pseudoVariables}.
		{self blockLevelFour . colors at: #blockLevelFour}.
		{self instVar . colors at: #instVar}.
		{self messages . colors at: #messages}.
		{self blockLevelFive . colors at: #blockLevelFive}.
		{self blockLevelSix . colors at: #blockLevelSix}.
		{self blockLevelSeven . colors at: #blockLevelSeven}.
		{self tempBar . colors at: #tempBar}.
		{self methodTags . colors at: #methodTags . #bold}.
		{self globals . colors at: #defaults . #bold}.
		{self incompleteMessages . colors at: #incompleteMessages . #underlined}.
		{self argumentTypes . colors at: #arguments . #italicArguments}.
		{self symbols . colors at: #messages . #bold}.
		{self nilly . nil . #bold}. "This one is odd.  --cbr"
		{self tempVars . colors at: #tempVars . #italic }.
		{self blockTemps . colors at: #tempBar . #italic}
	} do: [:style|
		styles addAll:
			(style first
				collect: [ :category | | elements |
					elements _ style asOrderedCollection.
					elements at: 1 put: category.
					Array withAll: elements ])].

	"Miscellaneous remainder after factoring out commonality:"
	self flag: #todo. "investigate meaning of nil in this context"
	styles addAll: {
		{#unfinishedString . colors at: #undefined . #normal}.
		{#undefinedIdentifier . colors at: #undefined . #bold}.
		{#unfinishedComment . colors at: #pseudoVariables . #italic}.
		{#comment . colors at: #methodTags . #italic}.
		{#string . colors at: #instVar . #normal}.
		{#literal . nil . #italic}.
		{#incompleteIdentifier . colors at: #tempVars . {#italic. #underlined}}.
		{#classVar . colors at: #tempVars . #bold}.
	}.

	^ styles! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 5/23/2012 19:50' prior: 50362717!
    generateShoutConfig

	| styles colors |
	
	styles := OrderedCollection new.
	colors := self shout as: Dictionary.

	{
		{self undefined. colors at: #undefined}.
		{self literals . colors at: #pseudoVariables}.
		{self defaults . colors at: #defaults}.
		{self pseudoVariables . colors at: #pseudoVariables}.
		{self blockLevelFour . colors at: #blockLevelFour}.
		{self instVar . colors at: #instVar}.
		{self messages . colors at: #messages}.
		{self blockLevelFive . colors at: #blockLevelFive}.
		{self blockLevelSix . colors at: #blockLevelSix}.
		{self blockLevelSeven . colors at: #blockLevelSeven}.
		{self tempBar . colors at: #tempBar}.
		{self methodTags . colors at: #methodTags . #bold}.
		{self globals . colors at: #defaults . #bold}.
		{self incompleteMessages . colors at: #incompleteMessages . #underlined}.
		{self argumentTypes . colors at: #arguments . #italicArguments}.
		{self symbols . colors at: #messages . #bold}.
		{self nilly . nil . #bold}. "This one is odd.  --cbr"
		{self tempVars . colors at: #tempVars . #italic }.
		{self blockTemps . colors at: #tempBar . #italic}
	} do: [:style|
		styles addAll:
			(style first
				collect: [ :category | | elements |
					elements _ style asOrderedCollection.
					elements at: 1 put: category.
					elements last = #italicArguments ifTrue: [
						self italizeArguments
							ifTrue: [ elements at: 3 put: #italic ]
							ifFalse: [ elements removeLast ]].
					Array withAll: elements ])].

	"Miscellaneous remainder after factoring out commonality:"
	self flag: #todo. "investigate meaning of nil in this context"
	styles addAll: {
		{#unfinishedString . colors at: #undefined . #normal}.
		{#undefinedIdentifier . colors at: #undefined . #bold}.
		{#unfinishedComment . colors at: #pseudoVariables . #italic}.
		{#comment . colors at: #methodTags . #italic}.
		{#string . colors at: #instVar . #normal}.
		{#literal . nil . #italic}.
		{#incompleteIdentifier . colors at: #tempVars . {#italic. #underlined}}.
		{#classVar . colors at: #tempVars . #bold}.
	}.

	^ styles! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:50' prior: 50362710!
                  italizeArguments

	^true not! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:50' prior: 50362564!
                       shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue muchDarker).
		#arguments 				-> #(blue muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:50' prior: 50362846!
              italizeArguments

	^true! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:51' prior: 50362850!
                           shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue muchDarker).
		#arguments 				-> #(blue).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:51' prior: 50362875!
                         shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(blue).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:52' prior: 50362896!
                             shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(green darker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:52' prior: 50362917!
                     shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(green muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:53' prior: 50362938!
                 shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(gray muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:54' prior: 50362871!
                  italizeArguments

	^true not! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:54' prior: 50362980!
                       italizeArguments

	^true! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:54' prior: 50362959!
                           shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(gray veryMuchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:55' prior: 50362988!
              shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(blue darker duller).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:55' prior: 50363009!
               shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(blue duller).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:56' prior: 50363030!
                      shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(darktan duller).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:56' prior: 50363051!
                   shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #darktan.
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:57' prior: 50363072!
                            shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #darktan.
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(blue muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:57' prior: 50363093!
                            shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #darktan.
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:57' prior: 50363114!
                            shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #paleTan.
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:58' prior: 50363135!
                            shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(lightBlue darker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:58' prior: 50363156!
                 shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(blue darker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 19:59' prior: 50363177!
                      shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(orange veryMuchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:00' prior: 50363198!
            shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(orange blacker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:01' prior: 50363219!
                   shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(orange quiteBlacker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:01' prior: 50363240!
              shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(orange twiceDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:02' prior: 50363261!
               shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(darktan twiceDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:02' prior: 50363282!
              shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(darktan blaker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:02' prior: 50363303!
                   shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(darktan blacker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:02' prior: 50363324!
                  shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(darktan blaker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:01' prior: 50363345!
                   shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(orange twiceDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:03' prior: 50363366!
               shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(orange blacker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:04' prior: 50363387!
                   shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(darkTan blacker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:04' prior: 50363408!
                  shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(darktan blacker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:01' prior: 50363429!
                  shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(orange twiceDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:04' prior: 50363450!
               shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(darktan blacker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !

Color darktan blacker!

Color darktan muchDarker!
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:05' prior: 50363471!
                               shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(darktan muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !

Color darktan darker!
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:06' prior: 50363494!
                        shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(darktan muchdarkerDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:06' prior: 50363516!
         shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(darktan darker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:06' prior: 50363537!
                   shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(cyan darker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:06' prior: 50363558!
                      shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(cyan muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:07' prior: 50362984!
                  italizeArguments

	^true not! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:07' prior: 50363600!
                       italizeArguments

	^true! !

----QUIT/NOSAVE----#(23 May 2012 9:53:32 pm) Cuis4.0-1288.image priorSource: 866683!

----STARTUP----#(23 May 2012 9:54:12 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0-1288.image!


'From Cuis 4.0 of 21 April 2012 [latest update: #1288] on 23 May 2012 at 8:07:33 pm'!
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:30'!
                    drawRegularLabelOn: aCanvas

	| w f center x y  availableW l labelMargin |

	f _ self fontToUse.
	center _ bounds center.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ bounds width-labelMargin-labelMargin-1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ bounds left + labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			in: (x@y extent: bounds extent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:17'!
buttonColor

	^Theme current buttonColorFrom: self widgetsColor! !
!SystemWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:59'!
                      textBackgroundColor

	^Theme current paneBackgroundFrom: self widgetsColor! !
!Theme methodsFor: 'other options' stamp: 'jmv 5/23/2012 19:33'!
                 embossedButtonLabels
	"Currently only apply to rounded buttons!!"

	^true! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:07'!
                          italizeArguments

	^true! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:06' prior: 16852813!
    createAcceptButton
	"create the [accept] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current acceptButton;
		 label: 'Accept';
		 action: #acceptClicked.
	result bounds: (29@90 corner: 122@117).
	self addMorph: result.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:08' prior: 16852830!
             createCancelButton
	"create the [cancel] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current cancelButton;
		 label: 'Cancel';
		 action: #cancelClicked.
	result bounds: (149@90 corner: 242@117).
	self addMorph: result.
	^ result! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:20' prior: 16852957!
                   drawOn: aCanvas
	| roundCorners |
	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			aCanvas
				roundRect: bounds
				color: color
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ].
	aCanvas
		fillRectangle: textPane bounds
		colorOrInfiniteForm: (Theme current paneBackgroundFrom: color)! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:31' prior: 16913500!
  draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: bounds
		colorOrInfiniteForm: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol.

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 19:33' prior: 16913585!
            drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	rect _ bounds insetBy: 1@3.
	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 5/23/2012 18:43' prior: 16965269!
    openInWorld
	"Ensure all widgets have proper colors before opening"
	self widgetsColor: self widgetsColor.
	super openInWorld! !
!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 18:46' prior: 16965514!
               widgetsColor

	widgetsColor ifNotNil: [ ^ widgetsColor ].
	^Display depth > 2
		ifTrue: [ self windowColor ]
		ifFalse: [ Color white ]! !
!SystemWindow methodsFor: 'panes' stamp: 'jmv 5/23/2012 19:00' prior: 16965524!
     widgetsColor: aColor
	"aColor will be used for titles, borders, etc.
	A variation of it, #paneColorFrom:, will be used for panes background"

	widgetsColor _ aColor.
	self color: self textBackgroundColor.
	self adoptWidgetsColor: widgetsColor! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:11' prior: 16813416!
          buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow description summary buttonRow browseChangesButton saveButton browseButton createButton deleteButton backColor labelBackground |
	backColor _ self textBackgroundColor.	
	labelBackground _ Theme current background.
	dirtyFlags _ PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	names _ PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: 16;
		addMorphUseAll: names.

	fileNames _ PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: 16;
		addMorphUseAll: fileNames.

	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: names proportionalWidth: 0.2;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.7.

	description _ TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary _ TextModelMorph
		textProvider: model
		textGetter: #summary.

	saveButton _ PluggableButtonMorph model: model action: #save label: 'Save (overwrite)'.
	createButton _ PluggableButtonMorph model: self action: #createPackage label: 'Create Package'.
	deleteButton _ PluggableButtonMorph model: self action: #deletePackage label: 'Delete (merge in Cuis)'.
	browseChangesButton _ PluggableButtonMorph model: self action: #browseChanges label: 'Browse unsaved changes'.
	browseButton _ PluggableButtonMorph model: self action: #browse label: 'Browse package code'.
	buttonRow _ LayoutMorph newRow.
	buttonRow
		color: self widgetsColor quiteWhiter;
		addMorph: saveButton proportionalWidth: 0.6;
		addMorph: createButton proportionalWidth: 0.6;
		addMorph: deleteButton proportionalWidth: 0.6;
		addMorph: browseChangesButton proportionalWidth: 0.6;
		addMorph: browseButton proportionalWidth: 0.6.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: summary proportionalHeight: 0.13;
		addAdjusterAndMorph: description proportionalHeight: 0.3;
		addAdjusterAndMorph: buttonRow proportionalHeight: 0.07.
	self setLabel: 'Installed Packages'! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16814896!
            optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!CodeWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:02' prior: 16815041!
                decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColor aButton flags buttonColor |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColor _ self buttonColor.

	Preferences decorateBrowserButtons
		ifFalse: [ ^aButton color: buttonColor ].
	cm _ model currentCompiledMethod.
	(cm isKindOf: CompiledMethod)
		ifFalse: [ ^aButton color: buttonColor ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColor _ {

		"This is NOTan override. There is no super implementation."
		buttonColor.							"no sends to super. there is not override in any subclass"
		Color tan.							"no sends to super. there is an override in some subclass"
		Color red.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		Color red.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		Color red muchLighter.			"doesn't have sub; has super but doesn't call it"
		Color r: 0.94 g: 0.823 b: 0.673.		"has sub; has super but doesn't call it"
		Color green muchLighter.			"doesn't have sub; has super and callsl it"
		Color blue muchLighter.			"has sub; has super and callsl it"

	} at: flags + 1.
	aButton color: aColor! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:02' prior: 16795512!
   buildMorphicSwitches
	| instanceSwitch commentSwitch classSwitch row buttonColor |
	instanceSwitch := PluggableButtonMorph 
				model: model
				stateGetter: #instanceMessagesIndicated
				action: #indicateInstanceMessages.
	instanceSwitch
		label: 'instance'.
	commentSwitch := PluggableButtonMorph 
				model: model
				stateGetter: #classCommentIndicated
				action: #plusButtonHit.
	commentSwitch
		label: '?';
		setBalloonText: 'class comment'.
	classSwitch := PluggableButtonMorph 
				model: model
				stateGetter: #classMessagesIndicated
				action: #indicateClassMessages.
	classSwitch
		label: 'class'.
	row _ LayoutMorph newRow.
	row
		addMorph: instanceSwitch proportionalWidth: 0.45;
		addMorph: commentSwitch proportionalWidth: 0.22;
		addMorph: classSwitch proportionalWidth: 0.33.
	buttonColor _ self buttonColor.
	row color: buttonColor.
	{ 
		instanceSwitch.
		commentSwitch.
		classSwitch} do: [:m | 
				m color: buttonColor ].
	^row! !
!ChangeListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:02' prior: 16799310!
        optionalButtonRow
	"Answer a row of buttons to occur in a tool pane"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: model
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second asString.
		buttons add: button.
		button setBalloonText: tuple fourth].
	buttons add: self lineDiffButton.
	widths add: 14.
	buttons add: self wordDiffButton.
	widths add: 16.
	model wantsPrettyDiffOption ifTrue: [
		buttons add:  self prettyLineDiffButton.
		widths add: 21.
		buttons add:  self prettyWordDiffButton.
		widths add: 23 ].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:12' prior: 50358208!
                             buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.
	labelBackground _ Theme current background.
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: 16;
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Change Set name') fixedHeight: 16;
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Classes') fixedHeight: 16;
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.1;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.5;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (Morph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: 'Methods') fixedHeight: 16;
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.5.

	self setLabel: model labelString! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16834872!
                             customButtonRow
	"Answer a button pane affording the user one-touch access to certain functions; the pane is given the formal name 'customButtonPane' by which it can be retrieved by code wishing to send messages to widgets residing on the pane"

	| button buttons row buttonColor |
	
	buttons _ OrderedCollection new.
	buttonColor _ self buttonColor.
	"button with target = self"
	button _ PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #proceed.
	button color: buttonColor.
	button label: 'Proceed'.
	button setBalloonText: 'close the debugger and proceed.'.
	buttons add: button.
	"buttons with model target"
	self customButtonSpecs do: [ :tuple |
		button _ PluggableButtonMorph 
					model: model
					stateGetter: nil
					action: tuple second.
		button color: buttonColor.
		button label: tuple first asString.
		tuple size > 2 ifTrue: [button setBalloonText: tuple third].
		buttons add: button].

	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons.
	^row! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16851920!
                      buttonToTriggerIn: aFileList for: service
	"Answer a button that will trigger the receiver service in a file list"

	| aButton |
	service argumentProvider: aFileList.
	aButton := PluggableButtonMorph 
				model: service
				stateGetter: nil
				action: #performService.
	aButton label: service buttonLabel.
	aButton color: self buttonColor.
	aButton setBalloonText: service description.
	^aButton! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16851975!
                       optionalButtonRow
	"Answer the button row associated with a file list"

	| row buttonColor |
	row _ LayoutMorph newRow.
	buttonColor _ self buttonColor.
	row setProperty: #buttonRow toValue: true.  "Used for dynamic retrieval later on"
	row color: buttonColor.
	self updateButtonRow: row.
	^row! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 19:25' prior: 50344254!
                           buildUpperControls
	| refreshButton filterButton stopButton runOneButton runButton runProfiledButton row column1 column2 column3 theTestsList |

	refreshButton _ self buildRefreshButton.
	filterButton _ self buildFilterButton.
	stopButton _ self buildStopButton.
	column1 _ LayoutMorph newColumn.
	column1 addMorphs: { refreshButton . filterButton . stopButton }.

	theTestsList _ PluggableListMorphOfMany
				model: model
				listGetter: #tests
				primarySelectionGetter: #selectedSuite
				primarySelectionSetter: #selectedSuite:
				listSelectionGetter: #listSelectionAt:
				listSelectionSetter: #listSelectionAt:put:
				mainView: self
				menuGetter: #listMenu
				keystrokeAction: nil.
	theTestsList autoDeselect: false.
	theTestsList color: self textBackgroundColor.
	column2 _ LayoutMorph newColumn.
	column2
		addMorph: theTestsList proportionalHeight: 1;
		addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight.

	runOneButton _ self buildRunOneButton.
	runButton _ self buildRunButton.
	runProfiledButton := self buildRunProfiledButton.	
	column3 _ LayoutMorph newColumn.
	column3 addMorphs: { runOneButton . runButton . runProfiledButton }.
	
	row _ LayoutMorph newRow.
	row
		addMorph: column1 fixedWidth: 80;
		addMorph: column2 proportionalWidth: 1;
		addMorph: column3 fixedWidth: 120.

	^row

! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 5/23/2012 18:03' prior: 16969152!
            optionalButtonRow
	| row button buttons widths buttonColor |

	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | 
		widths add: tuple first.
		button _ PluggableButtonMorph 
			model: model
			stateGetter: nil
			action: tuple third.
		button color: buttonColor.
		button
			label: tuple second.
		buttons add: button].
	row _ LayoutMorph newRow.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:19' prior: 16969193!
                       refreshWindow
	| pc |
	pc _ self widgetsColor.
	passFailText color: pc.
	detailsText color: pc.
	model refreshTR! !
!TestRunnerWindow methodsFor: 'updating' stamp: 'jmv 5/23/2012 18:19' prior: 16969210!
                     updateColors
	| aTestResult theColor |
	theColor _ self widgetsColor.
	model ifNotNil: [
		model runButtonState ifFalse: [
			aTestResult _ model result.
			theColor _ aTestResult errors size + aTestResult failures size = 0
				ifTrue: [ Color green lighter ]
				ifFalse: [
					aTestResult errors size > 0
						ifTrue: [ Color red lighter ]
						ifFalse: [ Color yellow lighter ]]].
		self updatePartColors: theColor ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 5/23/2012 19:23' prior: 16975339!
       messageNames

	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.53 g: 0.77 b: 0.382 ]! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:49' prior: 16975390!
                 acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.2 g: 0.6 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:51' prior: 16975395!
                        cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.8 g: 0.2 b: 0.2 ])! !
!Theme methodsFor: 'private - shout mappings' stamp: 'jmv 5/23/2012 19:50' prior: 16975549!
             generateShoutConfig

	| styles colors |
	
	styles := OrderedCollection new.
	colors := self shout as: Dictionary.

	{
		{self undefined. colors at: #undefined}.
		{self literals . colors at: #pseudoVariables}.
		{self defaults . colors at: #defaults}.
		{self pseudoVariables . colors at: #pseudoVariables}.
		{self blockLevelFour . colors at: #blockLevelFour}.
		{self instVar . colors at: #instVar}.
		{self messages . colors at: #messages}.
		{self blockLevelFive . colors at: #blockLevelFive}.
		{self blockLevelSix . colors at: #blockLevelSix}.
		{self blockLevelSeven . colors at: #blockLevelSeven}.
		{self tempBar . colors at: #tempBar}.
		{self methodTags . colors at: #methodTags . #bold}.
		{self globals . colors at: #defaults . #bold}.
		{self incompleteMessages . colors at: #incompleteMessages . #underlined}.
		{self argumentTypes . colors at: #arguments . #italicArguments}.
		{self symbols . colors at: #messages . #bold}.
		{self nilly . nil . #bold}. "This one is odd.  --cbr"
		{self tempVars . colors at: #tempVars . #italic }.
		{self blockTemps . colors at: #tempBar . #italic}
	} do: [:style|
		styles addAll:
			(style first
				collect: [ :category | | elements |
					elements _ style asOrderedCollection.
					elements at: 1 put: category.
					elements last = #italicArguments ifTrue: [
						self italizeArguments
							ifTrue: [ elements at: 3 put: #italic ]
							ifFalse: [ elements removeLast ]].
					Array withAll: elements ])].

	"Miscellaneous remainder after factoring out commonality:"
	self flag: #todo. "investigate meaning of nil in this context"
	styles addAll: {
		{#unfinishedString . colors at: #undefined . #normal}.
		{#undefinedIdentifier . colors at: #undefined . #bold}.
		{#unfinishedComment . colors at: #pseudoVariables . #italic}.
		{#comment . colors at: #methodTags . #italic}.
		{#string . colors at: #instVar . #normal}.
		{#literal . nil . #italic}.
		{#incompleteIdentifier . colors at: #tempVars . {#italic. #underlined}}.
		{#classVar . colors at: #tempVars . #bold}.
	}.

	^ styles! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/23/2012 20:06' prior: 16976511!
                  shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #black.
		#undefined 				-> #red.
		#methodTags 			-> #(green muchDarker).
		#pseudoVariables 		-> #(red muchDarker).
		#messages 				-> #(blue darker).
		#arguments 				-> #(cyan muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#incompleteMessages -> #(gray veryMuchDarker).
		#blockLevelFour 		-> #(green darker).
		#blockLevelFive 		-> #(orange darker).
		#blockLevelSix 			-> #(magenta darker).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #gray.
		#tempVars 				-> #(gray muchDarker).
	}! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 5/23/2012 18:55' prior: 16976584!
   changeTheme

	| themes set menu result |
		themes _ Theme allSubclasses copyWith: Theme.
		set _ themes collect: [ :i | { i asString . i } ].
		menu _ SelectionMenu fromArray: set asArray.
		result _ menu startUpWithCaption: 'Choose a theme'.

	result ifNotNil: [ result beCurrent ]! !

PluggableButtonMorph removeSelector: #drawLabelOn:!

----End fileIn of /Volumes/CANON_DC/Cuis/1289-FixIssues001to005-JuanVuletich-2012May23-18h45m-jmv.9.cs----!

----SNAPSHOT----#(23 May 2012 9:55:09 pm) Cuis4.0-1289.image priorSource: 866683!

----QUIT/NOSAVE----#(23 May 2012 9:55:17 pm) Cuis4.0-1289.image priorSource: 1047615!

----STARTUP----#(23 May 2012 10:00:37 pm) as /Volumes/CANON_DC/Cuis/Cuis4.0-1289.image!


'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 2:34:25 pm'!
!DropEvent methodsFor: 'accessing' stamp: 'jmv 12/11/2011 23:10'!
  eventPosition
	^position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:42'!
       morphPosition
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"
	^ bounds topLeft! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:43'!
          morphPosition: aPoint
	"Change the position of this morph and and all of its submorphs."

	"Detesto el falso polimorfismo con streams. Ponerle otro nombre a esto!!
	Igual, todavia esta #position, el getter, que es igual de feo..."
	
	"
	VER SENDERS. Acomodar. el argumento es en coord del owner o del world?
	Convertir los senders a senders de #zzpositionInOwner: o #zzpositionInWorld
	Espero que pocos hablen en coordenadas del world!!
	"

	| delta |
	delta _ aPoint - bounds topLeft.
	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.
	self privateFullMoveBy: delta.

	"En realidad, quiero coordenadas relativas al owner!!"
"	position _ aPoint."

	self redrawNeeded
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!HaloMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:43'!
                        morphPosition: pos
	"Halos display imprefectly if their coordinates are non-integral
		-- especially the direction handles."

	^ super morphPosition: pos asIntegerPoint! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:44'!
                morphPosition: aPoint
	"Prevent moving a world (e.g. via HandMorph>>specialGesture:)"

	"for now, let's allow it and see what happens"

	self isWorldMorph ifFalse: [ ^super morphPosition: aPoint ].
	super morphPosition: aPoint.
	self viewBox ifNotNil: [ self viewBox: (aPoint extent: self viewBox extent) ]! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:44'!
      morphPosition: newPos
	super morphPosition: newPos.
	isCollapsed
		ifTrue: [ collapsedFrame _ bounds ]
		ifFalse: [ fullFrame _ bounds ]! !
!UserInputEvent methodsFor: 'accessing' stamp: 'jmv 12/11/2011 23:10'!
             eventPosition
	^position! !
!MouseEvent methodsFor: 'accessing' stamp: 'jmv 12/11/2011 23:12'!
 eventPosition
	"Answer the location of the cursor's hotspot when this event occured."
	^ position! !
!AbstractSound methodsFor: 'file i/o' stamp: 'jmv 12/12/2011 10:43' prior: 16779362!
      storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream
	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files). If self isStereo is true, both channels are stored, creating a stereo file. Otherwise, only the left channel is stored, creating a mono file."

	| bufSize stereoBuffer reverseBytes  |
	self reset.
	bufSize _ (2 * self samplingRate rounded) min: samplesToStore.  "two second buffer"
	stereoBuffer _ SoundBuffer newStereoSampleCount: bufSize.
	reverseBytes _ bigEndianFlag ~= Smalltalk isBigEndian.

	'Storing audio...' displayProgressAt: World activeHand morphPosition
		from: 0 to: samplesToStore during: [:bar | | remaining out |
			remaining _ samplesToStore.
			[remaining > 0] whileTrue: [
				bar value: samplesToStore - remaining.
				stereoBuffer primFill: 0.  "clear the buffer"
				self playSampleCount: (bufSize min: remaining) into: stereoBuffer startingAt: 1.
				self isStereo
					ifTrue: [out _ stereoBuffer]
					ifFalse: [out _ stereoBuffer extractLeftChannel].
				reverseBytes ifTrue: [out reverseEndianness].
				(aBinaryStream isKindOf: StandardFileStream)
					ifTrue: [  "optimization for files: write sound buffer directly to file"
						aBinaryStream next: (out size // 2) putAll: out startingAt: 1]  "size in words"
					ifFalse: [  "for non-file streams:"
						1 to: out monoSampleCount do: [:i | aBinaryStream int16: (out at: i)]].
				remaining _ remaining - bufSize]].
! !
!AutoCompleter methodsFor: 'menu morph' stamp: 'jmv 12/12/2011 10:43' prior: 16783264!
                   openCompletionMenu
	| theEditor |
	theEditor _ textMorph editor.
	position _ theEditor startIndex - 1.
	self closeMenu.
	self computeEntries.
	entries notEmpty
		ifTrue: [ 
			menuMorph _  AutoCompleterMorph 
				completer: self
				position: theEditor startBlock bottomLeft + textMorph morphPosition ]! !
!CodePackage methodsFor: 'testing' stamp: 'jmv 4/10/2012 14:22' prior: 16812459!
                             changeRecordForOverriddenMethod: aMethodReference
	| sourceFilesCopy method position |
	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.
	position := method filePosition.
	sourceFilesCopy := SourceFiles collect:
		[:x | x isNil ifTrue: [ nil ]
				ifFalse: [x readOnlyCopy]].
	[ | file prevPos prevFileIndex chunk stamp methodCategory tokens |
	method fileIndex = 0 ifTrue: [^ nil].
	file := sourceFilesCopy at: method fileIndex.
	[position notNil & file notNil] whileTrue: [
		file position: (0 max: position-150).  "Skip back to before the preamble"
		[file position < (position-1)]  "then pick it up from the front"
			whileTrue: [ chunk _ file nextChunk ].

		"Preamble is likely a linked method preamble, if we're in
			a changes file (not the sources file).  Try to parse it
			for prior source position and file index"
		prevPos := nil.
		stamp := ''.
		(chunk findString: 'methodsFor:' startingAt: 1) > 0
			ifTrue: [tokens := Scanner new scanTokens: chunk]
			ifFalse: [tokens := #()  "ie cant be back ref"].
		((tokens size between: 7 and: 8)
			and: [(tokens at: tokens size-5) = #methodsFor:])
			ifTrue:
				[(tokens at: tokens size-3) = #stamp:
				ifTrue: ["New format gives change stamp and unified prior pointer"
						stamp := tokens at: tokens size-2.
						prevPos := tokens last.
						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.
						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]
				ifFalse: ["Old format gives no stamp; prior pointer in two parts"
						prevPos := tokens at: tokens size-2.
						prevFileIndex := tokens last].
				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].
		((tokens size between: 5 and: 6)
			and: [(tokens at: tokens size-3) = #methodsFor:])
			ifTrue:
				[(tokens at: tokens size-1) = #stamp:
				ifTrue: ["New format gives change stamp and unified prior pointer"
						stamp := tokens at: tokens size]].
		methodCategory := (tokens after: #methodsFor:) ifNil: ['as yet unclassifed'].
		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:
			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].
			^ ChangeRecord new file: file position: position type: #method
						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].
		position := prevPos.
		prevPos notNil ifTrue: [
			file _ sourceFilesCopy at: prevFileIndex]].
		^ nil]
			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]
	! !
!DropEvent methodsFor: 'printing' stamp: 'jmv 12/11/2011 23:32' prior: 16841192!
                          printOn: aStream

	aStream nextPut: $[.
	aStream nextPutAll: self eventPosition printString; space.
	aStream nextPutAll: self type.
	aStream nextPut: $].! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/12/2011 10:49' prior: 16896791!
             aboutToBeGrabbedBy: aHand
	"The receiver is being grabbed by a hand.
	Perform necessary adjustments (if any) and return the actual morph
	that should be added to the hand."
	self formerOwner: owner.
	self formerPosition: self morphPosition.
	^self "Grab me"! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/12/2011 10:52' prior: 16896972!
     slideBackToFormerSituation: evt 
	| slideForm formerOwner formerPosition aWorld startPoint endPoint |
	formerOwner _ self formerOwner.
	formerPosition _ self formerPosition.
	aWorld _ evt hand world.
	slideForm _ self imageForm offset: 0 @ 0.
	startPoint _ evt hand fullBounds origin.
	endPoint _ formerPosition.
	owner removeMorph: self.
	aWorld displayWorld.
	slideForm 
		slideFrom: startPoint
		to: endPoint
		nSteps: 12
		delay: 15.
	formerOwner addMorph: self.
	self morphPosition: formerPosition.
	self justDroppedInto: formerOwner event: evt! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 12/11/2011 23:28' prior: 16897556!
 handleMouseOver: anEvent
	"System level event handling."
	anEvent hand mouseFocus == self ifTrue:[
		"Got this directly through #handleFocusEvent: so check explicitly"
		(self containsPoint: anEvent eventPosition event: anEvent) ifFalse:[^self]].
	anEvent hand noticeMouseOver: self event: anEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 12/11/2011 23:29' prior: 16897704!
                             rejectDropEvent: anEvent
	"This hook allows the receiver to repel a drop operation currently executed. The method is called prior to checking children so the receiver must validate that the event was really designated for it.
	Note that the ordering of the tests below is designed to avoid a (possibly expensive) #fullContainsPoint: test. If the receiver doesn't want to repel the morph anyways we don't need to check after all."
	(self repelsMorph: anEvent contents event: anEvent) ifFalse:[^self]. "not repelled"
	(self fullContainsPoint: anEvent eventPosition) ifFalse:[^self]. "not for me"
	"Throw it away"
	anEvent wasHandled: true.
	anEvent contents rejectDropMorphEvent: anEvent.! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:49' prior: 16897802!
 align: aPoint1 with: aPoint2
	"Translate by aPoint2 - aPoint1."

	^ self morphPosition: self morphPosition + (aPoint2 - aPoint1)! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:52' prior: 16897828!
               bounds: newBounds
	| oldExtent newExtent |
	oldExtent _ bounds extent.
	newExtent _ newBounds extent.
	"Moving stuff around is most likely the most common operation.
	Optimize it"
	oldExtent = newExtent ifTrue: [
		^self morphPosition: newBounds topLeft ].
	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[
		"We're growing. First move then resize."
		self morphPosition: newBounds topLeft; extent: newExtent.
	] ifFalse: [
		"We're shrinking. First resize then move."
		self extent: newExtent; morphPosition: newBounds topLeft.
	].! !
!Morph methodsFor: 'geometry eToy' stamp: 'jmv 12/12/2011 10:52' prior: 16897925!
                       referencePosition: aPoint
	"a rather ugly way to say #center: . Just for consistency with #referencePosition"
	self morphPosition: aPoint - (bounds extent // 2)! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 12/12/2011 10:49' prior: 16898093!
 editBalloonHelpContent: aString
	| reply |
	reply _ FillInTheBlank
		multiLineRequest: 'Edit the balloon help text for ' , (self printStringLimitedTo: 40)
		centerAt: self world activeHand morphPosition
		initialAnswer: (aString ifNil: [self noHelpString] ifNotNil: [aString])
		answerHeight: 200.
	reply ifNil: [^ self].  "User cancelled out of the dialog"
	(reply isEmpty or: [reply asString = self noHelpString])
		ifTrue: [self setBalloonText: nil]
		ifFalse: [self setBalloonText: reply]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 12/11/2011 23:29' prior: 16898232!
                     transferHalo: event from: formerHaloOwner
	"Progressively transfer the halo to the next likely recipient"
	| w |

	"Never transfer halo to top-most world"
	(self isWorldMorph and:[owner isNil]) ifFalse: [
		(self wantsHaloFromClick and:[formerHaloOwner ~~ self]) 
			ifTrue:[^self addHalo: event from: formerHaloOwner]].

	event shiftPressed ifTrue: [
		"Pass it outwards"
		owner ifNotNil:[^owner transferHalo: event from: formerHaloOwner].
		"We're at the top level; throw the event back in to find recipient"
		formerHaloOwner removeHalo.
		^self processEvent: event copy resetHandlerFields.
	].
	self submorphsDo: [ :m |
		(m fullContainsPoint: event eventPosition) 
			ifTrue:[^m transferHalo: event from: formerHaloOwner].
	].
	"We're at the bottom most level; throw the event back up to the root to find recipient"
	formerHaloOwner removeHalo.
	(w _ self world) ifNil: [ ^self ].
	^w processEvent: event copy resetHandlerFields.
! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 10:49' prior: 16898352!
 openInWorld: aWorld
	"Add this morph to the requested World."
	(aWorld viewBox origin ~= (0@0) and: [self morphPosition = (0@0)]) ifTrue: [
		self morphPosition: aWorld viewBox origin].
	aWorld addMorph: self.
	aWorld startSteppingSubmorphsOf: self! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 12/12/2011 10:49' prior: 16898838!
                   changeColorTarget: anObject selector: aSymbol originalColor: aColor hand: aHand
	"Put up a color picker for changing some kind of color.  May be modal or modeless, depending on #modalColorPickers setting"
	self flag: #arNote. "Simplify this due to anObject == self for almost all cases"
	^ ColorPickerMorph new
		choseModalityFromPreference;
		sourceHand: aHand;
		target: anObject;
		selector: aSymbol;
		originalColor: aColor;
		putUpFor: anObject near: ((anObject is: #Morph)
					ifTrue: [ Rectangle center: self morphPosition extent: 20 ]
					ifFalse: [ anObject == self world
								ifTrue: [ anObject viewBox bottomLeft + (20@-20) extent: 200 ]
								ifFalse: [ anObject fullBounds ]]);
		yourself! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/12/2011 10:51' prior: 16899455!
                               addMorphFront: aMorph fromWorldPosition: aPoint

	self addMorphFront: aMorph.
	aMorph morphPosition: aPoint! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/12/2011 10:49' prior: 16899461!
                        addMorphFrontFromWorldPosition: aMorph
	^self addMorphFront: aMorph fromWorldPosition: aMorph morphPosition.! !
!Morph methodsFor: 'testing' stamp: 'jmv 12/11/2011 23:36' prior: 16899658!
    shouldDropOnMouseUp
	| former |
	"
	former _ self formerPosition ifNil:[^false].
	^(former dist: self zzposition) > 10
	"^true! !
!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 10:51' prior: 16783581!
                              setCompleter: anAutoCompleter position: aPoint 
	completer _ anAutoCompleter.
	self morphPosition: aPoint.
	self resetMenu.
	self openInWorld! !
!AutoCompleterMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:13' prior: 16783707!
               mouseUp: evt
	(self containsPoint: evt eventPosition)
		ifTrue: [
			self selected: 
				((evt eventPosition y - bounds top // self class itemHeight) + 
					self firstVisible).
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !
!FillInTheBlankMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:14' prior: 16852801!
                           mouseDown: evt
	(self containsPoint: evt eventPosition) ifFalse:[^ Beeper beep]. "sent in response to outside modal click"
	evt hand grabMorph: self. "allow repositioning"! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 10:45' prior: 16852995!
       request: queryString
	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph request: 'What is your favorite color?'"

	^ self
		request: queryString
		initialAnswer: ''
		centerAt: World activeHand morphPosition! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 10:45' prior: 16853010!
              request: queryString initialAnswer: defaultAnswer 
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."
	"FillInTheBlankMorph
		request: 'What is your favorite color?'
		initialAnswer: 'red, no blue. Ahhh!!'"

	^ self
		request: queryString
		initialAnswer: defaultAnswer
		centerAt: World activeHand morphPosition! !
!HaloMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/12/2011 10:45' prior: 16863637!
        startDrag: evt with: dragHandle
	"Drag my target without removing it from its owner."

	self obtainHaloForEvent: evt andRemoveAllHandlesBut: dragHandle.
	positionOffset _ dragHandle referencePosition - target morphPosition! !
!HaloMorph methodsFor: 'event handling' stamp: 'jmv 12/12/2011 10:51' prior: 16863647!
       mouseMove: evt
	"Drag our target around"
	| thePoint |
	thePoint _ evt eventPosition - positionOffset.
	target morphPosition: thePoint! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 12/12/2011 10:45' prior: 16863654!
       popUpFor: aMorph event: evt
	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."

	| hand anEvent |
	self flag: #workAround.	"We should really have some event/hand here..."
	anEvent _ evt
				ifNil: [
					hand _ aMorph world activeHand.
					hand ifNil: [ hand _ aMorph world firstHand ]. 
					hand lastEvent ]
				ifNotNil: [
					hand _ evt hand.
					evt ].
	self target: aMorph.
	hand halo: self.
	hand world addMorphFront: self.
	positionOffset _ anEvent eventPosition - aMorph morphPosition.
	self startStepping! !
!HaloMorph methodsFor: 'events-processing' stamp: 'jmv 12/11/2011 23:27' prior: 16863687!
            containsPoint: aPoint event: anEvent
	"mouseButton3 events are handled by the halo"
	(anEvent isMouse and: [ anEvent isMouseDown and: [ anEvent mouseButton3Pressed ]])
		ifFalse:  [^super containsPoint: aPoint event: anEvent ].
	^self fullBounds containsPoint: anEvent eventPosition! !
!HaloMorph methodsFor: 'meta-actions' stamp: 'jmv 12/12/2011 10:45' prior: 16863915!
             mouseButton3Down: event
	"Transfer the halo to the next likely recipient"
	target ifNil:[^self delete].
	event hand obtainHalo: self.
	positionOffset _ event eventPosition - target morphPosition.
	"wait for drags or transfer"
	event hand 
		waitForClicksOrDrag: self 
		event: event
		clkSel: #transferHalo:
		dblClkSel: nil! !
!HaloMorph methodsFor: 'stepping' stamp: 'jmv 12/12/2011 10:51' prior: 16863927!
       step
	| newBounds |
	target
		ifNil: [^ self].
	newBounds _ target isWorldMorph
				ifTrue: [target bounds]
				ifFalse: [target worldBoundsForHalo truncated].
	newBounds = bounds
		ifTrue: [^ self].
	newBounds extent = bounds extent
		ifTrue: [^ self morphPosition: newBounds origin].
	growingOrRotating
		ifFalse: [submorphs size > 1
				ifTrue: [self addHandles]].
	"adjust halo bounds if appropriate"
	self bounds: newBounds! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/30/2011 23:40' prior: 16863963!
addHandle: handleSpec on: eventName send: selector to: recipient 
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint iconName colorToUse aMorph |
	aPoint := self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	handle := HaloHandleMorph new.
	self addMorph: handle.
	handle 
		bounds: (Rectangle center: aPoint extent: HandleSize asPoint);
		color: (colorToUse := Color colorFrom: handleSpec color).
	(iconName := handleSpec iconSymbol) ifNotNil: [
			| form |
			form := Icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				aMorph _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				aMorph morphPosition: aPoint - (form extent // 2).
				handle addMorphFront: aMorph.
				]].
	handle 
		on: #mouseUp
		send: #endInteraction
		to: self.
	handle 
		on: eventName
		send: selector
		to: recipient.
	handle 
		setBalloonText: (target balloonHelpTextForHandle: handle).
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16864040!
                    addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w |
	w := self world ifNil: [target world].
	nameMorph := StringMorph contents: aString.
	nameMorph color: Color magenta.
	namePosition := outerRectangle bottomCenter 
				- ((nameMorph width // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph 
		morphPosition: (namePosition min: w viewBox bottomRight - nameMorph extent y + 5).
	self addMorph: (RectangleMorph new
		bounds: (nameMorph bounds outsetBy: 2);
		borderWidth: 0;
		color: (Color lightBlue alpha: 0.9)).
	self addMorph: nameMorph.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16864096!
        doDrag: evt with: dragHandle
	| thePoint |
	evt hand obtainHalo: self.
	thePoint _ evt eventPosition - positionOffset.
	target morphPosition: thePoint! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16864126!
                      doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target bounds topLeft.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target extent: newExtent.
	growHandle morphPosition: evt eventPosition - (growHandle extent // 2).
	self someSubmorphPositionOrExtentChanged
! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:15' prior: 16864158!
                       doRecolor: evt with: aHandle
	"The mouse went down in the 'recolor' halo handle.  Allow the user to change the color of the innerTarget"

	evt hand obtainHalo: self.
	(aHandle containsPoint: evt eventPosition)
		ifFalse: [  "only do it if mouse still in handle on mouse up"
			self delete.
			target addHalo: evt]
		ifTrue: [
			innerTarget changeColor]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16864171!
           doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Color lightBlue]
		ifFalse: [rotHandle color: Color blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPosition: evt eventPosition - (rotHandle extent // 2).
	self someSubmorphPositionOrExtentChanged! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:15' prior: 16864211!
                    maybeCollapse: evt with: collapseHandle 
	"Ask hand to collapse my target if mouse comes up in it."

	evt hand obtainHalo: self.
	self delete.
	(collapseHandle containsPoint: evt eventPosition) 
		ifFalse: [
			target addHalo: evt ]
		ifTrue: [
			target collapse ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:16' prior: 16864222!
   maybeDismiss: evt with: dismissHandle
	"Ask hand to dismiss my target if mouse comes up in it."

	evt hand obtainHalo: self.
	(dismissHandle containsPoint: evt eventPosition)
		ifFalse: [
			self delete.
			target addHalo: evt]
		ifTrue: [
			target resistsRemoval ifTrue: [
				(PopUpMenu
					confirm: 'Really throw this away'
					trueChoice: 'Yes'
					falseChoice: 'Um, no, let me reconsider') ifFalse: [^ self]].

			self delete.
			target dismissViaHalo]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:16' prior: 16864285!
                               setDismissColor: evt with: dismissHandle
	"Called on mouseStillDown in the dismiss handle; set the color appropriately."

	| colorToUse |
	evt hand obtainHalo: self.
	colorToUse _  (dismissHandle containsPoint: evt eventPosition)
		ifFalse: [ Color red muchLighter ]
		ifTrue: [ Color lightGray ].
	dismissHandle color: colorToUse! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:16' prior: 16864298!
  startGrow: evt with: growHandle
	"Initialize resizing of my target.  Launch a command representing it, to support Undo"

	| botRt |
	self obtainHaloForEvent: evt andRemoveAllHandlesBut: growHandle.
	botRt _ target bounds bottomRight.
	positionOffset _ (self world viewBox containsPoint: botRt)
		ifTrue: [evt eventPosition - botRt]
		ifFalse: [0@0]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/11/2011 23:16' prior: 16864311!
                startRot: evt with: rotHandle
	"Initialize rotation of my target if it is rotatable.  Launch a command object to represent the action"

	self obtainHaloForEvent: evt andRemoveAllHandlesBut: rotHandle.
	growingOrRotating _ true.

	self removeAllHandlesBut: rotHandle.  "remove all other handles"
	angleOffset _ evt eventPosition - target referencePosition.
	angleOffset _ Point
			r: angleOffset r
			degrees: angleOffset degrees - target rotationDegrees

! !
!HandMorph methodsFor: 'cursor' stamp: 'jmv 12/12/2011 10:46' prior: 16864626!
      cursorBounds

	^self morphPosition extent: CursorWithMask normal extent! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 12/12/2011 10:46' prior: 16865010!
                           handleEvent: anEvent
	| evt |
	owner ifNil: [ ^ self ].
	evt _ anEvent.
	evt isMouseOver ifTrue: [ ^ self sendMouseEvent: evt ].

	"Notify listeners"
	self sendListenEvent: evt to: self eventListeners.
	
	evt isWindowEvent ifTrue: [
		self sendEvent: evt.
		^ self mouseOverHandler processMouseOver: lastMouseEvent ].

	evt isKeyboard ifTrue: [
		self sendListenEvent: evt to: self keyboardListeners.
		self sendKeyboardEvent: evt.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	evt isDropEvent ifTrue: [
		self sendEvent: evt.
		^ self mouseOverHandler processMouseOver: lastMouseEvent].

	evt isMouse ifTrue: [
		self sendListenEvent: evt to: self mouseListeners.
		lastMouseEvent _ evt.	
		lastMouseEventTime _ Time millisecondClockValue].

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: evt from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			^self mouseOverHandler processMouseOver: lastMouseEvent  ]].

	evt isMove ifTrue: [
		self morphPosition: evt eventPosition.
		self sendMouseEvent: evt.
	] ifFalse: [
		"Issue a synthetic move event if we're not at the position of the event"
		evt eventPosition = self morphPosition ifFalse: [ self moveToEvent: evt ].
		"Drop submorphs on button events"
		self hasSubmorphs
			ifTrue: [ self dropMorphs: evt ]
			ifFalse: [ self sendMouseEvent: evt ].
	].
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 12/12/2011 10:46' prior: 16865120!
           newMouseFocus: aMorph event: event 
	aMorph ifNotNil: [ 
		targetOffset _ event eventPosition - aMorph morphPosition].
	^self newMouseFocus: aMorph! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/12/2011 10:46' prior: 16865187!
               attachMorph: m
	"Position the center of the given morph under this hand, then grab it.
	This method is used to grab far away or newly created morphs."
	| delta |
	self releaseMouseFocus. "Break focus"
	delta _ m bounds extent // 2.
	m morphPosition: (self morphPosition - delta).
	m formerPosition: m morphPosition.
	targetOffset _ m morphPosition - self morphPosition.
	self addMorphBack: m.! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/12/2011 10:46' prior: 16865201!
                          dropMorph: aMorph event: anEvent
	"Drop the given morph which was carried by the hand"
	| event |
	(anEvent isMouseUp and:[aMorph shouldDropOnMouseUp not]) ifTrue:[^self].

	"Note: For robustness in drag and drop handling we remove the morph BEFORE we drop him, but we keep his owner set to the hand. This prevents system lockups when there is a problem in drop handling (for example if there's an error in #wantsToBeDroppedInto:). THIS TECHNIQUE IS NOT RECOMMENDED FOR CASUAL USE."
	self privateRemove: aMorph.
	aMorph privateOwner: self.

	event _ DropEvent new setPosition: self morphPosition contents: aMorph hand: self.
	self sendEvent: event.
	event wasHandled ifFalse:[aMorph rejectDropMorphEvent: event].
	aMorph owner == self ifTrue:[aMorph delete].
	self mouseOverHandler processMouseOver: anEvent.! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/12/2011 10:46' prior: 16865237!
                          grabMorph: aMorph from: formerOwner
	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."

	self releaseMouseFocus. "Break focus"
	"And compute distance from hand's position"
	targetOffset _ aMorph morphPosition - self morphPosition.
	self addMorphBack: aMorph.
	aMorph justGrabbedFrom: formerOwner.! !
!HandMorph methodsFor: 'paste buffer' stamp: 'jmv 12/12/2011 10:47' prior: 16865483!
  pasteMorph

	| pastee |
	pastee _ Clipboard retrieveMorph.
	pastee ifNil: [^ self inform: 'Nothing to paste.'].
	self attachMorph: pastee.
	pastee align: pastee referencePosition with: self morphPosition
! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 12/12/2011 10:46' prior: 16865496!
                         generateKeyboardEvent: evtBuf 
	"Generate the appropriate mouse event for the given raw event buffer"

	| buttons modifiers type keyValue pressType stamp |
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [stamp _ Time millisecondClockValue].
	(evtBuf sixth <= 0 or: [
		(keyValue _ (Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth)) isNil ])
			ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].
	modifiers _ evtBuf fifth.
	pressType _ evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type _ #keyDown.
		lastKeyDownValue _ keyValue].
	pressType = EventSensor eventKeyUp ifTrue: [type _ #keyUp].
	pressType = EventSensor eventKeyChar ifTrue: [
		type _ #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [		"Control key pressed"
			keyValue < 27 ifTrue: [
				
				"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [		"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ 	"If Equal, Ctrl-alphabetic in Windows => do translate"
							lastKeyDownValue < 47 ]) ifTrue: [		"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue _ (modifiers anyMask: 1)
							ifFalse: [ keyValue + 96 ]	"shift not pressed: conver to lowercase letter"
							ifTrue: [ keyValue + 64 ]].	"shift pressed: conver to uppercase letter"
					]
				].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [
				modifiers _ modifiers bitOr: 8 ]
			]].
	buttons _ modifiers bitShift: 3.
	^KeyboardEvent new 
		setType: type
		buttons: buttons
		position: self morphPosition
		keyValue: keyValue
		hand: self
		stamp: stamp! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 12/12/2011 10:46' prior: 16865642!
             moveToEvent: anEvent
	"Issue a mouse move event to make the receiver appear at the given position"
	self handleEvent: (MouseMoveEvent new
		setType: #mouseMove 
		startPoint: self morphPosition 
		endPoint: anEvent eventPosition 
		trail: (Array with: self morphPosition with: anEvent eventPosition)
		buttons: anEvent buttons
		hand: self
		stamp: anEvent timeStamp)! !
!HandleMorph methodsFor: 'event handling' stamp: 'jmv 4/10/2012 14:29' prior: 16865778!
                     keyStroke: evt
	"Check for cursor keys"
	| keyValue |
	(owner is: #HandMorph) ifFalse: [ ^self ].
	keyValue _ evt keyValue.
	keyValue = 28 ifTrue: [ ^self morphPosition: self morphPosition - (1@0) ].
	keyValue = 29 ifTrue: [ ^self morphPosition: self morphPosition + (1@0) ].
	keyValue = 30 ifTrue: [ ^self morphPosition: self morphPosition - (0@1) ].
	keyValue = 31 ifTrue: [ ^self morphPosition: self morphPosition + (0@1) ].
	"Special case for return"
	evt isReturnKey ifTrue:[
		"Drop the receiver and be done"
	self flag: #arNote. "Probably unnecessary"
		owner releaseKeyboardFocus: self.
		self delete ]! !
!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 10:47' prior: 16867371!
                              popUpForHand: aHand
	"Pop up the receiver as balloon help for the given hand"

	| xcess |
	(contents isNil or: [ contents isEmpty ]) ifTrue: [ ^self ].
	self morphPosition: aHand morphPosition + (-6@20).
	xcess _ bounds right - aHand world bounds right.
	xcess > 0 ifTrue: [
		self morphPosition: self morphPosition - (xcess@0) ].
	aHand world addMorphFront: self.
	aHand balloonHelp: self! !
!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 12/11/2011 23:17' prior: 16870032!
  enterClickableRegion: evt
	| index isLink |
	evt hand hasSubmorphs ifTrue: [ ^self ].
	paragraph ifNotNil:[
		index _ (paragraph characterBlockAtPoint: evt eventPosition) stringIndex.
		isLink _ (model actualContents attributesAt: index) 
					anySatisfy: [ :attr | attr mayActOnClick ].
		isLink ifTrue: [ Cursor webLink show ] ifFalse: [ Cursor normal show ]]! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:17' prior: 16870178!
                       mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].
	self handleInteraction: [ editor mouseMove: (evt translatedBy: bounds topLeft negated)].
	(evt eventPosition y between: owner bounds top and: owner bounds bottom) ifFalse: [
		WorldState addDeferredUIMessage: [
			owner scrollSelectionIntoView: evt ]
	]! !
!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 10:47' prior: 16879765!
            handPoint
	^ hand morphPosition adhereTo: owner bounds! !
!LayoutAdjustingMorph methodsFor: 'stepping' stamp: 'jmv 12/12/2011 10:47' prior: 16879781!
          step
	"got the #mouseLeave: message"
	| p |
	hand ifNil: [
		indicator ifNotNil: [
			indicator delete.
			indicator _ nil ].
		Cursor currentCursor == self cursor ifTrue: [
			Cursor normal show ].
		^self stopStepping ].

	"hasn't got the #mouseLeave: message (yet)"
	p _ self handPoint.
	hand lastEvent mouseButton1Pressed
		ifTrue: [
			indicator
				ifNil: [ self adjustOwnerAt: p ]
				ifNotNil: [ self adjustIndicatorAt: p ]]
		ifFalse: [
			indicator ifNotNil: [
				indicator delete.
				indicator _ nil.
				self adjustOwnerAt: p ].
			"If the button was unpressed outside the morph (can happen if you try to go outside container),
			we might not get the #mouseLeave: message"
			(self containsPoint: hand morphPosition) ifFalse: [
				hand _ nil.
				Cursor normal show.
				self stopStepping ]]! !
!LayoutAdjustingMorph methodsFor: 'adjusting' stamp: 'jmv 12/12/2011 10:47' prior: 16879814!
                        adjustIndicatorAt: aPoint
	owner direction = #vertical
		ifTrue: [
			indicator morphPosition: indicator morphPosition x @ (aPoint y-(indicator height//2)) ]
		ifFalse: [
			indicator morphPosition: (aPoint x-(indicator width//2)) @ indicator morphPosition y ]! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 12/12/2011 10:48' prior: 16885163!
      chooseMagnification: evt
	| handle origin aHand currentMag |
	currentMag _ magnification.
	aHand _ evt ifNil: [ self world activeHand ] ifNotNil: [evt hand].
	origin _ aHand morphPosition y.
	handle _ HandleMorph new forEachPointDo:
		[ :newPoint | self magnification: (newPoint y - origin) / 8.0 + currentMag ].
	aHand attachMorph: handle.
	handle startStepping.
	self redrawNeeded. ! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 12/12/2011 10:48' prior: 16885245!
    sourcePoint
	"If we are being dragged use our center, otherwise use pointer position"
	^ (trackPointer not or: [owner notNil and: [owner is: #HandMorph]])
		ifTrue: [ bounds center ]
		ifFalse: [ self activeHand morphPosition ]! !
!MagnifierMorph methodsFor: 'round view' stamp: 'jmv 12/11/2011 23:35' prior: 16885274!
 toggleRoundness
	| |
"	w _ self world.
	self isRound
		ifTrue: [owner delete.
				w addMorph: self]
		ifFalse: [sm _ ScreeningMorph new position: self zzposition.
				sm addMorph: self.
				sm addMorph: (EllipseMorph newBounds: self bounds).
				w addMorph: sm]
			"! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 10:51' prior: 16886778!
                            contents: aString withMarkers: aBool inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	self contentString: nil.	"get rid of old"
	aBool ifFalse: [^super contents: aString].
	self removeAllMorphs.	"get rid of old markers if updating"
	self hasIcon ifTrue: [ self icon: nil ].
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	self contentString: aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	marker morphPosition: bounds left @ (bounds top + 2).
	self addMorphFront: marker! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:17' prior: 16886907!
                      activateOwnerMenu: evt
	"Activate our owner menu; e.g., pass control to it"
	owner ifNil:[^false]. "not applicable"
	(owner fullContainsPoint: evt eventPosition) ifFalse:[^false].
	owner activate: evt.
	^true! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:17' prior: 16886916!
                         activateSubmenu: evt
	"Activate our submenu; e.g., pass control to it"
	subMenu ifNil:[^false]. "not applicable"
	(subMenu fullContainsPoint: evt eventPosition) ifFalse:[^false].
	subMenu activate: evt.
	self removeAlarm: #deselectTimeOut:.
	^true! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 4/10/2012 14:30' prior: 16887473!
                 addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s p w |
	
	titleMorph _ RectangleMorph new.
	self setTitleParametersFor: titleMorph.
	p _ titleMorph morphPosition + (8@2).
	aString asString linesDo: [ :line | 
		s _ StringMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		s morphPosition: p.
		titleMorph addMorphBack: s.
		p _ p + (0@(s height+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each width ].
	titleMorph height: p y; width: w + 8.
	self addMorphFront: titleMorph.
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/12/2011 10:49' prior: 16887634!
 popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem
	"Present this menu at the given point under control of the given hand."

	| delta tryToPlace selectedOffset |

	hand world startSteppingSubmorphsOf: self.
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil:[self items first]) morphPosition - self morphPosition.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self fullBounds amountToTranslateWithin: sourceItem world bounds.
		(delta x = 0 or: [ mustFit ]) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			sourceItem owner owner addMorphFront: self.
			^ self]].
	tryToPlace 
		value: rightOrLeftPoint first value: false;
		value: rightOrLeftPoint last  - (self width @ 0) value: false;
		value: rightOrLeftPoint first value: true

	! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/12/2011 10:49' prior: 16887698!
                            popUpForHand: hand in: aWorld
	| p |
	"Present this menu under control of the given hand."

	p _ hand morphPosition truncated.
	^self popUpAt: p forHand: hand in: aWorld
! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/12/2011 10:49' prior: 16887712!
  popUpInWorld: aWorld
	"Present this menu under control of the given hand."
	^self
		popUpAt: aWorld activeHand morphPosition
		forHand: aWorld activeHand
		in: aWorld
! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:17' prior: 16887796!
      mouseDown: evt
	"Handle a mouse down event."
	(stayUp or:[self fullContainsPoint: evt eventPosition]) 
		ifFalse:[^self deleteIfPopUp: evt]. "click outside"
	self isSticky ifTrue: [^self].
	"Grab the menu and drag it to some other place"
	evt hand grabMorph: self.! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:17' prior: 16887807!
     mouseUp: evt
	"Handle a mouse up event.
	Note: This might be sent from a modal shell."
	(self fullContainsPoint: evt eventPosition) ifFalse:[
		"Mouse up outside. Release eventual focus and delete if pop up."
		evt hand releaseMouseFocus: self.
		^self deleteIfPopUp: evt].
	stayUp ifFalse:[
		"Still in pop-up transition; keep focus"
		evt hand newMouseFocus: self].! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 12/12/2011 10:48' prior: 16887856!
                    displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m isKindOf: MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Color veryDarkGray.
		feedbackMorph morphPosition: self morphPosition - (0@20).
		self
			 addLine;
			 addMorphBack: feedbackMorph lock.
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self submorphs last delete.
		self removeProperty: #feedbackMorph ].
	matches size = 1 ifTrue: [
		self
			selectItem: matches first
			event: evt ].! !
!MenuMorph methodsFor: 'menu' stamp: 'jmv 12/12/2011 10:51' prior: 16888036!
                        sightTarget: event 
	| bullseye menu newTarget |
	owner
		ifNil: [^ self ].
	bullseye _ Point fromUserWithCursor: Cursor target.
	ActiveHand morphPosition: bullseye.
	menu _ CustomMenu new.
	(owner morphsAt: bullseye) do: [ :m |
		menu add: m printString action: m ].
	menu title: self printString, ' targets... '.
	newTarget _ menu startUp.
	newTarget
		ifNil: [^ self].
	self target: newTarget! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 12/12/2011 10:48' prior: 16888084!
                           invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu"

	^ self invokeModalAt: ActiveHand morphPosition in: ActiveWorld allowKeyboard: allowKeyboardControl! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16888140!
             adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p tl |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: (
			(each respondsTo: #minItemWidth)
				ifTrue: [each minItemWidth]
				ifFalse: [each width])].

	w _ w + 4.
	tl _ bounds topLeft.
	p _ tl + 5.
	submorphs do: [ :m |
		m width: w.
		m morphPosition: p.
		p _ m bounds bottomLeft +(0@1) ].
	
	self extent: submorphs last bounds bottomRight - tl + 5! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:49' prior: 16888172!
     positionAt: aPoint relativeTo: aMenuItem inWorld: aWorld
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| i yOffset sub delta |
	self adjustSubmorphsLayout.
	i _ 0.
	yOffset _ 0.
	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]
		whileFalse: [ yOffset _ yOffset + sub height ].

	self morphPosition: aPoint - (2 @ (yOffset + 8)).

	"If it doesn't fit, show it to the left, not to the right of the hand."
	bounds right > aWorld world bounds right
		ifTrue: [
			self moveRight: aPoint x + 1].

	"Make sure that the menu fits in the world."
	delta _ bounds amountToTranslateWithin:
		(aWorld world bounds withHeight: ((aWorld world bounds height - 18) max: (ActiveHand morphPosition y) + 1)).
	delta = (0 @ 0) ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!MenuMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:51' prior: 16888218!
         moveRight: aNumber
	self morphPosition: ((aNumber - bounds width) @ bounds top)! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 12/12/2011 10:48' prior: 16884746!
                         informUserAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	| w titleString |

	titleString _ titleMorph submorphs first.
	self visible: false.
	w _ ActiveWorld.
	aBlock value: [ :string |
		self visible ifFalse: [
			w addMorph: self centeredNear: aPoint.
			self visible: true].
		titleString contents: string.
		titleMorph width: titleString width + 8.
		self morphPosition: w activeHand morphPosition.
		self adjustSubmorphsLayout.
		self redrawNeeded.
		w displayWorld		 "show myself"
	]. 
	self delete.
	w displayWorld! !
!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 12/11/2011 23:29' prior: 16900281!
                      dispatchDefault: anEvent with: aMorph
	"Dispatch the given event. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."
	| inside |
	"See if we're fully outside aMorphs bounds"
	(aMorph fullBounds containsPoint: anEvent eventPosition) ifFalse: [ ^#rejected ]. "outside"

	"Traverse children"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [
				"Not rejected. The event was in some submorph of the receiver"
				inside _ true
			]]].

	"Check for being inside the receiver"
	inside ifFalse: [ inside _ aMorph containsPoint: anEvent eventPosition event: anEvent ].
	inside ifTrue: [ ^aMorph handleEvent: anEvent ].
	^ #rejected! !
!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 12/11/2011 23:31' prior: 16900308!
                   dispatchDropEvent: anEvent with: aMorph
	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."
	| inside |

	"Try to get out quickly"
	(aMorph fullBounds containsPoint: anEvent eventPosition)
		ifFalse: [ ^#rejected ].

	"Give aMorph a chance to repel the dropping morph"
	aMorph rejectDropEvent: anEvent.
	anEvent wasHandled ifTrue:[^self].

	"Go looking if any of our submorphs wants it"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [
				inside _ true
			]]].

	inside ifFalse: [ inside _ aMorph containsPoint: anEvent eventPosition event: anEvent ].
	inside ifTrue: [ ^aMorph handleEvent: anEvent ].
	^#rejected! !
!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'jmv 12/11/2011 23:31' prior: 16900369!
      dispatchMouseDown: anEvent with: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
"
	| globalPt handler inside lastHandler |
	"Try to get out quickly"
	globalPt _ anEvent eventPosition.
	(aMorph fullBounds containsPoint: globalPt) ifFalse: [ ^#rejected ].

	"Install the prospective handler for the receiver"
	lastHandler _ anEvent handler. "in case the mouse wasn't even in the receiver"
	handler _ aMorph handlerForMouseDown: anEvent.
	handler ifNotNil: [ anEvent handler: handler ].

	"Now give our submorphs a chance to handle the event"
	inside _ false.
	aMorph submorphsDo: [ :eachChild |
		inside ifFalse: [
			(eachChild processEvent: anEvent using: self) == #rejected ifFalse: [
				"Some child did contain the point so we're part of the top-most chain."
				inside _ true.
			]]].

	(inside or: [ aMorph containsPoint: anEvent eventPosition event: anEvent ]) ifTrue:[
		"Receiver is in the top-most unlocked, visible chain."
		handler ifNotNil: [ handler handleEvent: anEvent ].
		"Note: Re-installing the handler is not really necessary but good style."
		anEvent handler: lastHandler.
		^self ].

	"Mouse was not on receiver nor any of its children"
	anEvent handler: lastHandler.
	^#rejected! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 12/12/2011 10:52' prior: 16900611!
                    placeEmbeddedObject: anchoredFormOrMorph

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	(anchoredFormOrMorph is: #Morph)
		ifTrue: [
			anchoredFormOrMorph morphPosition:
				((destX - anchoredFormOrMorph width)@
				(lineY+ line baseline - anchoredFormOrMorph height)) -
					paraTopLeft ]
		ifFalse: [
			destY _ lineY.
			runX _ destX.
			anchoredFormOrMorph 
				displayOn: canvas grafPort destForm 
				at: destX - anchoredFormOrMorph width @ (destY + line baseline - anchoredFormOrMorph height)
				clippingBox: canvas grafPort clipRect
				rule: Form blend
				fillColor: nil ].
	^ true! !
!MouseClickState methodsFor: 'actions' stamp: 'jmv 12/30/2011 23:41' prior: 16900948!
                            handleEvent: evt from: aHand
	"Process the given mouse event to detect a click, double-click, or drag.
	Return true if the event should be processed by the sender, false if it shouldn't.
	NOTE: This method heavily relies on getting *all* mouse button events."

	| timedOut distance |
	timedOut _ (evt timeStamp - lastClickDown timeStamp) > DoubleClickTimeout.
	distance _ (evt eventPosition - lastClickDown eventPosition) r.
	"Real action dispatch might be done after the triggering event, for example, because of waiting for timeout.
	So, count the button downs and ups(clicks), to be processed, maybe later, maybe in a mouseMove..."
	evt isMouseDown ifTrue: [
		lastClickDown _ evt.
		buttonDownCount _ buttonDownCount + 1 ].
	evt isMouseUp ifTrue: [
		buttonUpCount _ buttonUpCount + 1 ].

	"Simulate button 2 if timeout during first click (i.e. tap & hold). Useful for opening menus on pen computers."
	(buttonDownCount = 1 and: [ buttonUpCount = 0]) ifTrue: [
		(timedOut and: [ sendMouseButton2Activity and: [ distance = 0]]) ifTrue: [
			aHand dontWaitForMoreClicks.
			clickClient mouseButton2Activity.
			^ false ].
		"If we have already moved, then it won't be a double or triple click... why wait?"
		distance > 0 ifTrue: [
			aHand dontWaitForMoreClicks.
			self click.
			^ false ]].

	"If we're over triple click, or timed out, or mouse moved, don't allow more clicks."
	(buttonDownCount = 4 or: [ timedOut or: [ distance > 0 ]]) ifTrue: [
		aHand dontWaitForMoreClicks.
		^ false ].

	"Simple click."
	(buttonDownCount = 1 and: [ buttonUpCount = 1 ]) ifTrue: [
		self click ].

	"Click & hold"
	(buttonDownCount = 2 and: [ buttonUpCount = 1]) ifTrue: [
		self clickAndAHalf ].

	"Double click."
	(buttonDownCount = 2 and: [ buttonUpCount = 2]) ifTrue: [
		self doubleClick ].

	"Double click & hold."
	(buttonDownCount = 3 and: [ buttonUpCount = 2]) ifTrue: [
		self doubleClickAndHalf ].

	"Triple click"
	(buttonDownCount = 3 and: [ buttonUpCount = 3]) ifTrue: [
		self tripleClick ].

	"This means: if a mouseDown, then don't further process this event (so we can turn it into a double or triple click on next buttonUp)"
	^ evt isMouseDown! !
!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 12/30/2011 23:42' prior: 16906472!
               mouseDown: event
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	event hand newKeyboardFocus: self.

	self handleInteraction: [
		self editor mouseDown: event index: (self characterIndexAtPoint: event eventPosition) ].

	event hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: event
		clkSel: nil
		clkNHalf: #clickAndHalf:
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!OneLineEditorMorph methodsFor: 'event handling' stamp: 'jmv 12/30/2011 23:42' prior: 16906497!
        mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self].
	self handleInteraction: [
		self editor mouseMove: evt index: (self characterIndexAtPoint: evt eventPosition) ]! !
!Parser methodsFor: 'public access' stamp: 'jmv 12/11/2011 22:42' prior: 16911313!
                              parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock
	"Answer a MethodNode for the argument, sourceStream, that is the root of
	 a parse tree. Parsing is done with respect to the argument, class, to find
	 instance, class, and pool variables; and with respect to the argument,
	 ctxt, to find temporary variables. Errors in parsing are reported to the
	 argument, req, if not nil; otherwise aBlock is evaluated. The argument
	 noPattern is a Boolean that is true if the the sourceStream does not
	 contain a method header (i.e., for DoIts)."
	| methNode repeatNeeded myStream s p |
	category _ aCategory.
	myStream _ sourceStream.
	[
		repeatNeeded _ false.
		p _ myStream position.
		s _ myStream upToEnd.
		myStream position: p.
		self encoder init: class context: ctxt notifying: self.
		self init: myStream notifying: req failBlock: [
			^ aBlock value ].
		doitFlag _ noPattern.
		failBlock _ aBlock.
		[ methNode _ self method: noPattern context: ctxt ]
			on: ReparseAfterSourceEditing
			do: [ :ex |
				repeatNeeded _ true.
				myStream _ sourceStreamGetter notNil 	"Cuis specific. Do not remove!!"
					ifTrue: [ requestor perform: sourceStreamGetter ]
					ifFalse: [ ReadStream on: requestor text string ]].
		repeatNeeded
	] whileTrue: [
		encoder _ self encoder class new ].
	methNode sourceText: s.
	^ methNode! !
!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/12/2011 10:52' prior: 16911627!
                 acceptDroppingMorph: dropped event: evt 
	"The supplied morph, known to be acceptable to the receiver, is now to be assimilated; the precipitating event is supplied"

	| aMorph |
	aMorph := self morphToDropFrom: dropped.
	self isWorldMorph 
		ifTrue: [	"Add the given morph to this world and start stepping it if it wants to be."

			self addMorphFront: aMorph.
			(aMorph fullBounds intersects: self viewBox) 
				ifFalse: [
					Beeper beep.
					aMorph morphPosition: bounds center]]
		ifFalse: [super acceptDroppingMorph: aMorph event: evt].
	aMorph submorphsDo: [ :m | (m isKindOf: HaloMorph) ifTrue: [ m delete ]].
	self world startSteppingSubmorphsOf: aMorph! !
!PasteUpMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:30' prior: 16911698!
         morphToGrab: event
	"Return the morph to grab from a mouse down event. If none, return nil."
	self submorphsDo: [ :m |
		((m rejectsEvent: event) not and:[m fullContainsPoint: event eventPosition]) ifTrue:[^m].
	].
	^nil! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 12/12/2011 10:52' prior: 16912032!
       viewBox: newViewBox
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
	super morphPosition: newViewBox topLeft.
	fullBounds _ bounds _ newViewBox.! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 12/12/2011 10:52' prior: 16912372!
                     addMorph: aMorph centeredNear: aPoint
	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."

	| trialRect delta |
	trialRect _ Rectangle center: aPoint extent: aMorph fullBounds extent.
	delta _ trialRect amountToTranslateWithin: bounds.
	aMorph morphPosition: trialRect origin + delta.
	self addMorph: aMorph.
! !
!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:17' prior: 16913714!
            mouseUp: evt
	isPressed _ false.
	mouseIsOver _ false.
	(actWhen == #buttonUp and: [self containsPoint: evt eventPosition])
		ifTrue: [ self performAction ].
	self redrawNeeded! !
!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 12/12/2011 10:50' prior: 16914904!
                   addToScroller: aMorph

	aMorph morphPosition: scroller morphPosition.
	scroller addMorph: aMorph! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:50' prior: 16915100!
 scrollerOffset
	^self viewableBounds topLeft - scroller morphPosition! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:52' prior: 16915105!
                            scrollerOffset: newOffset
	scroller morphPosition: self viewableBounds topLeft - newOffset! !
!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 12/30/2011 23:43' prior: 16866476!
                               mouseDown: evt

	| aMorph |
	evt hand newKeyboardFocus: self.
	aMorph _ self itemFromPoint: evt eventPosition.
	(aMorph notNil and: [ aMorph inToggleArea: evt eventPosition ])
		ifTrue: [ ^self toggleExpandedState: aMorph event: evt ]. 
	evt mouseButton2Pressed  "First check for option (menu) click"
		ifTrue: [ ^ self mouseButton2Activity ].
	aMorph ifNil: [ ^super mouseDown: evt ].
	aMorph highlightForMouseDown.
	evt hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: evt 
		clkSel: #click:
		clkNHalf: nil
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:28' prior: 16866504!
               mouseUp: event 
	| aMorph |
	aMorph := self itemFromPoint: event eventPosition.
	aMorph ifNil: [^self].
	aMorph highlightedForMouseDown ifFalse: [^self].
	aMorph highlightForMouseDown: false.
	"No change if model is locked"
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].
	((autoDeselect isNil or: [autoDeselect]) and: [aMorph == selectedMorph]) 
		ifTrue: [self setSelectedMorph: nil]
		ifFalse: [self setSelectedMorph: aMorph].
	Cursor normal show! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:30' prior: 16914057!
                            doubleClick: event
	| index |
	doubleClickSelector ifNil: [^super doubleClick: event].
	index _ self rowAtLocation: event eventPosition.
	index = 0 ifTrue: [^super doubleClick: event].
	"selectedMorph ifNil: [self setSelectedMorph: aMorph]."
	^ self model perform: doubleClickSelector! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 12/30/2011 23:43' prior: 16914069!
        mouseDown: evt

	| row |
	evt mouseButton2Pressed  "First check for option (menu) click"
		ifTrue: [^ self mouseButton2Activity].
	self hasKeyboardFocus ifFalse: [
		evt hand newKeyboardFocus: self.
		"If we are focusing, deselect, so that later selection doesn't result in deselect."
		self listMorph noSelection].
	row _ self rowAtLocation: evt eventPosition.
	row = 0  ifTrue: [^super mouseDown: evt].
	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."
	evt hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: evt
		clkSel: #click:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 12/11/2011 23:30' prior: 16914093!
                              mouseUp: event
	"The mouse came up within the list; take appropriate action"

	| row |
	row _ self rowAtLocation: event eventPosition.
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].
	(autoDeselect == false and: [row = 0]) ifTrue: [^ self].  "work-around the no-mans-land bug"
	"No change if model is locked"
	((autoDeselect == nil or: [autoDeselect]) and: [row == self selectionIndex])
		ifTrue: [self changeModelSelection: 0]
		ifFalse: [self changeModelSelection: row].
	Cursor normal show.
! !
!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 12/30/2011 23:44' prior: 16914630!
 mouseDown: event

	| oldIndex oldVal row w |
	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].

	self hasKeyboardFocus ifFalse: [
		event hand newKeyboardFocus: self ].

	row _ self rowAtLocation: event eventPosition.

	row = 0 ifTrue: [^super mouseDown: event].

	w _ self ownerThatIsA: SystemWindow.
	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

		"Set meaning for subsequent dragging of selection"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row.
		oldIndex _ self getCurrentSelectionIndex.
		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].

		"Set or clear new primary selection (listIndex)"
		dragOnOrOff
			ifTrue: [self changeModelSelection: row]
			ifFalse: [self changeModelSelection: 0].

		"Need to restore the old one, due to how model works, and set new one."
		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].
		self listSelectionAt: row put: dragOnOrOff.
		"event hand releaseMouseFocus: aMorph."
		"aMorph changed"
	].
	event hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: event
		clkSel: nil
		clkNHalf: nil
		dblClkSel: #doubleClick:
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:30' prior: 16914671!
                         mouseMove: event 
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	row _ (event eventPosition y < bounds top and: [ scrollBar value > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: bounds topLeft) + 2 ]
		ifFalse: [
			(event eventPosition y > bounds bottom and: [ scrollBar value < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: bounds bottomLeft) - 3 ]
				ifFalse: [ self rowAtLocation: event eventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self changeModelSelection: row ]
		ifFalse: [ self changeModelSelection: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/11/2011 23:17' prior: 16916622!
                dragVertex: ix event: evt fromHandle: handle
	| p |
	p _ evt eventPosition.
	handle referencePosition: p.
	self verticesAt: ix put: p.
! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/11/2011 23:18' prior: 16916645!
  mouseDown: evt

	^ evt shiftPressed
		ifTrue: [((owner isKindOf: PolygonMorph) and: [owner includesHandle: self])
					ifTrue: ["Prevent insertion handles from getting edited"
							^ super mouseDown: evt].
				self toggleHandles.
				handles ifNil: [^ self].
				vertices withIndexDo:  "Check for click-to-drag at handle site"
					[:vertPt :vertIndex |
					((handles at: vertIndex*2-1 ifAbsent: [ ^self ]) containsPoint: evt eventPosition) ifTrue:
						["If clicked near a vertex, jump into drag-vertex action"
						evt hand newMouseFocus: (handles at: vertIndex*2-1)]]]
		ifFalse: [super mouseDown: evt]! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/11/2011 23:18' prior: 16916667!
       newVertex: ix event: evt fromHandle: handle
	"Insert a new vertex and fix everything up!! Install the drag-handle of the new vertex as recipient of further mouse events."

	| pt |
	(self hasProperty: #noNewVertices) ifFalse: [
		pt _ evt eventPosition.
		self setVertices: (vertices copyReplaceFrom: ix + 1 to: ix with: (Array with: pt)).
		evt hand newMouseFocus: (handles at: ((ix + 1) * 2) - 1)]
! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/12/2011 10:52' prior: 16916682!
                          updateHandles
	| newVert oldVert midPts nextVertIx tweens |
	smoothCurve
		ifTrue: [
			handles first referencePosition: vertices first.
			handles last referencePosition: vertices last.
			midPts _ OrderedCollection new.
			nextVertIx _ 2.
			tweens _ OrderedCollection new.
			self
				lineSegmentsDo: [:p1 :p2 | 
					tweens addLast: p2 asIntegerPoint.
					p2
							= (vertices atWrap: nextVertIx)
						ifTrue: ["Found endPoint."
							midPts addLast: (tweens at: tweens size // 2)
									+ (tweens at: tweens size + 1 // 2) // 2.
							tweens _ OrderedCollection new.
							nextVertIx _ nextVertIx + 1]].
			midPts
				withIndexDo: [:midPt :vertIndex | (closed
							or: [vertIndex < vertices size])
						ifTrue: [newVert _ handles at: vertIndex * 2.
							newVert referencePosition: midPt ]]]
		ifFalse: [vertices
				withIndexDo: [:vertPt :vertIndex | 
					oldVert _ handles at: vertIndex * 2 - 1.
					oldVert referencePosition: vertPt.
					(closed
							or: [vertIndex < vertices size])
						ifTrue: [newVert _ handles at: vertIndex * 2.
							newVert morphPosition: vertPt
									+ (vertices atWrap: vertIndex + 1) - newVert bounds extent // 2 + (1 @ -1)]]]! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:50' prior: 16917278!
         borderForm
	"A form must be created for drawing the border whenever the borderColor is translucent."

	| borderCanvas |
	borderForm ifNotNil: [^ borderForm].
	borderCanvas _ Display defaultCanvasClass forShadowOver: bounds.
	self drawBorderOn: borderCanvas.
	borderForm _ borderCanvas form.
	self arrowForms do:
		[:f |  "Eliminate overlap between line and arrowheads if transparent."
		borderForm copy: f boundingBox from: f to: f offset - self morphPosition rule: Form erase].
	^ borderForm! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:50' prior: 16917330!
                             computeBounds
	| oldBounds delta excludeHandles |
	vertices ifNil: [^ self].

	self redrawNeeded.
	oldBounds _ bounds.
	self releaseCachedState.
	bounds _ self curveBounds truncated.
	self arrowForms do: [ :f |
		bounds _ bounds merge: (f offset extent: f extent)].
	handles ifNotNil: [ self updateHandles ].

	"since we are directly updating bounds, see if any ordinary submorphs exist and move them accordingly"
	(oldBounds notNil and: [(delta _ bounds origin - oldBounds origin) ~= (0@0)]) ifTrue: [
		excludeHandles _ IdentitySet new.
		handles ifNotNil: [excludeHandles addAll: handles].
		self submorphsDo: [ :each |
			(excludeHandles includes: each) ifFalse: [
				each morphPosition: each morphPosition + delta ] ] ].
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded.! !
!PolygonMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 10:52' prior: 16917481!
    fromHand: hand
	"Let the user draw a polygon, clicking at each vertex, and ending
		by clicking within 5 of the first point..."
	| p1 poly oldVerts pN opposite |
	Cursor crossHair showWhile:
		[[Sensor anyButtonPressed] whileFalse:
			[self currentWorld displayWorldSafely; runStepMethods].
		p1 _ Sensor mousePoint].
	opposite _ (Display colorAt: p1) negated.
	opposite = Color transparent ifTrue: [opposite _ Color red].
	(poly _ LineMorph from: p1 to: p1 color: opposite width: 2) openInWorld.
	oldVerts _ {p1}.
	self currentWorld displayWorldSafely; runStepMethods.
	[true] whileTrue:
		[[Sensor anyButtonPressed] whileTrue:
			[pN _ Sensor mousePoint.
			poly setVertices: (oldVerts copyWith: pN).
			self currentWorld displayWorldSafely; runStepMethods].
		(oldVerts size > 1 and: [(pN dist: p1) < 5]) ifTrue: [
			hand morphPosition: Sensor mousePoint.  "Done -- update hand pos"
			^ (poly setVertices: (poly vertices copyWith: p1)) delete].
		oldVerts _ poly vertices.
		[Sensor anyButtonPressed] whileFalse:
			[pN _ Sensor mousePoint.
			poly setVertices: (oldVerts copyWith: pN).
			self currentWorld displayWorldSafely; runStepMethods]].
! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'jmv 12/12/2011 10:50' prior: 16917691!
                              startUpWithoutKeyboard
	"Display and make a selection from the receiver as long as the button  is pressed. Answer the current selection.  Do not allow keyboard input into the menu"
	
	^ self startUpWithCaption: nil at: ActiveHand morphPosition allowKeyboard: false! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:52' prior: 16934905!
   computeSlider
	| r |
	r _ self roomToMove.
	slider morphPosition:
		(bounds isWide
			ifTrue: [r topLeft + ((r width * value) asInteger @ 0)]
			ifFalse: [r topLeft + (0 @ (r height * value)  asInteger)])! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 12/11/2011 23:31' prior: 16935077!
                              setNextDirectionFromEvent: event

	nextPageDirection _ bounds isWide
		ifTrue: [ event eventPosition x >= slider referencePosition x ]
		ifFalse: [ event eventPosition y >= slider referencePosition y ]! !
!SketchMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 10:50' prior: 16939928!
                               form: aForm
	"Set the receiver's form"

	| oldForm |
	oldForm _ originalForm.
	originalForm _ aForm.
	self basicExtent: originalForm extent.

	oldForm ifNotNil: [ self morphPosition: self morphPosition + (oldForm extent - aForm extent // 2) ]! !
!ColorPickerMorph methodsFor: 'event handling' stamp: 'jmv 12/11/2011 23:14' prior: 16821097!
            mouseDown: evt
	| localPt |
	localPt _ evt eventPosition - bounds topLeft.
	self deleteAllBalloons.
	clickedTranslucency _ TransparentBox containsPoint: localPt.
	self inhibitDragging ifFalse: [
		(DragBox containsPoint: localPt)
			ifTrue: [^ evt hand grabMorph: self].
	].
	(RevertBox containsPoint: localPt)
		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].
	self inhibitDragging ifFalse: [self comeToFront].
	sourceHand _ evt hand.
	self startStepping.
! !
!ColorPickerMorph methodsFor: 'menu' stamp: 'jmv 12/12/2011 10:45' prior: 16821230!
     pickUpColorFor: aMorph
	"Show the eyedropper cursor, and modally track the mouse through a mouse-down and mouse-up cycle"

      | aHand localPt oldCursor |
	aHand _ aMorph isNil
		ifTrue: [self world activeHand] 
		ifFalse: [ aMorph activeHand].
	self addToWorld: aHand world near: (aMorph ifNil: [aHand world]) fullBounds.
	self owner ifNil: [^ self].

	oldCursor _ Sensor currentCursor.
	ColorPickerMorph eyeDropperCursor show.

	self updateContinuously: false.
	[Sensor anyButtonPressed]
		whileFalse: 
			 [self trackColorUnderMouse].
	self deleteAllBalloons.

	localPt _World activeHand morphPosition - bounds topLeft.
	self inhibitDragging ifFalse: [
		(DragBox containsPoint: localPt) ifTrue:
			["Click or drag the drag-dot means to anchor as a modeless picker"
			^ self anchorAndRunModeless: aHand].
	].
	(clickedTranslucency _ TransparentBox containsPoint: localPt)
		ifTrue: [selectedColor _ originalColor].

	self updateContinuously: true.
	[Sensor anyButtonPressed]
		whileTrue:
			 [self updateTargetColorWith: self indicateColorUnderMouse].
	aHand newMouseFocus: nil;
		flushEvents.
	oldCursor show.
	self delete.
		 
 ! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/12/2011 10:51' prior: 16821278!
                       addToWorld: world near: box
	| goodLocation |
	goodLocation _ self bestPositionNear: box inWorld: world.
	world allMorphsDo:
		[:p | (p isMemberOf: ColorPickerMorph) ifTrue:
		[(p ~~ self and: [p owner notNil and: [p target == target]]) ifTrue:
			[(p selector == selector and: [p argument == argument])
				ifTrue: [^ p comeToFront  "uncover existing picker"]
				ifFalse: ["place second picker relative to first"
						goodLocation _ self bestPositionNear: p bounds inWorld: world]]]].
	self morphPosition: goodLocation.
	world addMorphFront: self.
	self redrawNeeded! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/12/2011 10:45' prior: 16821314!
              indicateColorUnderMouse
	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."

	| pt |
	self pickColorAt: (pt _ World activeHand morphPosition ).
	isModal ifTrue: [
		self world activeHand morphPosition: pt.
		self world displayWorldSafely; runStepMethods].
	^ selectedColor	! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/12/2011 10:45' prior: 16821356!
       trackColorUnderMouse
	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."

	| pt |
	selectedColor _ originalColor.
	self trackColorAt: (pt _ World activeHand morphPosition ).
	isModal ifTrue: [
		self world activeHand morphPosition: pt.
		self world displayWorldSafely; runStepMethods.
		self modalBalloonHelpAtPoint: pt].
	^ selectedColor	! !
!ColorPickerMorph methodsFor: 'stepping and presenter' stamp: 'jmv 12/12/2011 10:45' prior: 16821374!
                    step

	sourceHand ifNotNil: [
		self pickColorAt: sourceHand morphPosition ]! !
!ColorPickerMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 10:51' prior: 16821382!
                         anchorAndRunModeless: aHand
	"If user clicks on the drag-dot of a modal picker,
	anchor it, and change to modeless operation."

	self initializeModal: false; originalColor: originalColor.  "reset as modeless"
	aHand flushEvents.  "Drop any events gathered during modal loop"
	aHand morphPosition: Sensor mousePoint; grabMorph: self.  "Slip into drag operation"
! !
!Sonogram methodsFor: 'all' stamp: 'jmv 12/12/2011 10:50' prior: 16947376!
        plotColumn: dataArray

	| chm1 i normVal r |
	columnForm unhibernate.
	chm1 _ columnForm height - 1.
	0 to: chm1 do:
		[:y | 
		i _ y*(dataArray size-1)//chm1 + 1.
		normVal _ ((dataArray at: i) - minVal) / (maxVal - minVal).
		normVal < 0.0 ifTrue: [normVal _ 0.0].
		normVal > 1.0 ifTrue: [normVal _ 1.0].
		columnForm bits at: chm1-y+1 put: (pixValMap at: (normVal * 255.0) truncated + 1)].
	(lastX _ lastX + 1) > (image width - 1) ifTrue:
		[self scroll].
	image copy: (r _ (lastX@0 extent: 1@image height))
			from: (32//image depth-1)@0
			in: columnForm rule: Form over.
	"self changed."
	self invalidRect: (r translateBy: self morphPosition)! !
!StarMorph methodsFor: 'editing' stamp: 'jmv 12/12/2011 10:50' prior: 16952212!
   dragVertex: label event: evt fromHandle: handle
	| ext oldR pt center |
	label == #center ifTrue: [
		self morphPosition: self morphPosition + (evt eventPosition - handle referencePosition)].

	label == #outside ifTrue: [
		center _ handles first referencePosition.
		pt _ center - evt eventPosition.
		ext _ pt r.
		oldR _ ext.
		vertices _ (0 to: 359 by: (360//vertices size)) collect: [ :angle |
			(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse: [ext])
					degrees: angle + pt degrees)
				+ center].
		handle align: handle referencePosition with: evt eventPosition ].

	self computeBounds.
! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 12/12/2011 10:50' prior: 16965017!
           makeMeVisible 

	self world extent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world extent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self isCollapsed
		ifTrue: [ self morphPosition: (RealEstateAgent assignCollapsePointFor: self)]
		ifFalse: [ self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: bounds extent world: self world) topLeft].

! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 12/12/2011 10:50' prior: 16965086!
    justDroppedInto: aMorph event: anEvent
	isCollapsed
		ifTrue: [
			self morphPosition: (self morphPosition max: 0@0).
			collapsedFrame _ bounds]
		ifFalse: [
			fullFrame _ bounds.
			TopWindow ~~ self ifTrue: [self activate]].
	^super justDroppedInto: aMorph event: anEvent! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/12/2011 10:52' prior: 16965255!
               initializeLabelArea
	"Initialize the label area (titlebar) for the window."

	| spacing |
	spacing _ self boxExtent x + 2.

	self
		addMorph: (self createCloseBox morphPosition: 2@2);
		addMorph: (self createCollapseBox morphPosition: spacing+2@2);
		addMorph: (self createExpandBox morphPosition: spacing*2+2@2);
		addMorph: (self createMenuBox morphPosition: spacing*3+2@2)! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 12/12/2011 10:52' prior: 16965463!
               openInWorld: aWorld extent: extent
	"This msg and its callees result in the window being activeOnlyOnTop"
	self morphPosition: (RealEstateAgent initialFrameFor: self world: aWorld) topLeft; extent: extent.
	^self openAsIsIn: aWorld! !
!SystemWindow methodsFor: 'top window' stamp: 'jmv 12/12/2011 10:50' prior: 16965697!
                               activateAndForceLabelToShow
	self activate.
	bounds top < 0 ifTrue: [
		self morphPosition: (self morphPosition x @ 0)]! !
!TextEditor methodsFor: 'events' stamp: 'jmv 12/30/2011 23:31' prior: 16971740!
                     doubleClickAndHalf: evt

	| here b interval |
	b _ paragraph characterBlockAtPoint: evt eventPosition.
	here _ b stringIndex.
	interval _ self privateCurrentString encompassParagraph: (here to: here).
	self selectFrom: interval first to: interval last.

	doWordSelection _ false.
	doParagraphSelection _ true.
	initialSelectionStart _ self startBlock.
	initialSelectionStop _ self stopBlock! !
!TextEditor methodsFor: 'events' stamp: 'jmv 12/30/2011 23:44' prior: 16971755!
      mouseDown: evt 
	| clickPoint b |

	initialSelectionStart _ nil.
	initialSelectionStop _ nil.
	doWordSelection _ false.
	doParagraphSelection _ false.

	"Multiple selection of text.
	Windows uses Control, Mac uses Command (i.e. commandAlt)
	On the Mac, command-button1 is translated to command-button3 by the VM. do:
		Preferences disable: #commandClickOpensHalo
	to disable this behavior and make command-button1 work for multiple selection. "
	(evt controlKeyPressed or: [ evt commandAltKeyPressed ]) ifTrue: [
		self selectionInterval size > 0 ifTrue: [
			selectionStartBlocks _ selectionStartBlocks copyWith: self startBlock.
			selectionStopBlocks _ selectionStopBlocks copyWith: self stopBlock ]]
	ifFalse: [
		selectionStartBlocks _ #().
		selectionStopBlocks _ #() ].

	clickPoint _ evt eventPosition.
	b _ paragraph characterBlockAtPoint: clickPoint.

	(paragraph clickAt: clickPoint) ifTrue: [
		markBlock _ b.
		pointBlock _ b.
		evt hand releaseKeyboardFocus: self.
		^ self ].
	
	evt shiftPressed
		ifFalse: [
			(self markIndex = b stringIndex and: [ self pointIndex = b stringIndex ])
				ifTrue: [
					markBlock _ b.
					pointBlock _ b ]
				ifFalse: [
					markBlock _ b.
					pointBlock _ b.	
					self setEmphasisHereFromText ]]! !
!TextEditor methodsFor: 'events' stamp: 'jmv 12/30/2011 23:48' prior: 16971797!
          mouseMove: evt
	"Change the selection in response to mouse-down drag"

	| b interval i1 i2 |

	doWordSelection ifTrue: [
		pointBlock _ (paragraph characterBlockAtPoint: (evt eventPosition)).
		self selectWordLeftDelimiters: '' rightDelimiters: ''.
		markBlock _ self startBlock min: initialSelectionStart.
		pointBlock _ self stopBlock max: initialSelectionStop.
		self storeSelectionInParagraph.
		^self ].

	doParagraphSelection ifTrue: [
		b _ paragraph characterBlockAtPoint: evt eventPosition.
		i1 _ b stringIndex min: initialSelectionStart stringIndex.
		i2 _ b stringIndex max: initialSelectionStop stringIndex-1.
		interval _ self privateCurrentString encompassParagraph: (i1 to: i2).
		self selectFrom: interval first to: interval last.
		markBlock _ self startBlock min: initialSelectionStart.
		pointBlock _ self stopBlock max: initialSelectionStop.
		self storeSelectionInParagraph.
		^self ].

	pointBlock _ (paragraph characterBlockAtPoint: (evt eventPosition)).
	self storeSelectionInParagraph! !
!TextEditor methodsFor: 'events' stamp: 'jmv 12/11/2011 23:19' prior: 16971831!
                          mouseUp: evt
	| cursorBlock cursorIndex startBlock startIndex stopBlock stopIndex |

	evt shiftPressed
		ifTrue: [
			"Squeak classic behavior for click, move, shift-click sequence "
			"pointBlock _(paragraph characterBlockAtPoint: (evt eventPosition))."

			"Mac behavior"
			cursorBlock _ paragraph characterBlockAtPoint: evt eventPosition.
			cursorIndex _ cursorBlock stringIndex.
			startBlock _ self startBlock min: cursorBlock.
			startIndex _ startBlock stringIndex.
			stopBlock _ self stopBlock max: cursorBlock.
			stopIndex _ stopBlock stringIndex.
			(stopIndex - cursorIndex) < (cursorIndex - startIndex)
				ifTrue: [
					markBlock _ startBlock.
					pointBlock _ cursorBlock ]
				ifFalse: [
					markBlock _ stopBlock.
					pointBlock _ cursorBlock ]].
	self storeSelectionInParagraph! !
!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 12/11/2011 23:32' prior: 16973778!
                              scrollSelectionIntoView: event
	"Scroll my text into view if necessary and return true, else return false"
	| selRects rectToTest cpHere |
	selRects _ self textMorph selectionRects.
	selRects isEmpty ifTrue: [ ^ self ].
	rectToTest _ selRects first merge: selRects last.
	(event notNil and: [ event anyButtonPressed ]) ifTrue: [  "Check for autoscroll"
		cpHere _ event eventPosition.
		cpHere y <= bounds top
			ifTrue:  [ rectToTest _ selRects first topLeft extent: 2@2 ]
			ifFalse: [
				cpHere y >= bounds bottom
					ifTrue: [ rectToTest _ selRects last bottomRight extent: 2@2 ]
					ifFalse: [ ^ self ]]].
	^ self scrollToShow: rectToTest! !
!MouseEvent methodsFor: 'comparing' stamp: 'jmv 12/11/2011 23:29' prior: 16901120!
   = aMorphicEvent
	super = aMorphicEvent ifFalse:[^false].
	position = aMorphicEvent eventPosition ifFalse: [^ false].
	buttons = aMorphicEvent buttons ifFalse: [^ false].
	^ true
! !
!MouseEvent methodsFor: 'printing' stamp: 'jmv 12/11/2011 23:37' prior: 16901181!
                        printOn: aStream

	aStream nextPut: $[.
	aStream nextPutAll: self eventPosition printString; space.
	aStream nextPutAll: type; space.
	aStream nextPutAll: self modifierString.
	aStream nextPutAll: self buttonString.
	aStream nextPutAll: timeStamp printString.
	aStream nextPut: $].! !
!MouseMoveEvent methodsFor: 'comparing' stamp: 'jmv 12/11/2011 23:29' prior: 16901270!
            = aMorphicEvent
	super = aMorphicEvent ifFalse:[^false].
	position = aMorphicEvent eventPosition ifFalse: [^ false].
	startPoint = aMorphicEvent startPoint ifFalse: [^ false].
	buttons = aMorphicEvent buttons ifFalse: [^ false].
	^ true
! !
!WindowEdgeAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 10:50' prior: 16985939!
              handPoint
	^ hand morphPosition! !

MouseEvent removeSelector: #position!

MouseEvent removeSelector: #position!

UserInputEvent removeSelector: #position!

UserInputEvent removeSelector: #position!

SystemWindow removeSelector: #position:!

SystemWindow removeSelector: #position:!

PasteUpMorph removeSelector: #position:!

PasteUpMorph removeSelector: #position:!

HaloMorph removeSelector: #position:!

HaloMorph removeSelector: #position:!

Morph removeSelector: #position!

Morph removeSelector: #position!

Morph removeSelector: #position:!

Morph removeSelector: #position:!

DropEvent removeSelector: #position!

DropEvent removeSelector: #position!

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1289-positionFalsePolymorphism-jmv.8.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 2:37:37 pm'!

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!
!Morph methodsFor: 'as yet unclassified' stamp: 'jmv 12/12/2011 11:15'!
        initPosExtent
"
Morph allSubInstancesDo: [ :m | m initPosExtent ]
"
	position ifNil: [
		position _ owner
			ifNil: [ bounds topLeft ]
			ifNotNil: [
				owner initPosExtent.
				owner internalizeFromWorld: bounds topLeft ]].
	extent ifNil: [ extent _ bounds extent ].! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 23:00'!
                   externalizeToWorld: aPoint
	"aPoint is in own coordinates. Answer is in world coordinates."
	^owner
		ifNotNil: [ owner internalizeFromWorld: aPoint + position ]
		ifNil: [ aPoint + position ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 22:59'!
                               internalizeFromWorld: aPoint
	"aPoint is in World coordinates. Answer is in own coordinates."
	^(owner
		ifNotNil: [ owner internalizeFromWorld: aPoint ]
		ifNil: [ aPoint ])
			- position! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 22:59'!
                            externalizeToWorld: aPoint
	"aPoint is in own coordinates. Answer is in world coordinates."
	^self isWorldMorph
		ifTrue: [ aPoint ]
		ifFalse: [ super externalizeToWorld: aPoint ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 22:59'!
    internalizeFromWorld: aPoint
	"aPoint is in World coordinates. Answer is in own coordinates."
	^self isWorldMorph
		ifTrue: [ aPoint ]
		ifFalse: [ super internalizeFromWorld: aPoint ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 19:05' prior: 16897808!
                       basicExtent: aPoint

	bounds extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	bounds _ bounds topLeft extent: aPoint.
	extent _ aPoint.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 13:22' prior: 50364412!
    morphPosition: aPoint
	"Change the position of this morph and and all of its submorphs."

	"Detesto el falso polimorfismo con streams. Ponerle otro nombre a esto!!
	Igual, todavia esta #position, el getter, que es igual de feo..."
	
	"
	VER SENDERS. Acomodar. el argumento es en coord del owner o del world?
	Convertir los senders a senders de #zzpositionInOwner: o #zzpositionInWorld
	Espero que pocos hablen en coordenadas del world!!
	"

	| delta |
	delta _ aPoint - bounds topLeft.
	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.
	self privateFullMoveBy: delta.

	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].

	self redrawNeeded
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/11/2011 19:08' prior: 16898319!
          initialize
	"initialize the state of the receiver"

	owner _ nil.
	submorphs _ #().
	bounds _ self defaultBounds.
	position _ bounds topLeft.
	extent _ bounds extent.
	color _ self defaultColor! !
!Morph methodsFor: 'private' stamp: 'jmv 12/12/2011 11:16' prior: 16899783!
               privateBounds: boundsRect
	"Private!! Use position: and/or extent: instead."

	fullBounds _ nil.
	bounds _ boundsRect.
	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].
	extent _ bounds extent.! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 12/11/2011 19:22' prior: 16865312!
            initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	bounds _ 0@0 extent: CursorWithMask normal extent.
	position _ 0@0.
	extent _ CursorWithMask normal extent.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 12/11/2011 19:20' prior: 16887838!
  initialize
	super initialize.
	bounds _ 0@0 corner: 40@10.
	position _ 0@0.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil
! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/11/2011 19:21' prior: 16911766!
                             extent: aPoint

	bounds extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 12/12/2011 11:19' prior: 50366189!
                   viewBox: newViewBox
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
	super morphPosition: newViewBox topLeft.
	fullBounds _ bounds _ newViewBox.
	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].
	extent _ bounds extent.! !

!classDefinition: #Morph category: #'Morphic-Kernel'!
Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

Object subclass: #Morph
	instanceVariableNames: 'bounds owner submorphs fullBounds color extension position extent'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Kernel'!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 2:48:24 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:06'!
                              morphHeight
"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	^ bounds height! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:06'!
                              morphHeight: aNumber

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self extent: bounds width@aNumber asInteger.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 09:02'!
                      morphPositionInOwner
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"

	self flag: #jmvVer2.
	self validateOwnerNotNil.
	self validatePositionAndBounds.

	^ position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 20:47'!
                     morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = bounds topLeft ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

owner ifNil: [
	'-----trying to set position before setting owner... bad idea!!-----' print.
	thisContext printStack: 10 ].


"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 09:02'!
                               morphPositionInWorld
	| answer1 answer2 |
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"


	self flag: #jmvVer2.
	self validateOwnerNotNil.
	self validatePositionAndBounds.
	
	answer1 _ owner
		ifNotNil: [ owner externalizeToWorld: position ]
		ifNil: [ position ].
	answer2 _ bounds topLeft.
	{ answer1 . answer2 }.

	^answer2! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 20:47'!
                 morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
owner ifNil: [
	'-----trying to set position before setting owner... bad idea!!-----' print.
	thisContext printStack: 10 ].

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
"Quizas no un null change del todo... Es posible que bounds y position se desincronicen, al cambiar el owner (o cualquier owner en el medio). Todo esto es fulerote. espero sacarlo pronto!!"
		self privateFullMoveBy: newPositionInWorld - bounds topLeft.
		^ self ].		"Null change"


	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:09'!
        morphWidth

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	^ bounds width! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:09'!
                               morphWidth: aNumber
"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self extent: aNumber asInteger@bounds height.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 09:01'!
                       validateOwnerNotNil
	"To be removed. Just to check consistency"

	self flag: #jmvVer2.
	owner ifNil: [
		'-----Still no owner, but this stuff kind of requires it!!-----' print.
		thisContext printStack: 10 ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 20:38'!
                validatePositionAndBounds
	"To be removed. Just to check consistency"
	| answer1 answer2 |
	self flag: #jmvVer2.

	answer1 _ owner
		ifNotNil: [ owner externalizeToWorld: position ]
		ifNil: [ position ].
	answer2 _ bounds topLeft.

	answer1 = answer2 ifFalse: [
		#validatePositionAndBounds print.
		answer1 print.
		answer2 print.
		thisContext printStack: 10 ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 16:14'!
             morphPositionInWorld

	self flag: #jmvVer2. "Solo para evitar los warning por falta de owner... pensar despues este caso"
	self isWorldMorph ifTrue: [ ^ 0@0 ].
	^super morphPositionInWorld! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:39'!
                            windowBottom: aNumber
	"aNumber is an Y coordinate in the owner's coordinate system"
	self bounds: (bounds bottom: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:40'!
                             windowBottomLeft: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self bounds: (aPoint x @ bounds top corner: bounds right @ aPoint y)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:41'!
                     windowBottomRight: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self bounds: (bounds origin corner: aPoint)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:41'!
             windowLeft: aNumber
	"aNumber is an X coordinate in the owner's coordinate system"
	self bounds: (bounds left: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:42'!
 windowRight: aNumber
	"aNumber is an X coordinate in the owner's coordinate system"
	self bounds: (bounds right: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:42'!
                               windowTop: aNumber
	"aNumber is an Y coordinate in the owner's coordinate system"
	self bounds: (bounds top: aNumber)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:43'!
   windowTopLeft: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self bounds: (aPoint corner: bounds corner)! !
!SystemWindow methodsFor: 'resizing' stamp: 'jmv 12/13/2011 14:43'!
                 windowTopRight: aPoint
	"aPoint is an X@Y coordinate pair in the owner's coordinate system"
	self bounds: (bounds left @ aPoint y corner: aPoint x @ bounds bottom)! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
                          forBottom
	^self new initializeBottom! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
                        forBottomLeft
	^self new initializeBottomLeft! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
                forBottomRight
	^self new initializeBottomRight! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
              forLeft
	^self new initializeLeft! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:57'!
                            forRight
	^self new initializeRight! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:58'!
                          forTop
	^self new initializeTop! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:58'!
                              forTopLeft
	^self new initializeTopLeft! !
!WindowEdgeAdjustingMorph class methodsFor: 'instance creation' stamp: 'jmv 12/12/2011 13:58'!
                      forTopRight
	^self new initializeTopRight! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 12/13/2011 23:33' prior: 16803680!
                           placeEmbeddedObject: anchoredFormOrMorph
	"Place the anchoredMorph or return false if it cannot be placed.
	In any event, advance destX by its width."

	destX _ destX + anchoredFormOrMorph morphWidth.
	(destX > rightMargin and: [ lastIndex ~= line first ])
		"Won't fit, but  not at start of a line. Start a new line with it"
		ifTrue: [ ^ false].
	lastIndex _ lastIndex + 1.
	^ true! !
!CharacterBlockScanner methodsFor: 'scanning' stamp: 'jmv 12/13/2011 23:33' prior: 16803579!
placeEmbeddedObject: anchoredFormOrMorph

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	specialWidth _ anchoredFormOrMorph morphWidth.
	^ true! !
!CompositionScanner methodsFor: 'stop conditions' stamp: 'jmv 12/13/2011 23:35' prior: 16825773!
                    placeEmbeddedObject: anchoredFormOrMorph
	| descent |

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [
		line stop: lastIndex-1.
		^ false].
	descent _ lineHeight - baseline.
	baseline _ baseline max: anchoredFormOrMorph morphHeight.
	lineHeight _ baseline + descent.
	line stop: lastIndex.
	^ true! !
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 12/13/2011 23:35' prior: 16880957!
                  fixedOrMorphHeight: aNumber
	"aNumber is taken as the fixed height to use.
	No proportional part."
	fixedHeight
		ifNotNil: [ fixedHeight _ aNumber ]
		ifNil: [ morph morphHeight: aNumber ].
	proportionalHeight _ nil! !
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 12/13/2011 23:34' prior: 16880966!
                 fixedOrMorphWidth: aNumber
	"aNumber is taken as the fixed width to use.
	No proportional part."
	fixedWidth
		ifNotNil: [ fixedWidth _ aNumber ]
		ifNil: [ morph morphWidth: aNumber ].
	proportionalWidth _ nil! !
!LayoutSpec methodsFor: 'layout' stamp: 'jmv 12/13/2011 23:35' prior: 16881091!
                          fixedHeight
	"If proportional is zero, answer stored fixed extent, or actual morph extent if undefined. (no proportional extent is computed)
	Otherwise, we do proportional layout, and the stored extent is a minimum extent, so we don't  really a fixed extent."
	proportionalHeight ifNotNil: [
		^0 ].
	^ fixedHeight ifNil: [ morph morphHeight ]! !
!LayoutSpec methodsFor: 'layout' stamp: 'jmv 12/13/2011 23:33' prior: 16881104!
                     fixedWidth
	"If proportional is zero, answer stored fixed extent, or actual morph extent if undefined. (no proportional extent is computed)
	Otherwise, we do proportional layout, and the stored extent is a minimum extent, so we don't  really a fixed extent."
	proportionalWidth ifNotNil: [
		^0 ].
	^ fixedWidth ifNil: [ morph morphWidth ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 09:01' prior: 50367165!
                            basicExtent: aPoint

	self flag: #jmvVer2.
	"Lo dejo un rato porque se llama dde initialize... De ultima, es un problema? Es cierto que no se la escala aun..."
	"
	self validateOwnerNotNil.
	"
	
	"ver senders. Es en owner's o en world's ???"
	
	
	bounds extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	bounds _ bounds topLeft extent: aPoint.
	extent _ aPoint.
	self validatePositionAndBounds.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:10' prior: 16897816!
  bounds
	"Return the bounds of this morph."
	"Note: It is best not to override this method because many methods in Morph and its subclasses use the instance variable directly rather than 'self bounds'. Instead, subclasses should be sure that the bounds instance variable is correct."

	"remove senders and implementors"
	self flag: #jmvVer2.

	^ bounds
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:10' prior: 50364712!
               bounds: newBounds
	| oldExtent newExtent |

	"remove senders and implementors"
	self flag: #jmvVer2.
		
	oldExtent _ bounds extent.
	newExtent _ newBounds extent.
	"Moving stuff around is most likely the most common operation.
	Optimize it"
	oldExtent = newExtent ifTrue: [
		^self morphPosition: newBounds topLeft ].
	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[
		"We're growing. First move then resize."
		self morphPosition: newBounds topLeft; extent: newExtent.
	] ifFalse: [
		"We're shrinking. First resize then move."
		self extent: newExtent; morphPosition: newBounds topLeft.
	].! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:11' prior: 16897847!
                               extent
"
?
'' print.
thisContext printStack: 10.
"
"Needs to be turned into extentInOwner and extentInWorld"
"or better yet into morphExtent:, and assume it is always in owner's coordinates!!"
	self flag: #jmvVer2.
	^ bounds extent! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:11' prior: 16897850!
        extent: aPoint
"
?
'' print.
thisContext printStack: 10.
"
"Needs to be turned into extentInOwner: and extentInWorld:"
"or better yet into morphExtent:, and assume it is always in owner's coordinates!!"
	self flag: #jmvVer2.
	self basicExtent: aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 16:01' prior: 50367130!
                     externalizeToWorld: aPoint
	"aPoint is in own coordinates. Answer is in world coordinates."
	self flag: #jmvVer2.
	^owner
		ifNotNil: [ owner externalizeToWorld: aPoint + position ]
		ifNil: [ aPoint + position ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:08' prior: 16897853!
                           height
	self flag: #jmvVer2.
"False polymorphism elimination: turn senders into morphHeight"
'' print.
thisContext printStack: 10.
	^ bounds height! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:07' prior: 16897856!
                            height: aNumber
	self flag: #jmvVer2.
"False polymorphism elimination: turn senders into morphHeight:"
'' print.
thisContext printStack: 10.
	self extent: bounds width@aNumber asInteger.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:07' prior: 16897860!
                    innerBounds
	"Return the inner rectangle enclosed by the bounds of this morph excluding the space taken by its borders. For an unbordered morph, this is just its bounds."

"In own's coordinates!!"
	self flag: #jmvVer2.
	^ bounds! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 16:01' prior: 50367139!
           internalizeFromWorld: aPoint
	"aPoint is in World coordinates. Answer is in own coordinates."
	self flag: #jmvVer2.
	^(owner
		ifNotNil: [ owner internalizeFromWorld: aPoint ]
		ifNil: [ aPoint ])
			- position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:06' prior: 16897868!
                             minimumExtent
	| ext |
	"This returns the minimum extent that the morph may be shrunk to.  Not honored in too many places yet, but respected by the resizeToFit feature, at least.  copied up from SystemWindow 6/00"
	self flag: #jmvVer2.	"in owner's coordinates?"
	(ext _ self valueOfProperty: #minimumExtent)
		ifNotNil:
			[^ ext].
	^ 100 @ 80! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 15:45' prior: 50364402!
                        morphPosition
"
Ver que senders quieren #morphPositionInOwner y quienes #morphPosirionInWorld (espero que pocos!!)
Eventualmente eliminar los senders a este...
"
	self flag: #jmvVer2.
	^ self morphPositionInWorld! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 15:45' prior: 50367174!
                           morphPosition: newPositionInWorld
"Cuando terminemos, el arg es en coords del owner
entonces: Warning: argument is in owner's coordinate system. When creating new morphs, first add to owner, then set position."
	"Change the position of this morph."
	"
	Para morphs que estan en el mundo, da lo mismo!! Y para los que estan en otro morph, la mayoria de las veces usaremos un layout. Y las veces que no, usaremos coordenadas del owner tambien!!
	Podemos hacer que por default, #morphPosition y #morphPosition: sean en el owner, y chequear los senders...
	Quizas el camino es ir cambiando los senders a isOwner, y cuando todos sean ahi, eliminar los demas... suena razonable, no?
	Lo mismo para setter.
	Lo mismo para extent, height, width... aunque aqui, hasta que no introduzca factor de escala, no es tan urgente (i.e. no se rompe ya mismo!!) Eso quiere decir que no necesito pasar por los sufijos provisorios InOwner e InWorld!!
	Y en algun momento de todo esto, empezar a atacar los usos directos de la ivar bounds!!
	"
	
	"
Ver que senders quieren #morphPositionInOwner: y quienes #morphPosirionInWorld: (espero que pocos!!)
Eventualmente eliminar los senders a este...
NO OLVIDARSE que hay redefiniciones de este metodo... Redefinir los 2 setters que quedan?
	"
	self flag: #jmvVer2.
	^self morphPositionInWorld: newPositionInWorld! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:08' prior: 16897895!
                        width

	self flag: #jmvVer2.
"False polymorphism elimination: turn senders into morphWidth"
'' print.
thisContext printStack: 10.
	^ bounds width! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 21:08' prior: 16897898!
                              width: aNumber

	self flag: #jmvVer2.
"False polymorphism elimination: turn senders into morphWidth:"
'' print.
thisContext printStack: 10.
	self extent: aNumber asInteger@bounds height.
! !
!Morph methodsFor: 'geometry eToy' stamp: 'jmv 12/14/2011 15:51' prior: 50364733!
               referencePosition: aPoint
	"a rather ugly way to say #center: . Just for consistency with #referencePosition"
	self flag: #jmvVer2.
	self morphPosition: aPoint - (bounds extent // 2)! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/14/2011 16:04' prior: 16898303!
                   inATwoWayScrollPane
	"Answer a two-way scroll pane that allows the user to scroll the receiver in either direction.  It will have permanent scroll bars unless you take some special action."

	| widget |
	self flag: #jmvVer2.
	widget _ PluggableScrollPane new.
	widget addToScroller: self.
	widget extent: (self morphWidth min: 300 max: 100) @ (self morphHeight min: 150 max: 100).
	widget setScrollDeltas.
	widget color: self color darker darker.
	^widget! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/15/2011 20:43' prior: 50367203!
  initialize
	"initialize the state of the receiver"

	owner _ nil.
	submorphs _ #().
	
	self flag: #jmvVer2.
	"Ir convirtiendo todos los usos (no las asignaciones!!) a las vars nuevas.
	Despues eliminar las asignaciones y las propias ivars (bounds y fullBounds)"
	bounds _ self defaultBounds.

	position _ bounds topLeft.
	extent _ bounds extent.
	self validatePositionAndBounds.
	color _ self defaultColor! !
!Morph methodsFor: 'private' stamp: 'jmv 12/16/2011 09:03' prior: 16899789!
                           privateFullMoveBy: delta
	"Private!! Relocate me and all of my subMorphs by recursion. Subclasses that implement different coordinate systems may override this method."

	"All these will die soon!!"
	self flag: #jmvVer2.

	self privateMoveBy: delta.
	submorphs do: [ :m |
		m privateFullMoveBy: delta ]! !
!Morph methodsFor: 'private' stamp: 'jmv 12/16/2011 09:03' prior: 16899799!
  privateMoveBy: delta
	"Private!! Use 'position:' instead."

	"All these will die soon!!"

	self flag: #jmvVer2.
	self validateOwnerNotNil.

	bounds _ bounds translateBy: delta.
	fullBounds ifNotNil: [ fullBounds _ fullBounds translateBy: delta ].! !
!Morph methodsFor: 'private' stamp: 'jmv 12/16/2011 09:04' prior: 16899806!
                          privateOwner: aMorph
	"Private!! Should only be used by methods that maintain the ower/submorph invariant."

	| oldGlobalPosition prevOwner |
	self flag: #jmvVer2.
	"
	(aMorph notNil and: [
		bounds origin ~= self defaultBounds origin ]) ifTrue: [
			'                                ---------------- Nos mandan #privateOwner: , pero nos han mandado bounds antes (no necesariamente un problema!!!!!!!!!!)!!' print.
			thisContext printStack: 10 ].
	"
		
	self flag: #jmvVer2.
	"Is this the best behavior???"
	prevOwner _ owner.
	prevOwner
		ifNotNil: [
			"Had an owner. Maintain my global position..."
			oldGlobalPosition _ self morphPositionInWorld ].
	owner _ aMorph.
	owner
		ifNil: [
			"Won't have any owner. Keep local position, as it will be maintained in my new owner later"
			bounds _ position extent: bounds extent.
			fullBounds _ nil.
			self validatePositionAndBounds
			]
		ifNotNil: [
			prevOwner
				ifNil: [
					"Didn't have any owner. Assume my local position is to be maintained in my new owner"
					bounds _ (owner externalizeToWorld: position) extent: bounds extent.
					fullBounds _ nil.
					self validatePositionAndBounds
					]
				ifNotNil: [
					"Had an owner. Maintain my global position..."
					position _ owner internalizeFromWorld: oldGlobalPosition.
					self validatePositionAndBounds
					]]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 19:56' prior: 50365032!
                      addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w |
	w := self world ifNil: [target world].
	nameMorph := StringMorph contents: aString.
	nameMorph color: Color magenta.
	namePosition := outerRectangle bottomCenter 
				- ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph 
		morphPosition: (namePosition min: w viewBox bottomRight - nameMorph extent y + 5).
	self addMorph: (RectangleMorph new
		bounds: (nameMorph bounds outsetBy: 2);
		borderWidth: 0;
		color: (Color lightBlue alpha: 0.9)).
	self addMorph: nameMorph.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 19:56' prior: 16864064!
   basicBox
	| aBox minSide anExtent w |
	minSide _ 4 * self handleSize.
	anExtent _ ((self morphWidth + self handleSize + 8) max: minSide) @
				((self morphHeight + self handleSize + 8) max: minSide).
	aBox _ Rectangle center: bounds center extent: anExtent.
	w _ self world ifNil: [ target outermostWorldMorph ].
	^ w
		ifNil:
			[ aBox ]
		ifNotNil:
			[ aBox intersect: (w viewBox insetBy: 8@8) ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/14/2011 15:56' prior: 50365064!
                              doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target bounds topLeft.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target extent: newExtent.
	growHandle morphPosition: evt eventPosition - (growHandle extent // 2).
	self someSubmorphPositionOrExtentChanged
! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/14/2011 15:56' prior: 50365099!
 doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Color lightBlue]
		ifFalse: [rotHandle color: Color blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPosition: evt eventPosition - (rotHandle extent // 2).
	self someSubmorphPositionOrExtentChanged! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 12/15/2011 20:46' prior: 50367223!
                       initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	bounds _ 0@0 extent: CursorWithMask normal extent.
	position _ 0@0.
	extent _ CursorWithMask normal extent.
	self validatePositionAndBounds.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:31' prior: 16869456!
                      adjustExtent
	"And reposition submorphs"
	| w p0 h y |
	"make all items wide, so selection indicator is wide too"
	w _ self desiredWidth.
	p0 _ bounds topLeft..
	y _ 0.
	self submorphsDo: [ :m |
		h _ m morphHeight.
		m privateBounds: (p0 + (0@y) extent: w@h).
		y _ y + h ].
	self extent: w@y! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 12/12/2011 14:19' prior: 16869890!
model: aTextModel wrappedTo: width
	"Accept new text contents.  Lay it out, wrapping to width.
	Then fit my height to the result."
	wrapFlag _ true.
	self basicExtent: width truncated@self morphHeight.
	self model: aTextModel! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 12/12/2011 14:18' prior: 16880116!
          adjustHorizontallyBy: aLayoutAdjustMorph at: aPoint
	| delta l ls r rs lNewWidth rNewWidth i lCurrentWidth rCurrentWidth doNotResizeBelow |
	doNotResizeBelow _ self minPaneWidthForReframe.
	i _ submorphs indexOf: aLayoutAdjustMorph.
	l _ self submorphs at: i +1.
	ls _ l layoutSpec.
	lCurrentWidth _ l morphWidth max: 1.	"avoid division by zero"
	r _ self submorphs at: i - 1.
	rs _ r layoutSpec.
	rCurrentWidth _ r morphWidth max: 1.	"avoid division by zero"
	delta _ aPoint x - aLayoutAdjustMorph referencePosition x.
	delta _ delta max: doNotResizeBelow - lCurrentWidth.
	delta _ delta min: rCurrentWidth - doNotResizeBelow.
	delta = 0 ifTrue: [ ^self ].
	rNewWidth _ rCurrentWidth - delta.
	lNewWidth _ lCurrentWidth + delta.
	(ls isProportionalWidth and: [ rs isProportionalWidth ])
		ifTrue: [	"If both proportional, update them"
			ls setProportionalWidth: (1.0 * lNewWidth / lCurrentWidth * ls proportionalWidth).
			rs setProportionalWidth: (1.0 * rNewWidth / rCurrentWidth * rs proportionalWidth) ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ls isProportionalWidth ifFalse: [
				ls fixedOrMorphWidth: lNewWidth ].
			rs isProportionalWidth ifFalse: [
				rs fixedOrMorphWidth: rNewWidth ]].
	self layoutSubmorphs.
	fullBounds _ bounds! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 12/12/2011 14:18' prior: 16880158!
                        adjustVerticallyBy: aLayoutAdjustMorph at: aPoint
	| delta t ts b bs tNewHeight bNewHeight i tCurrentHeight bCurrentHeight doNotResizeBelow |
	doNotResizeBelow _ self minPaneHeightForReframe.
	i _ submorphs indexOf: aLayoutAdjustMorph.
	t _ self submorphs at: i +1.
	ts _ t layoutSpec.
	tCurrentHeight _ t morphHeight max: 1.	"avoid division by zero"
	b _ self submorphs at: i - 1.
	bs _ b layoutSpec.
	bCurrentHeight _ b morphHeight max: 1.	"avoid division by zero"
	delta _ aPoint y - aLayoutAdjustMorph referencePosition y.
	delta _ delta max: doNotResizeBelow - tCurrentHeight.
	delta _ delta min: bCurrentHeight - doNotResizeBelow.
	delta = 0 ifTrue: [ ^self ].
	tNewHeight _ tCurrentHeight + delta.
	bNewHeight _ bCurrentHeight - delta.
	(ts isProportionalHeight and: [ bs isProportionalHeight ])
		ifTrue: [	"If both proportional, update them"
			ts setProportionalHeight: (1.0 * tNewHeight / tCurrentHeight * ts proportionalHeight).
			bs setProportionalHeight: (1.0 * bNewHeight / bCurrentHeight * bs proportionalHeight) ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ts isProportionalHeight ifFalse: [
				ts fixedOrMorphHeight: tNewHeight ].
			bs isProportionalHeight ifFalse: [
				bs fixedOrMorphHeight: bNewHeight ]].
	self layoutSubmorphs.
	fullBounds _ bounds! !
!MenuLineMorph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 14:20' prior: 16887230!
                 initialize
	super initialize.
	self morphHeight: 2! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 12/12/2011 14:27' prior: 16887433!
                     addStayUpIcons
	| closeBox pinBox w |
	
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	closeBox _ PluggableButtonMorph model: self action: #delete.
	closeBox icon: Theme current closeIcon.
	pinBox _ PluggableButtonMorph model: self action: #stayUp.
	pinBox icon: Theme current pushPinIcon.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 42.
	self addMorphFront: 
		(LayoutMorph newRow
			morphHeight: (titleMorph morphHeight max: 19);
			morphWidth: w;	"Make room for buttons"
			color: Color transparent;
			addMorph: closeBox fixedWidth: 20;
			addMorph: (RectangleMorph new borderWidth: 0; color: Color transparent) fixedWidth: 4;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (RectangleMorph new borderWidth: 0; color: Color transparent) fixedWidth: 4;
			addMorph: pinBox fixedWidth: 20).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 3/14/2012 13:47' prior: 50365624!
                     addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w |
	
	titleMorph _ RectangleMorph new.
	self setTitleParametersFor: titleMorph.
	pp _ 8@2.
	aString asString linesDo: [ :line |
		s _ StringMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		titleMorph addMorphBack: s.
		s morphPositionInOwner: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphHeight: pp y; morphWidth: w + 8.
	self addMorphFront: titleMorph.
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 12/15/2011 20:45' prior: 50367234!
                       initialize
	super initialize.
	bounds _ 0@0 corner: 40@10.
	position _ 0@0.
	self validatePositionAndBounds.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil
! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 14:25' prior: 50365784!
adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p tl |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: (
			(each respondsTo: #minItemWidth)
				ifTrue: [each minItemWidth]
				ifFalse: [each morphWidth])].

	w _ w + 4.
	tl _ bounds topLeft.
	p _ tl + 5.
	submorphs do: [ :m |
		m morphWidth: w.
		m morphPosition: p.
		p _ m bounds bottomLeft +(0@1) ].
	
	self extent: submorphs last bounds bottomRight - tl + 5! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/12/2011 14:21' prior: 50365806!
                           positionAt: aPoint relativeTo: aMenuItem inWorld: aWorld
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| i yOffset sub delta |
	self adjustSubmorphsLayout.
	i _ 0.
	yOffset _ 0.
	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]
		whileFalse: [ yOffset _ yOffset + sub morphHeight ].

	self morphPosition: aPoint - (2 @ (yOffset + 8)).

	"If it doesn't fit, show it to the left, not to the right of the hand."
	bounds right > aWorld world bounds right
		ifTrue: [
			self moveRight: aPoint x + 1].

	"Make sure that the menu fits in the world."
	delta _ bounds amountToTranslateWithin:
		(aWorld world bounds withHeight: ((aWorld world bounds height - 18) max: (ActiveHand morphPosition y) + 1)).
	delta = (0 @ 0) ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/15/2011 20:46' prior: 50367243!
 extent: aPoint

	self flag: #jmvVer2.
	bounds extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self validatePositionAndBounds.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 12/15/2011 20:46' prior: 50367259!
                           viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
"	super morphPosition: newViewBox topLeft."
	fullBounds _ bounds _ newViewBox.
	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].
	extent _ bounds extent.
	self validatePositionAndBounds.! !
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 12/13/2011 14:44' prior: 50344068!
                          bringWindowsFullOnscreen
	"Make ever SystemWindow on the desktop be totally on-screen, whenever possible."
	
	(SystemWindow windowsIn: self satisfying: [ :w | true]) do:
		[ :aWindow | 
			aWindow windowRight: (aWindow bounds right min: bounds right).
			aWindow windowBottom: (aWindow bounds bottom min: bounds bottom).
			aWindow windowLeft: (aWindow bounds left max: bounds left).
			aWindow windowTop: (aWindow bounds top max: bounds top)]! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:14' prior: 16915064!
      hTotalScrollRange
	"Return the width extent of the receiver's scrollable area"
	^scroller morphWidth! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:14' prior: 16915181!
                             vTotalScrollRange
	"Return the height extent of the receiver's scrollable area"
	^scroller morphHeight! !
!HierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:15' prior: 16866576!
                         scrollDeltaHeight
	scroller hasSubmorphs ifFalse: [ ^1].
	^ scroller firstSubmorph morphHeight! !
!LimitedHeightTextMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:20' prior: 16881445!
innerHeight: aNumber
	"Adjust height and scrollbar to the new contents height."
	self morphHeight: (aNumber + 10 min: maxHeight)! !
!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 12/12/2011 14:17' prior: 16914165!
                            initialize
	super initialize.
	scroller morphWidth: self morphWidth.
	scroller color: self textColor.! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 12/15/2011 20:45' prior: 50366548!
    computeBounds
	| oldBounds delta excludeHandles |

	self flag: #jmvVer2.
	vertices ifNil: [^ self].

	self redrawNeeded.
	oldBounds _ bounds.
	self releaseCachedState.
	bounds _ self curveBounds truncated.
	self arrowForms do: [ :f |
		bounds _ bounds merge: (f offset extent: f extent)].
	handles ifNotNil: [ self updateHandles ].

	"since we are directly updating bounds, see if any ordinary submorphs exist and move them accordingly"
	(oldBounds notNil and: [(delta _ bounds origin - oldBounds origin) ~= (0@0)]) ifTrue: [
		excludeHandles _ IdentitySet new.
		handles ifNotNil: [excludeHandles addAll: handles].
		self submorphsDo: [ :each |
			(excludeHandles includes: each) ifFalse: [
				each morphPosition: each morphPosition + delta ] ] ].
	self validatePositionAndBounds.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded.! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:17' prior: 16934914!
                              expandSlider
	"Compute the new size of the slider (use the old sliderThickness as a minimum)."
	| r |
	r _ self totalSliderArea.
	slider extent: (bounds isWide
		ifTrue: [((r width * interval) asInteger max: 7) @ slider morphHeight]
		ifFalse: [slider morphWidth @ ((r height * interval) asInteger max: 7)])! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/12/2011 13:58' prior: 16965222!
               initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	isCollapsed _ false.
	
	self wantsLabel ifTrue: [self initializeLabelArea].
	self extent: 300 @ 200.
	updatablePanes _ #().

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorph: m ].

	"by default"
	self beColumn! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985872!
           initializeBottom
	selector _ #windowBottom:.
	coordinateGetter _ #y.
	cursorGetter _ #resizeBottom! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985878!
                    initializeBottomLeft
	selector _ #windowBottomLeft:.
	coordinateGetter _ #yourself.
	cursorGetter _ #resizeBottomLeft! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985885!
 initializeBottomRight
	selector _ #windowBottomRight:.
	coordinateGetter _ #yourself.
	cursorGetter _ #resizeBottomRight! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985892!
                              initializeLeft
	selector _ #windowLeft:.
	coordinateGetter _ #x.
	cursorGetter _ #resizeLeft! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985898!
                          initializeRight
	selector _ #windowRight:.
	coordinateGetter _ #x.
	cursorGetter _ #resizeRight! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985904!
                       initializeTop
	selector _ #windowTop:.
	coordinateGetter _ #y.
	cursorGetter _ #resizeTop! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985910!
                             initializeTopLeft
	selector _ #windowTopLeft:.
	coordinateGetter _ #yourself.
	cursorGetter _ #resizeTopLeft! !
!WindowEdgeAdjustingMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 14:45' prior: 16985916!
          initializeTopRight
	selector _ #windowTopRight:.
	coordinateGetter _ #yourself.
	cursorGetter _ #resizeTopRight! !
!WindowEdgeAdjustingMorph methodsFor: 'geometry testing' stamp: 'jmv 12/13/2011 14:46' prior: 16985961!
     containsPoint: aPoint
	| sensitiveBorder |
	(bounds containsPoint: aPoint) ifFalse: [ ^false ].
	sensitiveBorder _ 4.
	selector caseOf: {
		[ #windowTopLeft: ] -> [ ^ aPoint x - bounds left < sensitiveBorder or: [ aPoint y - bounds top < sensitiveBorder ]].
		[ #windowTopRight: ] -> [ ^ bounds right - aPoint x <= sensitiveBorder or: [ aPoint y - bounds top < sensitiveBorder ]].
		[ #windowBottomLeft: ] -> [ ^ aPoint x - bounds left < sensitiveBorder or: [ bounds bottom - aPoint y <= sensitiveBorder ]].
		[ #windowBottomRight: ] -> [ ^ bounds right - aPoint x <= sensitiveBorder or: [ bounds bottom - aPoint y <= sensitiveBorder ]].
	}
	otherwise: [
		"all the morph is sensitive for horizontal and vertical (i.e. non corner) instances."
		^true ]! !

WindowEdgeAdjustingMorph class removeSelector: #bottom!

WindowEdgeAdjustingMorph class removeSelector: #bottom!

WindowEdgeAdjustingMorph class removeSelector: #bottomLeft!

WindowEdgeAdjustingMorph class removeSelector: #bottomLeft!

WindowEdgeAdjustingMorph class removeSelector: #bottomRight!

WindowEdgeAdjustingMorph class removeSelector: #bottomRight!

WindowEdgeAdjustingMorph class removeSelector: #left!

WindowEdgeAdjustingMorph class removeSelector: #left!

WindowEdgeAdjustingMorph class removeSelector: #right!

WindowEdgeAdjustingMorph class removeSelector: #right!

WindowEdgeAdjustingMorph class removeSelector: #top!

WindowEdgeAdjustingMorph class removeSelector: #top!

WindowEdgeAdjustingMorph class removeSelector: #topLeft!

WindowEdgeAdjustingMorph class removeSelector: #topLeft!

WindowEdgeAdjustingMorph class removeSelector: #topRight!

WindowEdgeAdjustingMorph class removeSelector: #topRight!

SystemWindow removeSelector: #bottom:!

SystemWindow removeSelector: #bottom:!

SystemWindow removeSelector: #bottomLeft:!

SystemWindow removeSelector: #bottomLeft:!

SystemWindow removeSelector: #bottomRight:!

SystemWindow removeSelector: #bottomRight:!

SystemWindow removeSelector: #left:!

SystemWindow removeSelector: #left:!

SystemWindow removeSelector: #right:!

SystemWindow removeSelector: #right:!

SystemWindow removeSelector: #top:!

SystemWindow removeSelector: #top:!

SystemWindow removeSelector: #topLeft:!

SystemWindow removeSelector: #topLeft:!

SystemWindow removeSelector: #topRight:!

SystemWindow removeSelector: #topRight:!

Morph removeSelector: #initPosExtent!

Morph removeSelector: #initPosExtent!

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1291-positionSettersAndFixes-jmv.6.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 3:03:39 pm'!
!InnerTextMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/13/2011 23:05'!
addMorphFrontFromWorldPosition: aMorph
	"Overridden for more specific re-layout and positioning"
	| positionInWorld |
	positionInWorld _ aMorph morphPosition.
	^self anchorMorph: aMorph at: positionInWorld! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/13/2011 20:42'!
               positionAt: aPoint relativeTo: aMenuItem
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| i yOffset sub delta |
	self adjustSubmorphsLayout.
	i _ 0.
	yOffset _ 0.
	[(sub _ self submorphs at: (i _ i + 1)) == aMenuItem]
		whileFalse: [ yOffset _ yOffset + sub morphHeight ].

	self morphPosition: aPoint - (2 @ (yOffset + 8)).

	"If it doesn't fit, show it to the left, not to the right of the hand."
	bounds right > owner world bounds right
		ifTrue: [
			self moveRight: aPoint x + 1].

	"Make sure that the menu fits in the world."
	delta _ bounds amountToTranslateWithin:
		(owner world bounds withHeight: ((owner world bounds height - 18) max: (ActiveHand morphPosition y) + 1)).
	delta = (0 @ 0) ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 23:36'!
                             openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| h w |
	aWorld addMorph: self.
	w _ ((labelMorph measureContents x max: subLabelMorph measureContents x) max: progress morphWidth) + 8.
	h _ labelMorph morphHeight + subLabelMorph morphHeight + progress morphHeight + 10.
	self bounds: (0@0 extent: w@h).
	labelMorph fitContents.
	subLabelMorph fitContents.
	self layoutSubmorphs.
	self align: self fullBounds center with: Display boundingBox center.
	aWorld startSteppingSubmorphsOf: self.! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 12/13/2011 21:12' prior: 16897989!
             addHalo: evt
	| halo prospectiveHaloClass |
	prospectiveHaloClass _ Smalltalk at: self haloClass ifAbsent: [HaloMorph].
	halo _ prospectiveHaloClass new.
	halo popUpFor: self event: evt.
	halo bounds: self worldBoundsForHalo.
	^halo! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 23:12' prior: 50364792!
 openInWorld: aWorld
	"Add this morph to the requested World."
	aWorld addMorph: self.
	aWorld startSteppingSubmorphsOf: self! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/13/2011 23:05' prior: 50364836!
       addMorphFrontFromWorldPosition: aMorph
	| positionInWorld |
	positionInWorld _ aMorph morphPosition.
	self addMorphFront: aMorph.
	aMorph morphPosition: positionInWorld! !
!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 12/14/2011 16:48' prior: 50364850!
                    setCompleter: anAutoCompleter position: aPoint 
	completer _ anAutoCompleter.
	self resetMenu.
	self openInWorld.
	self morphPositionInOwner: aPoint.! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/13/2011 19:44' prior: 50366715!
                  addToWorld: world near: box
	| goodLocation |
	goodLocation _ self bestPositionNear: box inWorld: world.
	world allMorphsDo:
		[:p | (p isMemberOf: ColorPickerMorph) ifTrue:
		[(p ~~ self and: [p owner notNil and: [p target == target]]) ifTrue:
			[(p selector == selector and: [p argument == argument])
				ifTrue: [^ p comeToFront  "uncover existing picker"]
				ifFalse: ["place second picker relative to first"
						goodLocation _ self bestPositionNear: p bounds inWorld: world]]]].
	world addMorphFront: self.
	self morphPositionInOwner: goodLocation.
	self redrawNeeded! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/13/2011 19:44' prior: 50366736!
       indicateColorUnderMouse
	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."

	| pt |
	self pickColorAt: (pt _ World activeHand morphPosition ).
	isModal ifTrue: [
		self world activeHand morphPositionInOwner: pt.
		self world displayWorldSafely; runStepMethods].
	^ selectedColor	! !
!ColorPickerMorph methodsFor: 'other' stamp: 'jmv 12/13/2011 19:45' prior: 50366752!
trackColorUnderMouse
	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."

	| pt |
	selectedColor _ originalColor.
	self trackColorAt: (pt _ World activeHand morphPosition ).
	isModal ifTrue: [
		self world activeHand morphPositionInOwner: pt.
		self world displayWorldSafely; runStepMethods.
		self modalBalloonHelpAtPoint: pt].
	^ selectedColor	! !
!ColorPickerMorph methodsFor: 'private' stamp: 'jmv 12/13/2011 19:44' prior: 50366777!
                            anchorAndRunModeless: aHand
	"If user clicks on the drag-dot of a modal picker,
	anchor it, and change to modeless operation."

	self initializeModal: false; originalColor: originalColor.  "reset as modeless"
	aHand flushEvents.  "Drop any events gathered during modal loop"
	aHand morphPositionInOwner: Sensor mousePoint; grabMorph: self.  "Slip into drag operation"
! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 4/10/2012 14:59' prior: 50363658!
            createAcceptButton
	"create the [accept] button"
	| result buttonColor theme |
	theme _ Theme current.
	theme useUniformColors
		ifTrue: [ buttonColor _ theme buttonColorFrom: theme defaultWindowColor ]
		ifFalse: [ buttonColor _ theme acceptButton].
	result _ PluggableButtonMorph new
		 model: self;
		 color: buttonColor;
		 label: 'Accept';
		 action: #acceptClicked.
	self addMorph: result.
	result bounds: (29@90 corner: 122@117).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 4/10/2012 14:59' prior: 50363670!
                              createCancelButton
	"create the [cancel] button"
	| result buttonColor theme |
	theme _ Theme current.
	theme useUniformColors
		ifTrue: [ buttonColor _ theme buttonColorFrom: theme defaultWindowColor ]
		ifFalse: [ buttonColor _ theme buttonColorFrom: theme cancelButton ].
	result _ PluggableButtonMorph new
		 model: self;
		 color: buttonColor;
		 label: 'Cancel';
		 action: #cancelClicked.
	self addMorph: result.
	result bounds: (149@90 corner: 242@117).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 22:52' prior: 16852848!
    createQueryTextMorph: queryString 
	"create the queryTextMorph"
	| result |
	result _ StringMorph new contents: queryString.
	result lock.
	self addMorph: result.
	result bounds: ( 30@7 corner: 269@22).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 22:52' prior: 16852858!
       createTextPaneExtent: answerExtent acceptBoolean: acceptBoolean
	"create the textPane"
	| result |
	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval.
	result extent: answerExtent.
	result borderWidth: 1; borderColor: Color lightGray.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	self addMorph: result.
	result bounds: (14@25 corner: 257@84).
	^ result! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 12/13/2011 21:12' prior: 50364929!
                          popUpFor: aMorph event: evt
	"This message is sent by morphs that explicitly request the halo on a button click. Note: anEvent is in aMorphs coordinate frame."

	| hand anEvent |
	self flag: #workAround.	"We should really have some event/hand here..."
	anEvent _ evt
				ifNil: [
					hand _ aMorph world activeHand.
					hand ifNil: [ hand _ aMorph world firstHand ]. 
					hand lastEvent ]
				ifNotNil: [
					hand _ evt hand.
					evt ].
	hand halo: self.
	hand world addMorphFront: self.
	self target: aMorph.
	positionOffset _ anEvent eventPosition - aMorph morphPosition.
	self startStepping! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/31/2011 00:15' prior: 50364992!
                      addHandle: handleSpec on: eventName send: selector to: recipient 
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint iconName colorToUse icon |
	aPoint := self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle bounds: (Rectangle center: aPoint extent: HandleSize asPoint).
	(iconName _ handleSpec iconSymbol) ifNotNil: [
			| form |
			form _ Icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon.
				icon morphPositionInOwner: 0@0 ]].
	handle 
		on: #mouseUp
		send: #endInteraction
		to: self.
	handle 
		on: eventName
		send: selector
		to: recipient.
	handle 
		setBalloonText: (target balloonHelpTextForHandle: handle).
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/13/2011 20:24' prior: 50368000!
                 addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w nameBackground |
	w _ self world ifNil: [ target world ].
	nameBackground _ RectangleMorph new
		borderWidth: 0;
		color: (Color lightBlue alpha: 0.9).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color magenta.
	self addMorph: nameBackground.
	self addMorph: nameMorph.
	namePosition _ outerRectangle bottomCenter - ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph morphPosition: (namePosition min: w viewBox bottomRight - nameMorph extent y + 5).
	nameBackground bounds: (nameMorph bounds outsetBy: 2).
	^nameMorph! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/13/2011 20:28' prior: 50365262!
     attachMorph: m
	"Position the center of the given morph under this hand, then grab it.
	This method is used to grab far away or newly created morphs."
	| delta |
	self releaseMouseFocus. "Break focus"
	self addMorphBack: m.
	delta _ m bounds extent // 2.
	m morphPosition: (self morphPosition - delta).
	m formerPosition: m morphPosition.
	targetOffset _ m morphPosition - self morphPosition.! !
!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 12/13/2011 20:29' prior: 50365440!
                        popUpForHand: aHand
	"Pop up the receiver as balloon help for the given hand"

	| xcess |
	(contents isNil or: [ contents isEmpty ]) ifTrue: [ ^self ].
	aHand world addMorphFront: self.
	self morphPosition: aHand morphPosition + (-6@20).
	xcess _ bounds right - aHand world bounds right.
	xcess > 0 ifTrue: [
		self morphPosition: self morphPosition - (xcess@0) ].
	aHand balloonHelp: self! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/14/2011 18:14' prior: 50368101!
                     adjustExtent
	"And reposition submorphs"
	| w p0 h y |
	"make all items wide, so selection indicator is wide too"
	w _ self desiredWidth.
	p0 _ bounds topLeft..
	y _ 0.
	self submorphsDo: [ :m |
		h _ m morphHeight.
		m bounds: (p0 + (0@y) extent: w@h).
		y _ y + h ].
	self extent: w@y! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 12/13/2011 20:30' prior: 50365566!
        contents: aString withMarkers: aBool inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	self contentString: nil.	"get rid of old"
	aBool ifFalse: [^super contents: aString].
	self removeAllMorphs.	"get rid of old markers if updating"
	self hasIcon ifTrue: [ self icon: nil ].
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	self contentString: aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker.
	marker morphPosition: bounds left @ (bounds top + 2).! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/13/2011 23:07' prior: 50365651!
                        popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem
	"Present this menu at the given point under control of the given hand."

	| delta tryToPlace selectedOffset |
	hand world startSteppingSubmorphsOf: self.
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition - self morphPosition.
	sourceItem owner owner addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self fullBounds amountToTranslateWithin: sourceItem world bounds.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPoint first value: false;
		value: rightOrLeftPoint last - (self width @ 0) value: false;
		value: rightOrLeftPoint first value: true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 12/13/2011 20:42' prior: 16887672!
      popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [:m | m isKindOf: UpdatingMenuItemMorph]) 
		do: [:m | m updateContents].
	aWorld addMorphFront: self.
	self 
		positionAt: aPoint
		relativeTo: (selectedItem ifNil: [self items first]).
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [hand newKeyboardFocus: self].
	evt := hand lastEvent.
	(evt isKeyboard or: [evt isMouse and: [evt anyButtonPressed not]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt]! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 12/13/2011 22:55' prior: 50365723!
displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m isKindOf: MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Color veryDarkGray.
		self addMorphBack: feedbackMorph lock.
		feedbackMorph morphPosition: self morphPosition - (0@20).
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self submorphs last delete.
		self removeProperty: #feedbackMorph ].
	matches size = 1 ifTrue: [
		self
			selectItem: matches first
			event: evt ].! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 12/13/2011 23:34' prior: 50365842!
  informUserAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	| w titleString |

	titleString _ titleMorph submorphs first.
	self visible: false.
	w _ ActiveWorld.
	aBlock value: [ :string |
		self visible ifFalse: [
			w addMorph: self centeredNear: aPoint.
			self visible: true].
		titleString contents: string.
		titleMorph morphWidth: titleString width + 8.
		self morphPosition: w activeHand morphPosition.
		self adjustSubmorphsLayout.
		self redrawNeeded.
		w displayWorld		 "show myself"
	]. 
	self delete.
	w displayWorld! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 12/13/2011 23:36' prior: 50365987!
                            placeEmbeddedObject: anchoredFormOrMorph

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	(anchoredFormOrMorph is: #Morph)
		ifTrue: [
			anchoredFormOrMorph morphPosition:
				((destX - anchoredFormOrMorph morphWidth)@
				(lineY+ line baseline - anchoredFormOrMorph morphHeight)) -
					paraTopLeft ]
		ifFalse: [
			destY _ lineY.
			runX _ destX.
			anchoredFormOrMorph 
				displayOn: canvas grafPort destForm 
				at: destX - anchoredFormOrMorph morphWidth @ (destY + line baseline - anchoredFormOrMorph morphHeight)
				clippingBox: canvas grafPort clipRect
				rule: Form blend
				fillColor: nil ].
	^ true! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 12/13/2011 22:53' prior: 50366201!
       addMorph: aMorph centeredNear: aPoint
	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."

	| trialRect delta |
	trialRect _ Rectangle center: aPoint extent: aMorph fullBounds extent.
	delta _ trialRect amountToTranslateWithin: bounds.
	self addMorph: aMorph.
	aMorph morphPosition: trialRect origin + delta.! !
!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 12/13/2011 23:56' prior: 50366227!
                      addToScroller: aMorph

	scroller addMorph: aMorph.
	aMorph morphPosition: scroller morphPosition! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/31/2011 00:18' prior: 16915261!
hHideScrollBar
	hScrollBar hide.
	scroller adjustExtent! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/31/2011 00:18' prior: 16915291!
         hShowScrollBar

	hScrollBar show.
	scroller adjustExtent! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/31/2011 00:19' prior: 16915367!
        vHideScrollBar
	scrollBar hide.
	scroller adjustExtent! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/31/2011 00:19' prior: 16915391!
          vShowScrollBar

	scrollBar show.
	scroller adjustExtent! !
!PolygonMorph methodsFor: 'editing' stamp: 'jmv 12/13/2011 23:58' prior: 50366489!
                  updateHandles
	| newVert oldVert midPts nextVertIx tweens |
	smoothCurve
		ifTrue: [
			handles first referencePosition: vertices first.
			handles last referencePosition: vertices last.
			midPts _ OrderedCollection new.
			nextVertIx _ 2.
			tweens _ OrderedCollection new.
			self
				lineSegmentsDo: [:p1 :p2 | 
					tweens addLast: p2 asIntegerPoint.
					p2 = (vertices atWrap: nextVertIx)
						ifTrue: ["Found endPoint."
							midPts addLast: (tweens at: tweens size // 2)
									+ (tweens at: tweens size + 1 // 2) // 2.
							tweens _ OrderedCollection new.
							nextVertIx _ nextVertIx + 1]].
			midPts withIndexDo: [:midPt :vertIndex |
				(closed or: [vertIndex < vertices size]) ifTrue: [
					newVert _ handles at: vertIndex * 2.
					newVert referencePosition: midPt ]]]
		ifFalse: [
			vertices
				withIndexDo: [ :vertPt :vertIndex | 
					oldVert _ handles at: vertIndex * 2 - 1.
					oldVert referencePosition: vertPt.
					(closed or: [vertIndex < vertices size])
						ifTrue: [
							newVert _ handles at: vertIndex * 2.
							newVert morphPosition: vertPt
									+ (vertices atWrap: vertIndex + 1) - newVert bounds extent // 2 + (1 @ -1)]]]! !
!ProgressMorph methodsFor: 'accessing' stamp: 'jmv 12/13/2011 23:20' prior: 16923490!
                label: aString subLabel: otherString
	labelMorph contents: aString.
	subLabelMorph contents: otherString! !
!ProgressMorph class methodsFor: 'example' stamp: 'jmv 12/13/2011 23:38' prior: 16923548!
                          example
	"
	ProgressMorph example
	"
	| progress |
	progress _ ProgressMorph label: 'Test progress' subLabel: 'this is the subheading'.
	progress openInWorld.
	[
		100 timesRepeat: [
			(Delay forMilliseconds: 20) wait.
			progress incrDone: 0.01 ].
		progress delete] fork! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 16965176!
                 createCloseBox
	^ (PluggableButtonMorph model: self action: #closeBoxHit)
		icon: Theme current closeIcon;
		setBalloonText: 'close this window'! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 16965184!
                  createCollapseBox
	^(PluggableButtonMorph model: self action: #collapseOrExpand)
		icon: Theme current collapseIcon;
		setBalloonText: 'collapse this window'! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 16965193!
     createExpandBox
	^ (PluggableButtonMorph model: self action: #expandBoxHit)
		icon: Theme current expandIcon;
		setBalloonText: 'expand to full screen'! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 16965201!
           createMenuBox
	^ (PluggableButtonMorph model: self action: #offerWindowMenu)
		icon: Theme current windowMenuIcon;
		setBalloonText: 'window menu'! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/14/2011 18:24' prior: 50366867!
                initializeLabelArea
	"Initialize the label area (titlebar) for the window."

	| spacing box |
	spacing _ self boxExtent x + 2.

	box _ self createCloseBox.
	self addMorph: box.
	box morphPosition: 2@2.
	box extent: self boxExtent.

	box _ self createCollapseBox.
	self addMorph: box.
	box morphPosition: spacing+2@2.
	box extent: self boxExtent.

	box _ self createExpandBox.
	self addMorph: box.
	box morphPosition: spacing*2+2@2.
	box extent: self boxExtent.

	box _ self createMenuBox.
	self addMorph: box.
	box morphPosition: spacing*3+2@2.
	box extent: self boxExtent.! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 12/13/2011 21:06' prior: 16965454!
         openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	aWorld addMorph: self.
	self bounds: (RealEstateAgent initialFrameFor: self world: aWorld).
	self activate.
	aWorld startSteppingSubmorphsOf: self.! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 12/13/2011 21:07' prior: 50366882!
                       openInWorld: aWorld extent: extent
	"This msg and its callees result in the window being activeOnlyOnTop"
	aWorld addMorph: self.
	self morphPosition: (RealEstateAgent initialFrameFor: self world: aWorld) topLeft; extent: extent.
	self activate.
	aWorld startSteppingSubmorphsOf: self.! !

SystemWindow removeSelector: #openAsIsIn:!

SystemWindow removeSelector: #openAsIsIn:!

ProgressMorph removeSelector: #setupMorphs!

ProgressMorph removeSelector: #setupMorphs!

MenuMorph removeSelector: #positionAt:relativeTo:inWorld:!

MenuMorph removeSelector: #positionAt:relativeTo:inWorld:!

InnerTextMorph removeSelector: #addMorphFront:fromWorldPosition:!

InnerTextMorph removeSelector: #addMorphFront:fromWorldPosition:!

Morph removeSelector: #addMorphFront:fromWorldPosition:!

Morph removeSelector: #addMorphFront:fromWorldPosition:!

Morph removeSelector: #privateBounds:!

Morph removeSelector: #privateBounds:!

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1292-FirstAddMorphThenPosition-jmv.5.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 3:14:11 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:43'!
        morphExtent
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^ bounds extent! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:43'!
                             morphExtent: aPoint
"assume it is always in owner's coordinates!!"
	self flag: #jmvVer2.
	self basicExtent: aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:31'!
             validateNotSent
	"To be removed. Just to check consistency"

	self flag: #jmvVer2.
	Count ifNil: [ Count _ 0 ].
	Count _ Count + 1.
	Count < 10 ifTrue: [
		'-----False polymorphism. Should not be sent!!-----' print.
		thisContext printStack: 10 ]! !
!ImageMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:21'!
    morphExtent: aPoint
	"Do nothing; my extent is determined by my image Form."
! !
!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:27'!
         morphExtent: aPoint
	| newExtent |
	"Resist changing the extent if no wordwrap.. this should be checked."
	wrapFlag ifFalse: [ ^ self ].
	newExtent _ aPoint truncated max: self minimumExtent.
	
	"No change of wrap width"
	newExtent x = bounds extent x ifTrue: [ ^ self ].

	super morphExtent: newExtent.
	
	self resetParagraph.
	self editor recomputeSelection.	
	self updateFromParagraph.! !
!MagnifierMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:32'!
                  morphExtent: aPoint
	"Round to multiples of magnification"
	srcExtent _ (aPoint - (2 * borderWidth)) // magnification.
	^super morphExtent: self defaultExtent! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:32'!
                          morphExtent: aPoint

	self flag: #jmvVer2.
	bounds extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self validatePositionAndBounds.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PluggableButtonMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28'!
   morphExtent: aPoint
	super morphExtent: aPoint.
	magnifiedIcon _ nil.
	self redrawNeeded! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28'!
                         morphExtent: newExtent
	
	| minH minW |
	"Figure out the minimum width and height for this pane so that scrollbars will appear"
	minH _ Preferences scrollbarThickness * 2.
	minW _ minH.
	super morphExtent: (newExtent max: (minW@minH)).

	"Now reset widget sizes"
	scroller adjustExtent.
	self updateScrollBarsBounds.
	self setScrollDeltas! !
!LimitedHeightTextMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:27'!
                            morphExtent: aPoint
	maxHeight _ aPoint y.
	super morphExtent: aPoint.! !
!PolygonMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:21'!
                  morphExtent: newExtent 
	"Not really advisable, but we can preserve most of the geometry if we don't
	shrink things too small."
	| safeExtent center |
	center _ self referencePosition.
	safeExtent _ newExtent max: 20@20.
	self setVertices: (vertices collect:
		[:p | p - center * (safeExtent asFloatPoint / (bounds extent max: 1@1)) + center])! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/10/2012 15:10'!
     morphExtent: newExtent
	| newExtentToUse |
	newExtent = bounds extent ifTrue: [^ self].
	newExtentToUse _ bounds isWide
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = bounds extent ifTrue: [^ self].
	super morphExtent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!Sonogram methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:22'!
  morphExtent: newExtent
	super image: (Form extent: newExtent depth: Display depth).
	lastX _ -1.
	columnForm _ Form extent: (32//image depth)@(image height) depth: image depth.
	pixValMap _ ((1 to: 256) collect:
			[:i | columnForm pixelValueFor: (Color gray: (256-i)/255.0)])
		as: Bitmap.
! !
!StringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:26'!
                     setWidth: width

	self morphExtent: width @ (font ifNil: [StrikeFont default]) height! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28'!
   morphExtent: aPoint 
	"Set the receiver's extent to value provided. Respect my minimumExtent."

	| newExtent |
	newExtent _ self isCollapsed
		ifTrue: [aPoint]
		ifFalse: [aPoint max: self minimumExtent].
	newExtent = bounds extent ifTrue: [^ self].

	isCollapsed
		ifTrue: [super morphExtent: newExtent x @ (self labelHeight + 2)]
		ifFalse: [super morphExtent: newExtent].
	isCollapsed
		ifTrue: [collapsedFrame _ bounds]
		ifFalse: [fullFrame _ bounds]! !
!TranscriptMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28'!
              morphExtent: aPoint
	super morphExtent: aPoint.
	(form isNil or: [ form extent ~= aPoint ]) ifTrue: [
		form _ Form extent: aPoint depth: Display depth ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:34' prior: 50367713!
                      bounds: newBounds
	| oldExtent newExtent |

	"remove senders and implementors"
	self flag: #jmvVer2.
		
	oldExtent _ bounds extent.
	newExtent _ newBounds extent.
	"Moving stuff around is most likely the most common operation.
	Optimize it"
	oldExtent = newExtent ifTrue: [
		^self morphPosition: newBounds topLeft ].
	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[
		"We're growing. First move then resize."
		self morphPosition: newBounds topLeft; morphExtent: newExtent.
	] ifFalse: [
		"We're shrinking. First resize then move."
		self morphExtent: newExtent; morphPosition: newBounds topLeft.
	].! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:43' prior: 50367736!
                     extent
"Needs to be turned into extentInOwner and extentInWorld"
"or better yet into morphExtent:, and assume it is always in owner's coordinates!!"
	self flag: #jmvVer2.
	self validateNotSent.
	^ bounds extent! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 14:57' prior: 50367746!
                             extent: aPoint
"Needs to be turned into extentInOwner: and extentInWorld:"
"or better yet into morphExtent:, and assume it is always in owner's coordinates!!"
"(when deleting, delete all inheritance!!)"
	self flag: #jmvVer2.
	self validateNotSent.
	self basicExtent: aPoint! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:38' prior: 50367767!
                              height
	self flag: #jmvVer2.
	"False polymorphism elimination: turn senders into morphHeight"
	self validateNotSent.
	^ bounds height! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:38' prior: 50367775!
          height: aNumber
	self flag: #jmvVer2.
	"False polymorphism elimination: turn senders into morphHeight:"
	self validateNotSent.
	self morphExtent: bounds width@aNumber asInteger.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:25' prior: 50367297!
                             morphHeight: aNumber

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self morphExtent: bounds width@aNumber asInteger.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:38' prior: 50367317!
 morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = bounds topLeft ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

	self validateOwnerNotNil.


"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:38' prior: 50367371!
                morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
"Quizas no un null change del todo... Es posible que bounds y position se desincronicen, al cambiar el owner (o cualquier owner en el medio). Todo esto es fulerote. espero sacarlo pronto!!"
		self privateFullMoveBy: newPositionInWorld - bounds topLeft.
		^ self ].		"Null change"


	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:25' prior: 50367461!
                         morphWidth: aNumber
"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self morphExtent: aNumber asInteger@bounds height.
! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:36' prior: 50367873!
  width

	self flag: #jmvVer2.
	"False polymorphism elimination: turn senders into morphWidth"
	self validateNotSent.
	^ bounds width! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 13:37' prior: 50367881!
            width: aNumber

	self flag: #jmvVer2.
	"False polymorphism elimination: turn senders into morphWidth:"
	self validateNotSent.
	self morphExtent: aNumber asInteger@bounds height! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 12/16/2011 10:25' prior: 16898966!
                           resizeMorph: evt 
	| handle |
	handle := HandleMorph new 
				forEachPointDo: [:newPoint | self morphExtent: newPoint - bounds topLeft].
	evt hand attachMorph: handle.
	handle startStepping! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:27' prior: 50368861!
                              createTextPaneExtent: answerExtent acceptBoolean: acceptBoolean
	"create the textPane"
	| result |
	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval.
	result morphExtent: answerExtent.
	result borderWidth: 1; borderColor: Color lightGray.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	self addMorph: result.
	result bounds: (14@25 corner: 257@84).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:23' prior: 16852887!
   initialize

	super initialize.
	self morphExtent: 271@121.
	responseUponCancel := ''
	! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:36' prior: 50368940!
                      addNameBeneath: outerRectangle string: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition w nameBackground |
	w _ self world ifNil: [ target world ].
	nameBackground _ RectangleMorph new
		borderWidth: 0;
		color: (Color lightBlue alpha: 0.9).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color magenta.
	self addMorph: nameBackground.
	self addMorph: nameMorph.
	namePosition _ outerRectangle bottomCenter - ((nameMorph morphWidth // 2) @ (self handleSize negated // 2 - 1)).
	nameMorph morphPosition: (namePosition min: w viewBox bottomRight - nameMorph morphExtent y + 5).
	nameBackground bounds: (nameMorph bounds outsetBy: 2).
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:41' prior: 50368040!
          doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target bounds topLeft.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target morphExtent: newExtent.
	growHandle morphPosition: evt eventPosition - (growHandle extent // 2).
	self someSubmorphPositionOrExtentChanged
! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:43' prior: 50368061!
                            doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Color lightBlue]
		ifFalse: [rotHandle color: Color blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPosition: evt eventPosition - (rotHandle morphExtent // 2).
	self someSubmorphPositionOrExtentChanged! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:44' prior: 16864328!
                         strokeGrow: evt with: growHandle
	| dir |
	evt keyValue = 28 ifTrue:[dir _ -1@0].
	evt keyValue = 29 ifTrue:[dir _ 1@0].
	evt keyValue = 30 ifTrue:[dir _ 0@-1].
	evt keyValue = 31 ifTrue:[dir _ 0@1].
	dir ifNil:[^self].
	evt hand obtainHalo: self.
	evt hand newKeyboardFocus: growHandle.
	target morphExtent: target morphExtent + dir.
	self someSubmorphPositionOrExtentChanged.! !
!HandleMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:23' prior: 16865798!
          initialize
	"initialize the state of the receiver"
	super initialize.
	self morphExtent: 12 @ 12! !
!HoverHelpMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:23' prior: 16867385!
     contents: aString
	contents _ aString.
	paragraph _ Paragraph new.
	paragraph
		setModel: (TextModel withText: contents asText);
		extentForComposing: 9999999@9999999.
	paragraph composeAll.
	self morphExtent: paragraph usedExtent + 8! !
!ImageMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:33' prior: 16867769!
extent: aPoint
	"Do nothing; my extent is determined by my image Form."

	self validateNotSent.! !
!InnerPluggableMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:24' prior: 16869736!
  adjustExtent

	self submorphBounds ifNotNil: [ :r |
		self morphExtent: r bottomRight - bounds topLeft ]! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:24' prior: 50368998!
                  adjustExtent
	"And reposition submorphs"
	| w p0 h y |
	"make all items wide, so selection indicator is wide too"
	w _ self desiredWidth.
	p0 _ bounds topLeft..
	y _ 0.
	self submorphsDo: [ :m |
		h _ m morphHeight.
		m bounds: (p0 + (0@y) extent: w@h).
		y _ y + h ].
	self morphExtent: w@y! !
!InnerListMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:24' prior: 16869701!
   adjustExtent
	"Adjust our height to match the underlying list,
	but make it wider if neccesary to fill the available width in our PluggableListMorph
	(this is needed to make the selection indicator no narrower than the list)"
	self morphExtent:
		self desiredWidth @ ((listItems size max: 1) * font height)
! !
!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:24' prior: 16870247!
                   adjustExtent
	"This is just a suggestion. If we do wordwrap, the width will be honored.
	But the height is whatever is appropriate for the contents!!"
	self morphExtent: owner viewableBounds extent! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:24' prior: 16870331!
  extentForComposing
	self flag: #jmvVer2.	"like #extent ..."
	^wrapFlag
		ifTrue: [ bounds width @ 9999999 ]
		ifFalse: [ 9999999@9999999 ]! !
!MagnifierMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:25' prior: 16885073!
                      initialize
	super initialize.
	trackPointer _ true.
	magnification _ 2.
	lastPos _ self sourcePoint.
	self morphExtent: 128@128! !
!MagnifierMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28' prior: 16885080!
       borderWidth: anInteger
	"Grow outwards preserving innerBounds"
	| c |  
	c _ self referencePosition.
	super borderWidth: anInteger.
	super morphExtent: self defaultExtent.
	self referencePosition: c.! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 12/16/2011 10:25' prior: 16885148!
   chooseMagnification
	| result |
	result _ (SelectionMenu selections: #(1.5 2 4 8))
		startUpWithCaption: 'Choose magnification
(currently ', magnification printString, ')'.
	(result == nil or: [ result = magnification ]) ifTrue: [ ^ self ].
	magnification _ result.
	self morphExtent: bounds extent. "round to new magnification"
	self redrawNeeded. "redraw even if extent wasn't changed"! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 12/16/2011 10:28' prior: 16885187!
 magnification: aNumber
	| c |  
	magnification _ aNumber min: 8 max: 0.5.
	magnification _ magnification roundTo:
		(magnification < 3 ifTrue: [0.5] ifFalse: [1]).
	srcExtent _ srcExtent min: (512@512) // magnification. "to prevent accidents"
	c _ self referencePosition.
	super morphExtent: self defaultExtent.
	self referencePosition: c.! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 10:25' prior: 50368293!
                         adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p tl |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: (
			(each respondsTo: #minItemWidth)
				ifTrue: [each minItemWidth]
				ifFalse: [each morphWidth])].

	w _ w + 4.
	tl _ bounds topLeft.
	p _ tl + 5.
	submorphs do: [ :m |
		m morphWidth: w.
		m morphPosition: p.
		p _ m bounds bottomLeft +(0@1) ].
	
	self morphExtent: submorphs last bounds bottomRight - tl + 5! !
!MinimalStringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:25' prior: 16894905!
           fitContents

	| newBounds boundsChanged |
	newBounds _ self measureContents.
	boundsChanged _ bounds extent ~= newBounds.
	self morphExtent: newBounds.		"default short-circuits if bounds not changed"
	boundsChanged ifFalse: [ self redrawNeeded ]! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:25' prior: 16906283!
            fitContents

	| newBounds boundsChanged |
	newBounds _ self measureContents.
	boundsChanged _ bounds extent ~= newBounds.
	self morphExtent: newBounds.		"default short-circuits if bounds not changed"
	boundsChanged ifFalse: [ self redrawNeeded ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:32' prior: 50368346!
                   extent: aPoint

	self validateNotSent.
	self flag: #jmvVer2.
	bounds extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self validatePositionAndBounds.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:25' prior: 16913734!
                           initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	getStateSelector _ nil.
	actionSelector _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	actWhen _ #buttonUp.
	self morphExtent: 20 @ 15! !
!PolygonMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:32' prior: 16916744!
                 extent: newExtent 
	"Not really advisable, but we can preserve most of the geometry if we don't
	shrink things too small."
	| safeExtent center |
	self validateNotSent.
	center _ self referencePosition.
	safeExtent _ newExtent max: 20@20.
	self setVertices: (vertices collect:
		[:p | p - center * (safeExtent asFloatPoint / (bounds extent max: 1@1)) + center])! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:39' prior: 16923517!
                        initialize
	super initialize.
	self separation: 0.
	labelMorph _ StringMorph contents: '' font: AbstractFont default.
	subLabelMorph _ StringMorph contents: '' font: AbstractFont default.
	progress_ ProgressBarMorph new.
	progress morphExtent: 200 @ 15.
	self addMorph: labelMorph.
	self addMorph: subLabelMorph.
	self addMorph: progress fixedHeight: 15.! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:33' prior: 50368463!
         expandSlider
	"Compute the new size of the slider (use the old sliderThickness as a minimum)."
	| r |
	r _ self totalSliderArea.
	slider morphExtent: (bounds isWide
		ifTrue: [((r width * interval) asInteger max: 7) @ slider morphHeight]
		ifFalse: [slider morphWidth @ ((r height * interval) asInteger max: 7)])! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/10/2012 15:11' prior: 16934926!
                    extent: newExtent
	| newExtentToUse |
	self validateNotSent.
	newExtent = bounds extent ifTrue: [^ self].
	newExtentToUse _ bounds isWide
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = bounds extent ifTrue: [^ self].
	super extent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!SketchMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:26' prior: 16939955!
                            initializeWith: aForm

	super initialize.
	originalForm _ aForm.
	self morphExtent: originalForm extent.
! !
!Sonogram methodsFor: 'all' stamp: 'jmv 12/16/2011 10:26' prior: 16947359!
        extent: extent minVal: min maxVal: max scrollDelta: d
	minVal _ min.
	maxVal _ max.
	scrollDelta _ d.
	self morphExtent: extent.

" try following with scrolldelta = 1, 20, 200
	| s data |
	s _ Sonogram new extent: 200@50
				minVal: 0.0 maxVal: 1.0 scrollDelta: 20.
	World addMorph: s.
	data _ (1 to: 133) collect: [:i | 0.0].
	1 to: 300 do:
		[:i | data at: (i\\133)+1 put: 1.0.
		s plotColumn: data.
		data at: (i\\133)+1 put: 0.0.
		World doOneCycleNow].
	s delete	
"! !
!Sonogram methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:33' prior: 16947407!
                      extent: newExtent
	self validateNotSent.
	super image: (Form extent: newExtent depth: Display depth).
	lastX _ -1.
	columnForm _ Form extent: (32//image depth)@(image height) depth: image depth.
	pixValMap _ ((1 to: 256) collect:
			[ :i | columnForm pixelValueFor: (Color gray: (256-i)/255.0)])
		as: Bitmap.
! !
!StringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 10:26' prior: 16957368!
                  fitContents

	| newBounds boundsChanged |
	newBounds _ self measureContents.
	boundsChanged _ bounds extent ~= newBounds.
	self morphExtent: newBounds.		"default short-circuits if bounds not changed"
	boundsChanged ifFalse: [self redrawNeeded]! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 12/16/2011 10:48' prior: 50366836!
                      makeMeVisible 

	self world morphExtent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self isCollapsed
		ifTrue: [ self morphPosition: (RealEstateAgent assignCollapsePointFor: self)]
		ifFalse: [ self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: bounds extent world: self world) topLeft].

! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:26' prior: 50368476!
                    initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	isCollapsed _ false.
	
	self wantsLabel ifTrue: [self initializeLabelArea].
	self morphExtent: 300 @ 200.
	updatablePanes _ #().

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorph: m ].

	"by default"
	self beColumn! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 12/16/2011 10:35' prior: 50369313!
                  initializeLabelArea
	"Initialize the label area (titlebar) for the window."

	| spacing box |
	spacing _ self boxExtent x + 2.

	box _ self createCloseBox.
	self addMorph: box.
	box morphPosition: 2@2.
	box morphExtent: self boxExtent.

	box _ self createCollapseBox.
	self addMorph: box.
	box morphPosition: spacing+2@2.
	box morphExtent: self boxExtent.

	box _ self createExpandBox.
	self addMorph: box.
	box morphPosition: spacing*2+2@2.
	box morphExtent: self boxExtent.

	box _ self createMenuBox.
	self addMorph: box.
	box morphPosition: spacing*3+2@2.
	box morphExtent: self boxExtent.! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 12/16/2011 10:41' prior: 50369345!
                     openInWorld: aWorld extent: extent
	"This msg and its callees result in the window being activeOnlyOnTop"
	aWorld addMorph: self.
	self morphPosition: (RealEstateAgent initialFrameFor: self world: aWorld) topLeft; morphExtent: extent.
	self activate.
	aWorld startSteppingSubmorphsOf: self.! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 12/16/2011 10:26' prior: 16969050!
                              buildMorphicWindow
	"TestRunner new openAsMorph"

	self layoutMorph
		addMorph: self buildUpperControls proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.75.
	self setLabel: 'SUnit Test Runner'.
	self refreshWindow.
	self morphExtent: 460 @ 400! !

FillInTheBlankMorph removeSelector: #morphExtent:!

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1293-extentFalsePolymorphism-jmv.4.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1255] on 10 April 2012 at 3:16:49 pm'!
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/16/2011 15:24' prior: 50364637!
                aboutToBeGrabbedBy: aHand
	"The receiver is being grabbed by a hand.
	Perform necessary adjustments (if any) and return the actual morph
	that should be added to the hand."

	^self "Grab me"! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/16/2011 15:23' prior: 16896895!
        justDroppedInto: aMorph event: anEvent 
	"This message is sent to a dropped morph after it has been dropped on -- and been accepted by -- a drop-sensitive morph"

	aMorph activateWindow.
	self isInWorld  ifTrue: [
		self world startSteppingSubmorphsOf: self ].
	"Note an unhappy inefficiency here:  the startStepping... call will often have already been called in the sequence leading up to entry to this method, but unfortunately the isPartsDonor: call often will not have already happened, with the result that the startStepping... call will not have resulted in the startage of the steppage."! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 12/16/2011 15:22' prior: 16896924!
                   rejectDropMorphEvent: evt
	"The receiver has been rejected, and must be put back somewhere. 
	Just keep it in the hand"

	^evt hand grabMorph: self! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/16/2011 14:58' prior: 16899514!
                removeAllMorphs
	| oldMorphs |
	submorphs isEmpty ifTrue: [ ^self ].
	self redrawNeeded.
	submorphs do: [ :m |
		m privateOwner: nil ].
	oldMorphs _ submorphs.
	submorphs _ #().
	oldMorphs do: [ :m |
		self removedMorph: m ].
	self someSubmorphPositionOrExtentChanged! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 12/16/2011 15:27' prior: 16899529!
                        removeAllMorphsIn: aCollection
	"greatly speeds up the removal of *lots* of submorphs"
	| set |
	aCollection isEmpty ifTrue: [ ^self ].
	set _ IdentitySet new: aCollection size * 4 // 3.
	aCollection do: [ :each | each owner == self ifTrue: [ set add: each ]].
	set isEmpty ifTrue: [ ^self ].
	self redrawNeeded.
	set do: [ :m | m privateOwner: nil ].
	submorphs _ submorphs reject: [ :each | set includes: each].
	set do: [ :m | self removedMorph: m ].
	self someSubmorphPositionOrExtentChanged! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/16/2011 15:24' prior: 50368966!
                   attachMorph: m
	"Position the center of the given morph under this hand, then grab it.
	This method is used to grab far away or newly created morphs."
	| delta |
	self releaseMouseFocus. "Break focus"
	self addMorphBack: m.
	delta _ m bounds extent // 2.
	m morphPosition: (self morphPosition - delta).
	targetOffset _ m morphPosition - self morphPosition.! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 12/16/2011 15:20' prior: 50365278!
                              dropMorph: aMorph event: anEvent
	"Drop the given morph which was carried by the hand"
	| event |
	(anEvent isMouseUp and:[aMorph shouldDropOnMouseUp not]) ifTrue: [ ^self ].
	event _ DropEvent new setPosition: self morphPosition contents: aMorph hand: self.
	self sendEvent: event.
	event wasHandled ifFalse: [ aMorph rejectDropMorphEvent: event ].
	self mouseOverHandler processMouseOver: anEvent! !
!MenuItemMorph methodsFor: 'grabbing' stamp: 'jmv 12/16/2011 15:24' prior: 16887044!
                         aboutToBeGrabbedBy: aHand
	"Don't allow the receiver to act outside a Menu"
	| menu box |
	(owner notNil and: [ owner submorphs size = 1]) ifTrue:[
		"I am a lonely menuitem already; just grab my owner"
		owner stayUp.
		^owner aboutToBeGrabbedBy: aHand ].
	box _ bounds.
	menu _ MenuMorph new defaultTarget: nil.
	menu addMorphFront: self.
	menu bounds: box.
	menu stayUp.
	self isSelected: false.
	^menu! !

Morph removeSelector: #formerOwner!

Morph removeSelector: #formerOwner!

Morph removeSelector: #formerOwner:!

Morph removeSelector: #formerOwner:!

Morph removeSelector: #formerPosition!

Morph removeSelector: #formerPosition!

Morph removeSelector: #formerPosition:!

Morph removeSelector: #formerPosition:!

Morph removeSelector: #slideBackToFormerSituation:!

Morph removeSelector: #slideBackToFormerSituation:!

Morph removeSelector: #vanishAfterSlidingTo:event:!

Morph removeSelector: #vanishAfterSlidingTo:event:!

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1294-Cleanup-jmv.3.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1261] on 10 April 2012 at 3:33:56 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:41'!
          validateExtentAndBounds
	"To be removed. Just to check consistency"
	| answer1 answer2 |
	self flag: #jmvVer2.

"	answer1 _ owner
		ifNotNil: [ owner externalizeDistanceToWorld: extent ]
		ifNil: [ extent ]."
	answer1 _ extent.
	answer2 _ bounds extent.

	answer1 = answer2 ifFalse: [
		#validateExtentAndBounds print.
		answer1 print.
		answer2 print.
		thisContext printStack: 10 ]! !
!Morph methodsFor: 'change reporting' stamp: 'jmv 12/16/2011 15:54' prior: 16896355!
        privateInvalidateMorph: aMorph
	"Private. Invalidate the given morph after adding or removing.
	This method is private because a) we're invalidating the morph 'remotely'
	and b) it forces a fullBounds computation which should not be necessary
	for a general morph c) the morph may or may not actually invalidate
	anything (if it's not in the world nothing will happen) and d) the entire
	mechanism should be rewritten."

	"Is this needed at all?"
	self flag: #jmvVer2.
	aMorph layoutSubmorphsAndComputeFullBounds.

	aMorph redrawNeeded! !
!Morph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 16:39' prior: 16896621!
                         drawErrorOn: aCanvas
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	w _ 10.
	r _ bounds truncated.
	aCanvas
		frameAndFillRectangle: r
		fillColor: Color red
		borderWidth: w
		borderColor: Color yellow.
	aCanvas line: r topLeft +w to: r bottomRight -w width: w color: Color yellow.
	aCanvas line: r topRight + (w negated @ w) to: r bottomLeft + (w @ w negated) width: w color: Color yellow.! !
!Morph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 16:51' prior: 16896670!
   fullDrawOn: aCanvas
	"Draw the full Morphic structure on the given Canvas"

	self visible ifFalse: [^ self].
	(aCanvas isVisible: self fullBounds) ifFalse:[^self].		"Needs fullBounds 'in owner' if inside a scroller"
	self isKnownFailing ifTrue: [^self drawErrorOn: aCanvas].

	"Draw receiver itself"
	(aCanvas isVisible: bounds) ifTrue: [
		aCanvas clipBy: bounds during: [ :c | self drawOn: c ]].	"Needs bounds 'in owner' if inside a scroller"
	self drawSubmorphsOn: aCanvas.
	self drawDropHighlightOn: aCanvas.
	self drawMouseDownHighlightOn: aCanvas! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:54' prior: 50367682!
       basicExtent: aPoint

	self flag: #jmvVer2.
	"Lo dejo un rato porque se llama dde initialize... De ultima, es un problema? Es cierto que no se la escala aun..."
	"
	self validateOwnerNotNil.
	"
	
	"ver senders. Es en owner's o en world's ???"
	
	
	self validateExtentAndBounds.
	extent = aPoint ifTrue: [^ self].
	self redrawNeeded.
	bounds _ bounds topLeft extent: aPoint.
	extent _ aPoint.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:45' prior: 50369382!
           morphExtent
"assume it is always in owner's coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	self validateExtentAndBounds.
	^ extent! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:50' prior: 50367291!
                     morphHeight

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self validateExtentAndBounds.
	^ extent y! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:47' prior: 50369607!
                   morphHeight: aNumber

"Ensure everybody wants owner's coordinates!!
Besides, #asInteger???"
	self flag: #jmvVer2.
	self morphExtent: self morphWidth@aNumber asInteger! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:42' prior: 50367304!
         morphPositionInOwner
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"

	self flag: #jmvVer2.
	self validateOwnerNotNil.
	self validatePositionAndBounds.
	self validateExtentAndBounds.

	^ position! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:42' prior: 50369614!
      morphPositionInOwner: newPositionInOwner
	"Change the position of this morph."
"Ojo aca. Ponemos position a nil pero es solo por el problema de bounds desenganchado de position..."
	| newPositionInWorld |
	self flag: #jmvVer2.

	newPositionInWorld _ owner
		ifNotNil: [ owner externalizeToWorld: newPositionInOwner ]
		ifNil: [ newPositionInOwner ].

	position = newPositionInOwner ifTrue: [
		newPositionInWorld = bounds topLeft ifFalse: [
			'---------feote2' print
		].
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

	self validateOwnerNotNil.


"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.
	self validateExtentAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:43' prior: 50367353!
              morphPositionInWorld
	| answer1 answer2 |
"
Cuando tenga resueltos los setters (o quizas al mismo tiempo),
ver que senders del getter quieren en realidad #zzpositionInOwner y quienes #zzpositionInWorld.
Espero que pocos hablen en coordenadas del world!!
"


	self flag: #jmvVer2.
	self validateOwnerNotNil.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	
	answer1 _ owner
		ifNotNil: [ owner externalizeToWorld: position ]
		ifNil: [ position ].
	answer2 _ bounds topLeft.
	{ answer1 . answer2 }.

	^answer2! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:43' prior: 50369647!
  morphPositionInWorld: newPositionInWorld
	"Change the position of this morph."
	"El tema es, que tipo de coordenadas tenemos?
	En un mundo relativista, no hay un marco de referencia absoluto.
	No tiene sentido hablar de coordenadas del mundo... El mundo podria estar escalado... 
		Que tienen de especial las coordenadas del mundo?
	Coordenadas 'del hardware'? No deberia saber mucho sobre el... Puede haber multiples displays, hands de diverso tipo, remotas, virtuales...
	
	En ppio, un par de coordenadas pueden ser relativas a cualquier morph. Pareciera que necesito metodos de conversion de cualquier morph hacia mi, y de mi hacia cualquier morph... Como encontrar un marco de referencia comun????
	Dejar esto para despues. En realidad, para empezar, preciso menos: Solo preciso saber si las coordenadas estan en el morph o en su owner. Nada mas. Los eventos se iran transformando apropiadamente al moverse por el arbol, o al menos, llevaran consigo una transformacion (MatrixTransform2x3) que se ira actualizando"

	| newPositionInOwner |
	self flag: #jmvVer2.
	self validateOwnerNotNil.

	newPositionInOwner _ owner
		ifNotNil: [ owner internalizeFromWorld: newPositionInWorld ]
		ifNil: [ newPositionInWorld ].


	position = newPositionInOwner ifTrue: [
		"Al menos en algunos casos esto pasa porque al poner owner, no reajustamos bounds...
		Es necesario hacer que los globales sigan a los locales (manteniendo locales, moviendo morph)
		o que las locales sigan a las globales (manteniendo posicion en el mundo... si es que estabamos en un mundo!!)"
		self flag: #jmvVer2.
		newPositionInWorld - bounds topLeft = (0@0) ifFalse: [
			'-----feote' print.
			newPositionInWorld print.
			bounds print.
			position print.
			self print.
			owner print.
			owner morphPosition print.
			'--' print.
		].
"Quizas no un null change del todo... Es posible que bounds y position se desincronicen, al cambiar el owner (o cualquier owner en el medio). Todo esto es fulerote. espero sacarlo pronto!!"
		self privateFullMoveBy: newPositionInWorld - bounds topLeft.
		^ self ].		"Null change"

	"May need to compute fullBounds, but I see no reason to layout submorphs!!"
	self flag: #jmvVer2.
	self layoutSubmorphsAndComputeFullBounds; redrawNeeded.

"This won't be needed once we remove the bounds ivar in global coordinates!!
With this, we also delete implementors of #privateFullMoveBy: and #privateMoveBy: "
self privateFullMoveBy: newPositionInWorld - bounds topLeft.

	position _ newPositionInOwner.
	self validatePositionAndBounds.
	self validateExtentAndBounds.

	self redrawNeeded.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:48' prior: 50367455!
                        morphWidth

"Ensure everybody wants owner's coordinates!!"
	self flag: #jmvVer2.
	self validateExtentAndBounds.
	^ extent x! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:49' prior: 50369729!
                    morphWidth: aNumber

"Ensure everybody wants owner's coordinates!!
Besides, #asInteger???"
	self flag: #jmvVer2.
	self morphExtent: aNumber asInteger@self morphHeight! !
!Morph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 16:36' prior: 50369396!
         validateNotSent
	"To be removed. Just to check consistency"

	self flag: #jmvVer2.
"	Count ifNil: [ Count _ 0 ].
	Count _ Count + 1.
	Count < 10 ifTrue: ["
		'-----False polymorphism. Should not be sent!!-----' print.
		thisContext printStack: 10 
	"]"! !
!Morph methodsFor: 'geometry testing' stamp: 'jmv 12/16/2011 16:30' prior: 16897947!
           fullContainsPoint: aPoint
"
	This alternative implementation is included in this comment because it could be useful someday.
	If we start to rely heavily on the use of #ownShadowForm in #containsPoint, this could be cheaper.
	
	| shadow |
	self clipSubmorphs
		ifTrue: [ ^self containsPoint: aPoint ]
		ifFalse: [
			(self fullBounds containsPoint: aPoint) ifFalse: [^ false].
			(self containsPoint: aPoint) ifTrue: [^ true].
			shadow _ self shadowForm.
			^(shadow pixelValueAt: aPoint - shadow offset) > 0 ]
"
	
	self flag: #jmvVer2.
	"Is the comment relevant now?"
	
	(self fullBounds containsPoint: aPoint) ifFalse: [ ^ false ].  "quick elimination"
	(self containsPoint: aPoint) ifTrue: [ ^ true ].  "quick acceptance"
	submorphs do: [:m | (m fullContainsPoint: aPoint) ifTrue: [ ^ true ]].
	^ false
! !
!Morph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 16:42' prior: 50367916!
  initialize
	"initialize the state of the receiver"

	owner _ nil.
	submorphs _ #().
	
	self flag: #jmvVer2.
	"Ir convirtiendo todos los usos (no las asignaciones!!) a las vars nuevas.
	Despues eliminar las asignaciones y las propias ivars (bounds y fullBounds)"
	bounds _ self defaultBounds.

	position _ bounds topLeft.
	extent _ bounds extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	color _ self defaultColor! !
!Morph methodsFor: 'layout' stamp: 'jmv 12/16/2011 15:56' prior: 16898429!
                             computeFullBounds
	"Private. Compute the actual full bounds of the receiver"

	"Remove when removing fullBounds"
	self flag: #jmvVer2.

	(submorphs isEmpty or: [ self clipsSubmorphs ]) ifTrue: [ ^bounds ].
	^ bounds quickMerge: self submorphBounds! !
!Morph methodsFor: 'layout' stamp: 'jmv 12/16/2011 15:56' prior: 16898456!
                          layoutSubmorphsAndComputeFullBounds
	"Return self. Recompute the layout if necessary."

	"Check senders. Many many not be needed. Others might be just to compute fullBounds, that we hope to elliminate!! Keep those that really need layout. of submorphs"
	self flag: #jmvVer2.

	fullBounds ifNotNil: [ ^self ].

	"Errors at this point can be critical so make sure we catch 'em all right"
	[
		self layoutSubmorphs.
		fullBounds _ self computeFullBounds.
	] on: Exception do: [ :ex |
		"This should do it unless you don't screw up the bounds"
		fullBounds _ bounds.
		ex pass ]! !
!Morph methodsFor: 'layout' stamp: 'jmv 12/16/2011 16:31' prior: 16898480!
                   submorphBounds
	"Private. Compute the actual full bounds of the receiver"

	"Remove when removing fullBounds? Reimplement?"
	self flag: #jmvVer2.

	^submorphs inject: nil into: [ :prevBox :m |
		m visible
			ifTrue: [ m fullBounds quickMerge: prevBox ]
			ifFalse: [ prevBox ] ]! !
!Morph methodsFor: 'updating' stamp: 'jmv 12/16/2011 16:00' prior: 16899672!
                         redrawNeeded
	"Report that the area occupied by this morph should be redrawn."

	self flag: #jmvVer2.
	"Invalidate the appropriate display rectangle... Just ours, or include submorphs if we don't clip.
	Think about it. We don't to know about a specific rectangle... How do we notify our 'observers' (i.e. the possible canvases we end drawn upon)?"
	
	"This method is the only real use of ivar fullBounds, other than senders of #fullBounds"

	self invalidRect: (fullBounds ifNil: [ bounds ])! !
!Morph methodsFor: 'private' stamp: 'jmv 12/16/2011 17:07' prior: 50367955!
      privateOwner: aMorph
	"Private!! Should only be used by methods that maintain the ower/submorph invariant."

	| oldGlobalPosition prevOwner |
	self flag: #jmvVer2.
	"
	(aMorph notNil and: [
		bounds origin ~= self defaultBounds origin ]) ifTrue: [
			'                                ---------------- Nos mandan #privateOwner: , pero nos han mandado bounds antes (no necesariamente un problema!!!!!!!!!!)!!' print.
			thisContext printStack: 10 ].
	"

	self validatePositionAndBounds.
	self validateExtentAndBounds.
			
	self flag: #jmvVer2.
	"Is this the best behavior???"
	prevOwner _ owner.
	prevOwner
		ifNotNil: [
			"Had an owner. Maintain my global position..."
			oldGlobalPosition _ self morphPositionInWorld ].
	owner _ aMorph.
	owner
		ifNil: [
			"Won't have any owner. Keep local position, as it will be maintained in my new owner later"
			bounds _ position extent: extent.
			fullBounds _ nil.
			self validatePositionAndBounds.
			self validateExtentAndBounds.
			]
		ifNotNil: [
			prevOwner
				ifNil: [
					"Didn't have any owner. Assume my local position is to be maintained in my new owner"
					bounds _ (owner externalizeToWorld: position) extent: extent.
					fullBounds _ nil.
					self validatePositionAndBounds.
					self validateExtentAndBounds.
					]
				ifNotNil: [
					"Had an owner. Maintain my global position..."
					position _ owner internalizeFromWorld: oldGlobalPosition.
					self flag: #jmvVer2.
					"extent _ owner internalizeDistanceFromWorld: oldGlobalExtent" 	"or something like this!!"
					self validatePositionAndBounds.
					self validateExtentAndBounds.
					]]! !
!HaloHandleMorph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 17:09' prior: 16863547!
                        drawOn: aCanvas
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	aCanvas
		image: (self class circleForm: extent)
		multipliedBy: (color alpha: 0.57)
		at: bounds topLeft.! !
!HaloMorph methodsFor: 'stepping' stamp: 'jmv 12/16/2011 17:08' prior: 50364976!
                step
	| newBounds |
	target
		ifNil: [^ self].
	newBounds _ target isWorldMorph
				ifTrue: [target bounds]
				ifFalse: [target worldBoundsForHalo truncated].
	newBounds = bounds
		ifTrue: [^ self].
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newBounds extent = extent
		ifTrue: [^ self morphPosition: newBounds origin].
	growingOrRotating ifFalse: [
		submorphs size > 1
			ifTrue: [self addHandles]].
	"adjust halo bounds if appropriate"
	self bounds: newBounds! !
!HaloMorph methodsFor: 'updating' stamp: 'jmv 12/16/2011 17:09' prior: 16863947!
      redrawNeeded
	"Quicker to invalidate handles individually if target is large (especially the world)"

	self validatePositionAndBounds.
	self validateExtentAndBounds.
	extent > (200@200)
		ifTrue: [(target notNil and: [target ~~ self world]) ifTrue: [
					"Invalidate 4 outer strips first, thus subsuming separate damage."
					(self fullBounds areasOutside: target bounds) do:
						[ :r | self invalidRect: r ]].
				self submorphsDo: [:m | m redrawNeeded]]
		ifFalse: [ super redrawNeeded ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 17:09' prior: 50369812!
                               doGrow: evt with: growHandle
	"Called while the mouse is down in the grow handle"

	| newExtent |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
"Como podria andar el grow de un morph embebido en otro? andara ahora?"
newExtent _ evt eventPosition - positionOffset - target bounds topLeft.
	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].
	(newExtent x = 0 or: [newExtent y = 0]) ifTrue: [^ self].
	target morphExtent: newExtent.
	growHandle morphPosition: evt eventPosition - (growHandle morphExtent // 2).
	self someSubmorphPositionOrExtentChanged
! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 16:42' prior: 50368088!
                initialize
	super initialize.
	self initForEvents.
	keyboardFocus _ nil.
	mouseFocus _ nil.
	bounds _ 0@0 extent: CursorWithMask normal extent.
	position _ 0@0.
	extent _ CursorWithMask normal extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	damageRecorder _ DamageRecorder new.
	self initForEvents.! !
!ImageMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 17:11' prior: 16867738!
      borderWidth: bw
	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent _ 2 * bw + image extent.
	extent = newExtent ifFalse: [
		self basicExtent: newExtent ]! !
!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 17:11' prior: 50369411!
     morphExtent: aPoint
	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	"Resist changing the extent if no wordwrap.. this should be checked."
	wrapFlag ifFalse: [ ^ self ].
	newExtent _ aPoint truncated max: self minimumExtent.
	
	"No change of wrap width"
	newExtent x = extent x ifTrue: [ ^ self ].

	super morphExtent: newExtent.
	
	self resetParagraph.
	self editor recomputeSelection.	
	self updateFromParagraph.! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 17:11' prior: 16870337!
          fit
	"Adjust my bounds to fit the text.
	Required after the text changes,
	or if wrapFlag is true and the user attempts to change the extent."

	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent _ (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).
	extent = newExtent ifFalse: [
		self basicExtent: newExtent.
		self redrawNeeded.	"Too conservative: only paragraph composition
								should cause invalidation."
		].

	owner innerHeight: newExtent y! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 12/16/2011 17:00' prior: 50369963!
              chooseMagnification
	| result |
	result _ (SelectionMenu selections: #(1.5 2 4 8))
		startUpWithCaption: 'Choose magnification
(currently ', magnification printString, ')'.
	(result == nil or: [ result = magnification ]) ifTrue: [ ^ self ].
	magnification _ result.
	self morphExtent: extent. "round to new magnification"
	self redrawNeeded. "redraw even if extent wasn't changed"! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 12/16/2011 16:42' prior: 50368284!
         initialize
	super initialize.
	bounds _ 0@0 corner: 40@10.
	position _ 0@0.
	extent _ 40@10.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil
! !
!MinimalStringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 17:00' prior: 50370015!
                      fitContents

	| newExtent |
	newExtent _ self measureContents.
	self validateExtentAndBounds.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 17:11' prior: 50370026!
                fitContents

	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent _ self measureContents.
	self validateExtentAndBounds.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 17:10' prior: 50369434!
                       morphExtent: aPoint

	self flag: #jmvVer2.
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	extent = aPoint ifFalse: [
		self redrawNeeded.
		bounds _ bounds topLeft extent: aPoint.
		extent _ aPoint.
		self validatePositionAndBounds.
		self validateExtentAndBounds.
		self buildMagnifiedBackgroundImage.
		self someSubmorphPositionOrExtentChanged.
		self redrawNeeded ].

	worldState ifNotNil: [
		worldState viewBox ifNotNil: [
			worldState viewBox = bounds ifFalse: [
				worldState canvas: nil.
				worldState viewBox: bounds ]]]! !
!PasteUpMorph methodsFor: 'misc' stamp: 'jmv 12/16/2011 17:10' prior: 16911938!
      buildMagnifiedBackgroundImage
	| image old |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	old _ backgroundImage.
	backgroundImageData
		ifNil: [ backgroundImage _ nil ]
		ifNotNil: [ 
			image _ Form fromBinaryStream: backgroundImageData readStream.
			backgroundImage _ image magnifyTo: extent.
			self canvas ifNotNil: [ :c |
				(backgroundImage depth = 32 and: [ c depth < 32 ]) ifTrue: [
					backgroundImage _ backgroundImage orderedDither32To16 ]]
		].
	old == backgroundImage ifFalse: [
		self redrawNeeded ]! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 12/16/2011 16:43' prior: 50368364!
           viewBox: newViewBox
	self flag: #jmvVer2.
	self isWorldMorph ifTrue: [
		(self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ])
			ifTrue: [ worldState canvas: nil ].
		worldState viewBox: newViewBox ].
"	super morphPosition: newViewBox topLeft."
	fullBounds _ bounds _ newViewBox.
	position _ owner
		ifNil: [ bounds topLeft ]
		ifNotNil: [ owner internalizeFromWorld: bounds topLeft ].
	extent _ bounds extent.
	self validatePositionAndBounds.
	self validateExtentAndBounds.! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 12/16/2011 15:45' prior: 16912487!
                          restoreMorphicDisplay
	DisplayScreen startUp.
	self
		morphExtent: Display extent;
		viewBox: Display boundingBox;
		handsDo: [ :h | h visible: true ];
		fullRepaintNeeded.
	WorldState addDeferredUIMessage: [ Cursor normal show ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 1/3/2012 16:22' prior: 50363696!
                              draw3DLookOn: aCanvas

	| w f center x y borderStyleSymbol c availableW l labelMargin |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: bounds
		colorOrInfiniteForm: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol.

	f _ self fontToUse.
	center _ bounds center.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ bounds width-labelMargin-labelMargin-1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ bounds left + labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 17:03' prior: 16913532!
  drawEmbossedLabelOn: aCanvas

	| availableW center colorForLabel f l labelMargin targetSize w x y |
	label ifNotNil: [
		colorForLabel _ Theme current buttonLabel.
		self isPressed
			ifFalse: [
				self mouseIsOver
					ifFalse: [ colorForLabel _ colorForLabel adjustSaturation: -0.10 brightness: 0.10 ]]
			ifTrue: [ colorForLabel _ colorForLabel adjustSaturation: 0.0 brightness: -0.07 ].
		f _ self fontToUse.
		center _ bounds center.
		labelMargin _ 3.
		w _ f widthOfString: label.
		availableW _ bounds width-labelMargin-labelMargin.
		availableW >= w
			ifTrue: [
				l _ label ]
			ifFalse: [
				x _ bounds left + labelMargin.
				targetSize _ label size * availableW // w.
				l _ label squeezedTo: targetSize.
				(f widthOfString: l) > availableW ifTrue: [
					targetSize _ targetSize - 1.
					l _ label squeezedTo: targetSize ]].
		
		w _ f widthOfString: l.
		x _ center x - (w // 2).
		y _ center y - (f height // 2).
		aCanvas
			drawStringEmbossed: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: colorForLabel ]! !
!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 17:03' prior: 16913780!
                               magnifiedIcon
	| b |
	magnifiedIcon ifNil: [
		magnifiedIcon _ icon.
		self isRoundButton
			ifFalse: [ ^ magnifiedIcon ].
		b _ extent x max: extent y.
		b < icon extent x ifTrue: [
			magnifiedIcon _ icon magnifyTo: b@b ].
		b /  icon extent x > 1.7
			ifTrue: [	
				b _ b * 3 // 4.
				magnifiedIcon _ icon magnifyTo: b @ b]].
	^magnifiedIcon! !
!PolygonMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 17:09' prior: 50369476!
              morphExtent: newExtent 
	"Not really advisable, but we can preserve most of the geometry if we don't
	shrink things too small."
	| safeExtent center |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	center _ self referencePosition.
	safeExtent _ newExtent max: 20@20.
	self setVertices: (vertices collect:
		[:p | p - center * (safeExtent asFloatPoint / (extent max: 1@1)) + center])! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 12/16/2011 16:43' prior: 50368433!
                         computeBounds
	| oldBounds delta excludeHandles |

	self flag: #jmvVer2.
	vertices ifNil: [^ self].

	self redrawNeeded.
	oldBounds _ bounds.
	self releaseCachedState.
	bounds _ self curveBounds truncated.
	self arrowForms do: [ :f |
		bounds _ bounds merge: (f offset extent: f extent)].
	handles ifNotNil: [ self updateHandles ].

	"since we are directly updating bounds, see if any ordinary submorphs exist and move them accordingly"
	(oldBounds notNil and: [(delta _ bounds origin - oldBounds origin) ~= (0@0)]) ifTrue: [
		excludeHandles _ IdentitySet new.
		handles ifNotNil: [excludeHandles addAll: handles].
		self submorphsDo: [ :each |
			(excludeHandles includes: each) ifFalse: [
				each morphPosition: each morphPosition + delta ] ] ].
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded.! !
!PolygonMorph methodsFor: 'private' stamp: 'jmv 4/10/2012 15:31' prior: 16917386!
                              filledForm
	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."
	| bb origin |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	closed ifFalse: [^ filledForm _ nil].
	filledForm ifNotNil: [^ filledForm].
	filledForm _ ColorForm extent: extent+2.

	"Draw the border..."
	bb _ (BitBlt current toForm: filledForm) sourceForm: nil; fillColor: Color black;
			combinationRule: Form over; width: 1; height: 1.
	origin _ bounds topLeft asIntegerPoint-1.
	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin
										to: p2 asIntegerPoint-origin].

	"Fill it in..."
	filledForm _ ColorForm mappingWhiteToTransparentFrom: filledForm anyShapeFill.

	borderColor mightBeTranslucent ifTrue: [
		"If border is stored as a form, then erase any overlap now."
		filledForm
			copy: self borderForm boundingBox
			from: self borderForm
			to: 1@1
			rule: Form erase ].

	^ filledForm! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/10/2012 15:31' prior: 50369489!
                      morphExtent: newExtent

	| newExtentToUse |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent = extent ifTrue: [^ self].
	newExtentToUse _ bounds isWide
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = extent ifTrue: [^ self].
	super morphExtent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!StringMorph methodsFor: 'accessing' stamp: 'jmv 12/16/2011 16:56' prior: 50370166!
                           fitContents

	| newExtent |
	newExtent _ self measureContents.
	self validateExtentAndBounds.
	extent = newExtent ifFalse: [
		self morphExtent: newExtent.
		self redrawNeeded ]! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 12/16/2011 17:04' prior: 50370177!
                        makeMeVisible 

	self world morphExtent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self isCollapsed
		ifTrue: [ self morphPosition: (RealEstateAgent assignCollapsePointFor: self)]
		ifFalse: [ self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: extent world: self world) topLeft].

! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 12/16/2011 17:04' prior: 50369521!
 morphExtent: aPoint 
	"Set the receiver's extent to value provided. Respect my minimumExtent."

	| newExtent |
	newExtent _ self isCollapsed
		ifTrue: [aPoint]
		ifFalse: [aPoint max: self minimumExtent].
	newExtent = extent ifTrue: [^ self].

	isCollapsed
		ifTrue: [super morphExtent: newExtent x @ (self labelHeight + 2)]
		ifFalse: [super morphExtent: newExtent].
	isCollapsed
		ifTrue: [collapsedFrame _ bounds]
		ifFalse: [fullFrame _ bounds]! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 12/16/2011 15:50' prior: 16965787!
          layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| bl br h thickness tl tr w cornerExtent |
	thickness _ 4.
	cornerExtent _ 20.
	tl _ bounds topLeft.
	tr _ bounds topRight.
	bl _ bounds bottomLeft.
	br _ bounds bottomRight.
	w _ bounds width - cornerExtent - cornerExtent.
	h _ bounds height - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) bounds: (tl + (cornerExtent@0) extent: w@thickness).
	(adjusters at: #bottomAdjuster) bounds: (bl+ (cornerExtent @ thickness negated) extent: w@thickness).
	(adjusters at: #leftAdjuster) bounds: (tl+ (0@cornerExtent) extent: thickness@h).
	(adjusters at: #rightAdjuster) bounds: (tr + (thickness negated@ cornerExtent) extent: thickness@h).
	(adjusters at: #topLeftAdjuster) bounds: (tl extent: cornerExtent@cornerExtent).
	(adjusters at: #bottomLeftAdjuster) bounds: (bl-(0@cornerExtent) extent: cornerExtent@cornerExtent).
	(adjusters at: #topRightAdjuster) bounds: (tr+(cornerExtent negated@0) extent: cornerExtent@cornerExtent).
	(adjusters at: #bottomRightAdjuster) bounds: (br-cornerExtent extent: cornerExtent@cornerExtent).

	layoutMorph ifNotNil: [
		layoutMorph bounds: self layoutBounds ]! !
!TranscriptMorph methodsFor: 'drawing' stamp: 'jmv 12/16/2011 17:10' prior: 16978408!
                              drawOn: aCanvas
	"
	Transcript
		showOnDisplay: true;
		bounds: bounds;
		displayOn: aCanvas form.
	"
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	Transcript
		showOnDisplay: true;
		bounds: (0@0 extent: extent);
		displayOn: form;
		bounds: bounds.
	aCanvas image: form at: bounds origin! !

TranscriptMorph removeSelector: #extent:!

TranscriptMorph removeSelector: #extent:!

SystemWindow removeSelector: #extent:!

SystemWindow removeSelector: #extent:!

Sonogram removeSelector: #extent:!

Sonogram removeSelector: #extent:!

ScrollBar removeSelector: #extent:!

ScrollBar removeSelector: #extent:!

PolygonMorph removeSelector: #extent:!

PolygonMorph removeSelector: #extent:!

LimitedHeightTextMorph removeSelector: #extent:!

LimitedHeightTextMorph removeSelector: #extent:!

PluggableScrollPane removeSelector: #extent:!

PluggableScrollPane removeSelector: #extent:!

PluggableButtonMorph removeSelector: #extent:!

PluggableButtonMorph removeSelector: #extent:!

PasteUpMorph removeSelector: #extent:!

PasteUpMorph removeSelector: #extent:!

MagnifierMorph removeSelector: #extent:!

MagnifierMorph removeSelector: #extent:!

InnerTextMorph removeSelector: #extent:!

InnerTextMorph removeSelector: #extent:!

ImageMorph removeSelector: #extent:!

ImageMorph removeSelector: #extent:!

Morph removeSelector: #extent!

Morph removeSelector: #extent!

Morph removeSelector: #extent:!

Morph removeSelector: #extent:!

Morph removeSelector: #height!

Morph removeSelector: #height!

Morph removeSelector: #height:!

Morph removeSelector: #height:!

Morph removeSelector: #width!

Morph removeSelector: #width!

Morph removeSelector: #width:!

Morph removeSelector: #width:!

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1295-StartUsingNewIvars-jmv.4.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1261] on 10 April 2012 at 3:48:51 pm'!
!CodeProvider methodsFor: 'categories' stamp: 'jmv 1/2/2012 14:32' prior: 16813859!
     methodCategoryChanged
	self triggerEvent: #annotationChanged! !
!CodeProvider methodsFor: 'contents' stamp: 'jmv 1/2/2012 14:31' prior: 16813872!
              acceptedContentsChanged

	self changed: #acceptedContents.
	self changed: #decorateButtons.
	self triggerEvent: #annotationChanged! !
!Browser methodsFor: 'accessing' stamp: 'jmv 1/2/2012 14:31' prior: 16793751!
            contents: input notifying: aController
	"The retrieved information has changed and its source must now be
	 updated. The information can be a variety of things, depending on
	 the list selections (such as templates for class or message definition,
	 methods) or the user menu commands (such as definition, comment,
	 hierarchy).  Answer the result of updating the source."

	| aString aText theClass |
	aString _ input asString.
	aText _ input asText.
	editSelection == #editSystemCategories ifTrue: [ ^ self changeSystemCategories: aString ].
	editSelection == #editClass | (editSelection == #newClass) ifTrue: [ ^ self defineClass: aString notifying: aController ].
	editSelection == #editComment
		ifTrue: [
			theClass _ self selectedClass.
			theClass
				ifNil: [
					self inform: 'You must select a class
before giving it a comment.'.
					^ false].
			theClass comment: aText stamp: Utilities changeStamp.
			self changed: #classCommentText.
			^ true].
	editSelection == #hierarchy ifTrue: [ ^ true ].
	editSelection == #editMessageCategories ifTrue: [ ^ self changeMessageCategories: aString ].
	editSelection == #editMessage | (editSelection == #newMessage)
		ifTrue: [
			^ self okayToAccept
				ifFalse:[ false ]
				ifTrue: [
					(self compileMessage: aText notifying: aController)
						ifTrue: [ self triggerEvent: #annotationChanged ];
						yourself ]].
	editSelection == #none
		ifTrue: [
			self inform: 'This text cannot be accepted
in this part of the browser.'.
			^ false].
	self error: 'unacceptable accept'! !
!Browser methodsFor: 'initialize-release' stamp: 'jmv 1/2/2012 14:32' prior: 16794358!
       methodCategoryChanged
	self changed: #messageCategoryList.
	self changed: #messageList.
	self triggerEvent: #annotationChanged.
	self messageListIndex: 0! !
!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 1/4/2012 19:01' prior: 16861541!
   buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	"

	| resizeFactor outerBox arrowMorph resizedForm f |
	resizeFactor _ 4.
	outerBox _ RectangleMorph new.
	outerBox
		extent: finalSizeInteger asPoint * resizeFactor;
		borderWidth: 0;
		color: Color transparent.
	
	arrowMorph _ self buildArrowIn: outerBox bounds.
	outerBox addMorphFront: arrowMorph.
	arrowMorph morphPosition: outerBox bounds center - (arrowMorph morphExtent // 2).
	
	f _ outerBox imageForm: 32.
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotateBy: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotateBy: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotateBy:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !
!MessageSet methodsFor: 'message functions' stamp: 'jmv 1/2/2012 14:33' prior: 16890744!
                   methodCategoryChanged
	self triggerEvent: #annotationChanged! !
!MessageSet methodsFor: 'private' stamp: 'jmv 1/2/2012 14:34' prior: 16890886!
                 contents: aString notifying: aController 
	"Compile the code in aString. Notify aController of any syntax errors. 
	Answer false if the compilation fails. Otherwise, if the compilation 
	created a new method, deselect the current selection. Then answer true."

	| category selector class oldSelector |
	self okayToAccept ifFalse: [^ false].
	self setClassAndSelectorIn: [:c :os | class _ c.  oldSelector _ os].
	class ifNil: [^ false].
	(oldSelector notNil and: [oldSelector first isUppercase]) ifTrue:
		[oldSelector == #Comment ifTrue:
			[class comment: aString stamp: Utilities changeStamp.
			self triggerEvent: #annotationChanged.
 			self changed: #clearUserEdits.
			^ false].
		oldSelector == #Definition ifTrue:
			["self defineClass: aString notifying: aController."
			class subclassDefinerClass
				evaluate: aString
				notifying: aController
				logged: true.
			self changed: #clearUserEdits.
 			^ false].
		oldSelector == #Hierarchy ifTrue:
			[self inform: 'To change the hierarchy, edit the class definitions'. 
			^ false]].
	"Normal method accept"
	category _ class organization categoryOfElement: oldSelector.
	selector _ class compile: aString
				classified: category
				notifying: aController.
	selector
		ifNil: [^ false].
	selector == oldSelector ifFalse: [
		self reformulateListNoting: selector].
	self triggerEvent: #annotationChanged.
	^ true! !
!Morph methodsFor: 'geometry' stamp: 'jmv 1/2/2012 15:13' prior: 50370424!
                  validateExtentAndBounds
	"To be removed. Just to check consistency"
	| answer1 answer2 |
	self flag: #jmvVer2.

"	answer1 _ owner
		ifNotNil: [ owner externalizeDistanceToWorld: extent ]
		ifNil: [ extent ]."
	answer1 _ extent.
	answer2 _ bounds extent.

	answer1 = answer2 rounded ifFalse: [
		#validateExtentAndBounds print.
		answer1 print.
		answer2 print.
		thisContext printStack: 10 ]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 1/1/2012 23:28' prior: 50367468!
          validateOwnerNotNil
	"To be removed. Just to check consistency"

	self flag: #jmvVer2.
"
	owner ifNil: [
		'-----Still no owner, but this stuff kind of requires it!!-----' print.
		thisContext printStack: 10 ]
	"! !
!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 1/4/2012 18:59' prior: 16783547!
                 resetMenu
	| w f |
	firstVisible _ 1.
	self selected: 1.
	w _ 120.
	f _ self class listFont.
	1
		to: completer entryCount
		do: [ :index |
			w _ w max: (f widthOfString: (completer entries at: index) asString)].
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w + ScrollBar scrollbarThickness ].
	self morphExtent: w + 4 @ (self visibleItemsCount * self itemHeight+2)! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 1/2/2012 14:31' prior: 16814856!
      buildMorphicAnnotationsPane

	| aTextMorph |
	aTextMorph _ TextModelMorph
		textProvider: model
		textGetter: #annotation.
	model when: #annotationChanged send: #redrawNeeded to: aTextMorph.
	aTextMorph
		askBeforeDiscardingEdits: false;
		hideScrollBarsIndefinitely.
	^aTextMorph! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 1/2/2012 13:46' prior: 50365470!
          mouseMove: evt
	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].
	self handleInteraction: [ editor mouseMove: (evt translatedBy: bounds topLeft negated)].
	(evt eventPosition y between: owner bounds top and: owner bounds bottom) ifFalse: [
		owner scrollSelectionIntoView: evt ]! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 1/2/2012 13:09' prior: 16870415!
                               updateFromParagraph
	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be released, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, and current typing emphasis."

	paragraph ifNotNil: [
		editor storeSelectionInParagraph.
		self fit.
	].

	owner
		updateScrollBarsBounds;
		setScrollDeltas! !
!LayoutAdjustingMorph methodsFor: 'testing' stamp: 'jmv 1/3/2012 14:10' prior: 16879830!
        isOpaqueMorph
	"Any submorph that answers true to #isOrthoRectangularMorph (to optimize #containsPoint:)
	but is not an opaque rectangle covering bounds MUST answer false to this message"
	color mightBeTranslucent ifTrue: [
		^false ].
	^true! !
!MessageSetWindow methodsFor: 'top window' stamp: 'jmv 1/2/2012 15:36' prior: 16891448!
                  activateAndSendTopToBack: aBoolean
	super activateAndSendTopToBack: aBoolean.
	self isCollapsed 
		ifFalse: [
			(model messageListIndex = 0 and: [ model messageList notEmpty ])
				ifTrue: [	
					"Not really pretty... Cleanup some day"
					model messageListIndex: 1.
					model autoSelectString ifNotNil: [
						[ model acceptedContentsChanged ]
							forkAt: Processor userBackgroundPriority  ]
				]]! !
!PluggableButtonMorph class methodsFor: 'example' stamp: 'jmv 1/3/2012 16:40' prior: 16913899!
      example
	"PluggableButtonMorph example openInWorld"

	| s1 s2 s3 b1 b2 b3 row |
	s1 _ Switch new.
	s2 _ Switch new turnOn.
	s3 _ Switch new.
	s2 onAction: [s3 turnOff].
	s3 onAction: [s2 turnOff].
	b1 _ (PluggableButtonMorph model: s1 stateGetter: #isOn action: #switch) label: 'S1'.
	b2 _ (PluggableButtonMorph model: s2 stateGetter: #isOn action: #turnOn) label: 'S2'.
	b3 _ (PluggableButtonMorph model: s3 stateGetter: #isOn action: #turnOn) label: 'S3'.
	b1 color: Color lightRed.
	b2 color: Color lightRed.
	b3 color: Color lightRed.
	row _ LayoutMorph newRow
		addMorphs: (Array with: b1 with: b2 with: b3);
		morphExtent: 120@35.
	^ row
! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 1/4/2012 19:00' prior: 50369457!
                               morphExtent: newExtent
	
	| minH minW |
	"Figure out the minimum width and height for this pane so that scrollbars will appear"
	minH _ self scrollBarClass scrollbarThickness * 2.
	minW _ minH.
	super morphExtent: (newExtent max: (minW@minH)).

	"Now reset widget sizes"
	scroller adjustExtent.
	self updateScrollBarsBounds.
	self setScrollDeltas! !
!PluggableListMorph methodsFor: 'selection' stamp: 'jmv 1/2/2012 13:49' prior: 16914420!
         selectionIndex: index
	"Called internally to select the index-th item."
	| row |
	self unhighlightSelection.
	row _ index ifNil: [ 0 ].
	row _ row min: self getListSize.  "make sure we don't select past the end"
	self listMorph selectedRow: row.
	self highlightSelection.
	self scrollSelectionIntoView! !
!TextModelMorph methodsFor: 'editor access' stamp: 'jmv 1/2/2012 13:49' prior: 50367021!
                      scrollSelectionIntoView: event
	"Scroll my text into view if necessary and return true, else return false"
	| selRects rectToTest cpHere |
	selRects _ self textMorph selectionRects.
	selRects isEmpty ifTrue: [ ^ self ].
	rectToTest _ selRects first merge: selRects last.
	event ifNotNil: [  "Check for autoscroll"
		cpHere _ event eventPosition.
		cpHere y <= bounds top
			ifTrue:  [ rectToTest _ selRects first topLeft extent: 2@2 ]
			ifFalse: [
				cpHere y >= bounds bottom
					ifTrue: [ rectToTest _ selRects last bottomRight extent: 2@2 ]
					ifFalse: [ ^ self ]]].
	^ self scrollToShow: rectToTest! !

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1296-LottaFixes-jmv.10.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #1261] on 10 April 2012 at 3:51:44 pm'!
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 1/6/2012 15:31' prior: 50370988!
                  fit
	"Adjust my bounds to fit the text.
	Required after the text changes,
	or if wrapFlag is true and the user attempts to change the extent."

	| newExtent |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent _ (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).
	extent = newExtent ifFalse: [
		self basicExtent: newExtent ].

	self redrawNeeded.	"Too conservative: only paragraph composition
							should cause invalidation."
	owner innerHeight: newExtent y! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 1/6/2012 14:52' prior: 50371758!
            morphExtent: newExtent
	
	| minH minW |
	"Figure out the minimum width and height for this pane so that scrollbars will appear"
	minH _ self vIsScrollbarShowing
		ifTrue: [self scrollBarClass scrollbarThickness * 2]
		ifFalse: [0].
	minW _ self hIsScrollbarShowing
		ifTrue: [self scrollBarClass scrollbarThickness * 2]
		ifFalse: [0].
	super morphExtent: (newExtent max: (minW@minH)).

	"Now reset widget sizes"
	scroller adjustExtent.
	self updateScrollBarsBounds.
	self setScrollDeltas! !

StringMorph removeSelector: #setWidth:!

StringMorph removeSelector: #setWidth:!

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1297-AccountForLaterCuis4Changes-jmv.5.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4209] on 11 April 2012 at 9:35:50 pm'!
!HandMorph methodsFor: 'private events' stamp: 'jmv 4/11/2012 21:35' prior: 16865561!
    generateMouseEvent: evtBuf 
	"Generate the appropriate mouse event for the given raw event buffer"

	| pos buttons modifiers type trail stamp oldButtons |
	stamp := evtBuf second.
	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ].
	pos := evtBuf third @ evtBuf fourth.
	buttons := evtBuf fifth.
	modifiers := evtBuf sixth.
	type := buttons = 0 
		ifTrue: [
			lastEventBuffer fifth = 0 ifTrue: [#mouseMove] ifFalse: [#mouseUp]]
		ifFalse: [
			lastEventBuffer fifth = 0 
						ifTrue: [#mouseDown]
						ifFalse: [#mouseMove]].
	buttons := buttons bitOr: (modifiers bitShift: 3).
	oldButtons := lastEventBuffer fifth 
				bitOr: (lastEventBuffer sixth bitShift: 3).
	lastEventBuffer := evtBuf.
	type == #mouseMove 
		ifTrue: [
			trail := self mouseTrailFrom: evtBuf.
			^MouseMoveEvent new 
				setType: type
				startPoint: trail first
				endPoint: trail last
				trail: trail
				buttons: buttons
				hand: self
				stamp: stamp].
	^MouseButtonEvent new 
		setType: type
		position: pos
		which: (oldButtons bitXor: buttons)
		buttons: buttons
		hand: self
		stamp: stamp! !

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1298-CleanAShadowedVar-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4209] on 11 April 2012 at 10:01:23 pm'!
!CodeProvider methodsFor: 'commands' stamp: 'jmv 4/11/2012 21:54' prior: 16813947!
              hierarchyBrowser
	"Create and schedule a new hierarchy browser on the currently selected class or meta."

	| newBrowser aSymbol aBehavior messageCatIndex selectedClassOrMetaClass |
	(selectedClassOrMetaClass _ self selectedClassOrMetaClass)
		ifNil: [^ nil].
	newBrowser _ HierarchyBrowser new initHierarchyForClass: selectedClassOrMetaClass.
	((aSymbol _ self selectedMessageName) notNil and: [(MessageSet isPseudoSelector: aSymbol) not])
		ifTrue: [
			aBehavior _ selectedClassOrMetaClass.
			messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.
			messageCatIndex = 0 ifFalse: [
				newBrowser messageCategoryListIndex: messageCatIndex + 1.
				newBrowser messageListIndex:
					((aBehavior organization listAtCategoryNumber: messageCatIndex) indexOf: aSymbol) ]].
	^newBrowser! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/11/2012 21:56' prior: 16861019!
  drawString: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: c
	| font |
	port colorMap: nil.
	font _ fontOrNil ifNil: [StrikeFont default].
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: (origin + aPoint)
		strikeFont: font
		kern: font baseKern negated! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/11/2012 21:56' prior: 16861037!
               drawString: aString from: firstIndex to: lastIndex in: bounds font: fontOrNil color: c
	| font portRect |
	port colorMap: nil.
	portRect _ port clipRect.
	port clipByX1: bounds left + origin x 
		y1: bounds top + origin y 
		x2: bounds right + origin x 
		y2: bounds bottom + origin y.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [port clipRect: portRect. ^self].
	port clipWidth = 0 ifTrue: [port clipRect: portRect. ^self].
	font _ fontOrNil ifNil: [StrikeFont default].
	port installStrikeFont: font foregroundColor: (shadowColor ifNil: [ c ]).
	port
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: (bounds topLeft + origin)
		strikeFont: font
		kern: font baseKern negated.
	port clipRect: portRect! !
!FormCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/11/2012 21:58' prior: 16861070!
                   drawStringEmbossed: aString from: firstIndex to: lastIndex in: bounds font: fontOrNil color: aColor
	| font portRect insideColor |
	port colorMap: nil.
	portRect _ port clipRect.
	port clipByX1: bounds left + origin x 
		y1: bounds top + origin y 
		x2: bounds right + origin x 
		y2: bounds bottom + origin y.
	"Slight optimization when there's nothing to do."
	port clipHeight = 0 ifTrue: [^self].
	port clipWidth = 0 ifTrue: [^self].
	font _ fontOrNil ifNil: [StrikeFont default].
	insideColor _ shadowColor ifNil: [ aColor ].
	insideColor = Color black ifFalse: [ | topColor |
		topColor _ insideColor alphaMixed: 0.25 with: Color black.
		port installStrikeFont: font foregroundColor: topColor.
		port
			displayString: aString asString
			from: firstIndex
			to: lastIndex
			at: (bounds topLeft + origin)
			strikeFont: font
			kern: font baseKern negated ].
	insideColor = Color white ifFalse: [ | bottomColor |
		bottomColor _ insideColor alphaMixed: 0.22 with: Color white.
		port installStrikeFont: font foregroundColor: bottomColor.
		port
			displayString: aString asString
			from: firstIndex
			to: lastIndex
			at: (bounds topLeft + origin + (0@2))
			strikeFont: font
			kern: font baseKern negated ].
	port installStrikeFont: font foregroundColor: insideColor.
	port
		displayString: aString asString
		from: firstIndex
		to: lastIndex
		at: (bounds topLeft + origin + (0@1))
		strikeFont: font
		kern: font baseKern negated.
	port clipRect: portRect! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 4/11/2012 21:51' prior: 16900483!
           displayBulletParagraphTopLeft: paragraphTopLeft number: bulletNumber
	| pattern i c j s bullet bulletPos bulletSize prefix |
	pattern _ paragraphStyle listBulletPattern.
	bullet _ pattern.
	(i _ pattern indexOf: $%) > 0
		ifTrue: [ bullet _ bulletNumber asString]
		ifFalse: [
			(i _ pattern indexOf: $z) > 0
				ifTrue: [ bullet _ (Character value: 96 + bulletNumber) asString ]
				ifFalse: [
					(i _ pattern indexOf: $Z) > 0
						ifTrue: [ bullet _ (Character value: 64 + bulletNumber) asString ]]].
	prefix _ 0.
	i > 0 ifTrue: [
		c _ pattern at: i.
		j _ i.
		s _ pattern size.
		[ j <= s and: [ (pattern at: j) = c ] ] whileTrue: [ j _ j + 1 ].
		j _ j - 1.
		bulletSize _ j-i+1.
		prefix _ bulletSize - bullet size max: 0.
		bullet size > bulletSize ifTrue: [
			bullet _ bullet copyFrom: bullet size - bulletSize + 1 to: bullet size ].
		bullet _ (pattern copyFrom: 1 to: i-1), bullet, (pattern copyFrom: j+1 to: pattern size) ].
	bulletPos _ paragraphStyle firstIndent + paragraphTopLeft x + ((font widthOf: $9) * prefix)@destY.
	canvas grafPort displayString: bullet from: 1 to: bullet size at: bulletPos strikeFont: font kern: kern! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 4/11/2012 21:56' prior: 16900521!
             displayLine: textLine paragraphTopLeft: paragraphTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."
	| done stopCondition nowLeftInRun startIndex string lastPos priorFont |

	line _ textLine.
	paraTopLeft _ paragraphTopLeft + canvas origin.
	lineY _ line top + paraTopLeft y.
	lineHeight _ line lineHeight.
	rightMargin _ line rightMargin + paraTopLeft x.
	lastIndex _ line first.
	leftInRun <= 0 ifTrue: [self setStopConditions].
	leftMargin _ (line leftMarginForAlignment: alignment) + paraTopLeft x.
	destX _ runX _ leftMargin.
	destY _ lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: [ :ps |
			ps = paragraphStyle ifFalse: [
				""
				foregroundColor _ paragraphColor.
				priorFont _ font.
				self setActualFont: ps font.
				ps color ifNotNil: [ :color | self textColor: color ].
				alignment _ ps alignment.
				paragraphStyle _ ps.
				priorFont ifNotNil: [ destX _ destX + priorFont descentKern ].
				destX _ destX - font descentKern.
				kern _ 0 - font baseKern.
				spaceWidth _ font widthOf: Character space.
				xTable _ font xTable.
				map _ font characterToGlyphMap.
				stopConditions _ DefaultStopConditions.
				canvas grafPort installStrikeFont: font foregroundColor: foregroundColor.
				text ifNotNil: [ destY _ lineY + line baseline - font ascent ]
				""
			]
		].
		self displayBulletIfAppropriateFor: textLine paragraphTopLeft: paraTopLeft.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine paragraphTopLeft: paraTopLeft.

	lastIndex _ line first.
	leftInRun <= 0
		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun _ leftInRun].
	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount _ 0.
	done _ false.
	string _ text string.

	self placeEmbeddedObject.
	[ done ] whileFalse: [
		startIndex _ lastIndex.
		lastPos _ destX@destY.
		stopCondition _ self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions
			kern: kern.
		lastIndex >= startIndex ifTrue: [
			canvas grafPort 
				displayString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				strikeFont: font
				kern: kern ].
		"see setStopConditions for stopping conditions for displaying."
		done _ self perform: stopCondition ].
	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !
!MorphicScanner methodsFor: 'private' stamp: 'jmv 4/11/2012 21:57' prior: 16900633!
             setFont 
	foregroundColor _ paragraphColor.
	super setFont.  "Sets font and emphasis bits, and maybe foregroundColor"
	canvas grafPort installStrikeFont: font foregroundColor: foregroundColor.
	text ifNotNil: [ destY _ lineY + line baseline - font ascent ]! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 4/11/2012 21:57' prior: 16978297!
   displayOn: aForm
	"
	Transcript displayOn: Display
	"
	| font port count i string x y fh f bw r |
	bw _ self borderWidth  .
	r _ innerRectangle outsetBy: bw + self padding.
	aForm border: r width: bw. 
	aForm fill: r fillColor: Color white.
	port _ BitBlt toForm: aForm.
	port clipWidth: innerRectangle right.
	font _ StrikeFont default.
	port installStrikeFont: font foregroundColor: Color veryDarkGray.
	
	fh _ font height.
	count _ innerRectangle height // fh-1.
	x _ innerRectangle left.
	y _ innerRectangle top.
	f _ firstIndex-1.
	firstIndex > lastIndex ifTrue: [ f _ f - self maxEntries ].
	i _ (lastIndex - count max: f) \\ self maxEntries + 1.
	[
		string _ entries at: i.	
		port displayString: string from: 1 to: string size at: x@y strikeFont: font kern: font baseKern negated.
		y _ y + fh.
		i = lastIndex
	] whileFalse: [ i _ i \\ self maxEntries + 1 ].

	string _ unfinishedEntry contents.	
	port displayString: string from: 1 to: string size at: x@y strikeFont: font kern: font baseKern negated.! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 4/11/2012 21:57' prior: 16978340!
               displayUnfinishedEntryOn: aForm

	| font port count string x y fh |
	port _ BitBlt toForm: aForm.
	port clipWidth: innerRectangle right.
	font _ StrikeFont default.
	port installStrikeFont: font foregroundColor: Color black.
	
	fh _ font height.
	count _ innerRectangle height // fh-1.
	x _ innerRectangle left.

	string _ unfinishedEntry contents.
	y _ ((lastIndex - firstIndex \\ self maxEntries) min: count-1) + 1 * font height + innerRectangle top.
	port displayString: string from: 1 to: string size at: x@y strikeFont: font kern: font baseKern negated.! !

StrikeFont removeSelector: #characters:in:displayAt:clippedBy:rule:fillColor:!

StrikeFont removeSelector: #characters:in:displayAt:clippedBy:rule:fillColor:!

StrikeFont removeSelector: #displayLine:at:!

StrikeFont removeSelector: #displayLine:at:!

StrikeFont removeSelector: #displayString:on:from:to:at:kern:!

StrikeFont removeSelector: #displayString:on:from:to:at:kern:!

StrikeFont removeSelector: #installOn:foregroundColor:!

StrikeFont removeSelector: #installOn:foregroundColor:!

AbstractFont removeSelector: #displayString:on:from:to:at:kern:!

AbstractFont removeSelector: #displayString:on:from:to:at:kern:!

AbstractFont removeSelector: #installOn:foregroundColor:!

AbstractFont removeSelector: #installOn:foregroundColor:!

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1299-SmallTextRenderCleanup-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 7:55:17 am'!
!Theme class methodsFor: 'user interface' stamp: 'jmv 4/12/2012 07:54' prior: 50364372!
           changeTheme

	| themes set menu result |
		themes _ Theme allSubclasses copyWith: Theme.
		set _ themes collect: [ :i | { i asString . i } ].
		menu _ SelectionMenu fromArray: set asArray.
		result _ menu startUpWithCaption: 'Choose a theme'.

	result ifNotNil: [
		result beCurrent ]! !

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1300-ThemeSelectionWalkbackFix-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 8:28:36 am'!
!HaloMorph methodsFor: 'private' stamp: 'jmv 4/12/2012 08:02' prior: 50368901!
           addHandle: handleSpec on: eventName send: selector to: recipient 
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint iconName colorToUse icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle bounds: (Rectangle center: aPoint extent: HandleSize asPoint).
	(iconName _ handleSpec iconSymbol) ifNotNil: [
			| form |
			form _ Icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon.
				icon morphPositionInOwner: 0@0 ]].
	handle 
		on: #mouseUp
		send: #endInteraction
		to: self.
	handle 
		on: eventName
		send: selector
		to: recipient.
	handle 
		setBalloonText: (target balloonHelpTextForHandle: handle).
	^handle! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 4/12/2012 08:11' prior: 50369047!
                   popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem
	"Present this menu at the given point under control of the given hand."

	| delta tryToPlace selectedOffset |
	hand world startSteppingSubmorphsOf: self.
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition - self morphPosition.
	sourceItem owner owner addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self fullBounds amountToTranslateWithin: sourceItem world bounds.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPoint first value: false;
		value: rightOrLeftPoint last - (self morphWidth @ 0) value: false;
		value: rightOrLeftPoint first value: true! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 4/12/2012 08:24' prior: 50357964!
                           cuisDefaults
	"
	Preferences cuisDefaults
	"
	self setPreferencesFrom:

	#(
		(balloonHelpEnabled true)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds false)
		(checkForSlips true)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic false)
		(menuKeyboardControl true)
		(optionalButtons true)
		(extraDebuggerButtons true)
		(simpleMenus false)
		(smartUpdating true)
		(subPixelRenderFonts true)
		(thoroughSenders true)
	)! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 4/12/2012 08:24' prior: 50357983!
                             slowMachine

	self setPreferencesFrom: #(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(fastDragWindowForMorphic true)
		(menuKeyboardControl false)
		(optionalButtons false)
		(simpleMenus false)
		(smartUpdating false)
		(subPixelRenderFonts false)
		(thoroughSenders false)
	).
	ClassicTheme beCurrent! !
!Preferences class methodsFor: 'themes' stamp: 'jmv 4/12/2012 08:24' prior: 50358001!
                              smalltalk80
	"A traditional monochrome Smalltalk-80 look and feel, clean and austere, and lacking many features added to Squeak in recent years. Caution: this theme removes the standard Squeak flaps, turns off the 'smartUpdating' feature that keeps multiple browsers in synch, and much more."

	self setPreferencesFrom:

	#(
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList false)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(simpleMenus false)
		(smartUpdating false)
		(thoroughSenders false)
	)! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/12/2012 08:08' prior: 50364460!
                               morphPosition: newPos

	super morphPosition: newPos.

	self flag: #jmvVer2. "Maybe this would be better done in methods storing in #bounds...
	Better yet would be to remove this crap"
	isCollapsed
		ifTrue: [ collapsedFrame _ bounds ]
		ifFalse: [ fullFrame _ bounds ]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:25' prior: 16965536!
                      collapse

	| cf |
		
	self isCollapsed ifFalse: [

		"Collapse -- remove panes from morphics structure"

		isCollapsed _ true.
		fullFrame _ bounds.

		"First save latest fullFrame"
		layoutMorph ifNotNil: [ layoutMorph hide ].
		cf := RealEstateAgent assignCollapseFrameFor: self.
		collapsedFrame ifNil: [
			collapsedFrame _ cf].
		self bounds: cf.
	
		Taskbar visible ifTrue: [ Taskbar minimize: self ]
	]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:24' prior: 16965573!
         expand
	self isCollapsed
		ifTrue: [
		
			"Expand -- restore panes to morphics structure"
	
			isCollapsed _ false.
			self activate.  "Bring to front first"

			collapsedFrame _ bounds.

			self bounds: fullFrame.
			layoutMorph ifNotNil: [ layoutMorph show ].
			
			Taskbar visible ifTrue: [ Taskbar restore: self. ]
		]! !

SystemWindow removeSelector: #getCollapsedFrame!

SystemWindow removeSelector: #getCollapsedFrame!

Preferences class removeSelector: #collapseWindowsInPlace!

Preferences class removeSelector: #collapseWindowsInPlace!

PasteUpMorph removeSelector: #morphPosition:!

PasteUpMorph removeSelector: #morphPosition:!

HaloMorph removeSelector: #morphPosition:!

HaloMorph removeSelector: #morphPosition:!

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1301-SimplifyWindowCollapse-jmv.3.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 8:42:41 am'!

!classDefinition: #SystemWindow category: #'Morphic-Views for Models'!
PluggableMorph subclass: #SystemWindow
	instanceVariableNames: 'labelString collapsedFrame fullFrame isCollapsed updatablePanes widgetsColor layoutMorph adjusters'
	classVariableNames: 'TopWindow'
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

PluggableMorph subclass: #SystemWindow
	instanceVariableNames: 'labelString collapsedFrame fullFrame isCollapsed updatablePanes widgetsColor layoutMorph adjusters '
	classVariableNames: 'TopWindow '
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 4/12/2012 08:36' prior: 50371320!
  makeMeVisible 

	self world morphExtent > (0@0) ifFalse: [^ self].

	(self morphPosition >= (0@0) and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: extent world: self world) topLeft! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/12/2012 08:39' prior: 50366855!
                    justDroppedInto: aMorph event: anEvent
	isCollapsed
		ifTrue: [
			self morphPosition: (self morphPosition max: 0@0) ]
		ifFalse: [
			TopWindow ~~ self ifTrue: [self activate]].
	^super justDroppedInto: aMorph event: anEvent! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 4/12/2012 08:39' prior: 50371339!
        morphExtent: aPoint 
	"Set the receiver's extent to value provided. Respect my minimumExtent."

	| newExtent |
	newExtent _ self isCollapsed
		ifTrue: [aPoint]
		ifFalse: [aPoint max: self minimumExtent].
	newExtent = extent ifTrue: [^ self].

	isCollapsed
		ifTrue: [super morphExtent: newExtent x @ (self labelHeight + 2)]
		ifFalse: [super morphExtent: newExtent]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:41' prior: 50372411!
                    collapse
		
	self isCollapsed ifFalse: [

		"Collapse -- remove panes from morphics structure"

		isCollapsed _ true.
		layoutMorph ifNotNil: [ layoutMorph hide ].
		self morphExtent: 400@(self labelHeight + 2).
	
		Taskbar visible ifTrue: [ Taskbar minimize: self ]
	]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:33' prior: 50372427!
                     expand
	self isCollapsed
		ifTrue: [
		
			"Expand -- restore panes to morphics structure"
	
			isCollapsed _ false.
			self activate.  "Bring to front first"

			self morphExtent: 400@300.

			layoutMorph ifNotNil: [ layoutMorph show ].
			
			Taskbar visible ifTrue: [ Taskbar restore: self. ]
		]! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 4/12/2012 08:38' prior: 16965590!
                       expandBoxHit
	"The full screen expand box has been hit"

	isCollapsed ifTrue: [
		self hide.
		self collapseOrExpand.
		self fullScreen.
		^ self show].
	self fullScreen! !

SystemWindow removeSelector: #collapsedExtent!

SystemWindow removeSelector: #collapsedExtent!

SystemWindow removeSelector: #collapsedFrame!

SystemWindow removeSelector: #collapsedFrame!

SystemWindow removeSelector: #morphPosition:!

SystemWindow removeSelector: #morphPosition:!

SystemWindow removeSelector: #unexpandedFrame!

SystemWindow removeSelector: #unexpandedFrame!

SystemWindow removeSelector: #unexpandedFrame:!

SystemWindow removeSelector: #unexpandedFrame:!

!classDefinition: #SystemWindow category: #'Morphic-Views for Models'!
PluggableMorph subclass: #SystemWindow
	instanceVariableNames: 'labelString isCollapsed updatablePanes widgetsColor layoutMorph adjusters'
	classVariableNames: 'TopWindow'
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

PluggableMorph subclass: #SystemWindow
	instanceVariableNames: 'labelString isCollapsed updatablePanes widgetsColor layoutMorph adjusters'
	classVariableNames: 'TopWindow'
	poolDictionaries: ''
	category: 'Morphic-Views for Models'!

RealEstateAgent class removeSelector: #assignCollapseFrameFor:!

RealEstateAgent class removeSelector: #assignCollapseFrameFor:!

RealEstateAgent class removeSelector: #assignCollapsePointFor:!

RealEstateAgent class removeSelector: #assignCollapsePointFor:!

RealEstateAgent class removeSelector: #initialFrameFor:!

RealEstateAgent class removeSelector: #initialFrameFor:!

RealEstateAgent class removeSelector: #initialFrameFor:initialExtent:!

RealEstateAgent class removeSelector: #initialFrameFor:initialExtent:!

RealEstateAgent class removeSelector: #standardPositions!

RealEstateAgent class removeSelector: #standardPositions!

RealEstateAgent class removeSelector: #strictlyStaggeredInitialFrameFor:initialExtent:!

RealEstateAgent class removeSelector: #strictlyStaggeredInitialFrameFor:initialExtent:!

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1302-AdditionalCollapseSimplification-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 8:58:08 am'!
!FormCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 4/12/2012 08:56' prior: 50371530!
                            buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	"

	| resizeFactor outerBox arrowMorph resizedForm f |
	resizeFactor _ 4.
	outerBox _ RectangleMorph new.
	outerBox
		morphExtent: finalSizeInteger asPoint * resizeFactor;
		borderWidth: 0;
		color: Color transparent.
	
	arrowMorph _ self buildArrowIn: outerBox bounds.
	outerBox addMorphFront: arrowMorph.
	arrowMorph morphPositionInOwner: 12@8.	"not a clue why these numbers work..."
	
	
	f _ outerBox imageForm: 32.
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotateBy: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotateBy: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotateBy:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1303-SmallCleanup-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 9:04:10 am'!
!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 4/12/2012 09:01' prior: 50369196!
                        addToScroller: aMorph

	scroller addMorph: aMorph.
	aMorph morphPositionInOwner: 0@0! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 4/12/2012 09:03' prior: 50366239!
              scrollerOffset: newOffset
	| delta |
	delta _ borderWidth + self xtraBorder.
	scroller morphPositionInOwner: delta@delta - newOffset! !

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1304-SmallCleanup2-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 9:15:45 am'!
!Morph methodsFor: 'geometry' stamp: 'jmv 4/12/2012 09:11' prior: 50364705!
                  align: aPoint1 with: aPoint2
	"Translate by aPoint2 - aPoint1."

	^ self morphPositionInOwner: self morphPositionInOwner + (aPoint2 - aPoint1)! !
!Morph methodsFor: 'geometry' stamp: 'jmv 4/12/2012 09:12' prior: 50369546!
  bounds: newBounds
	| oldExtent newExtent |

	"remove senders and implementors"
	self flag: #jmvVer2.
		
	oldExtent _ bounds extent.
	newExtent _ newBounds extent.
	"Moving stuff around is most likely the most common operation.
	Optimize it"
	oldExtent = newExtent ifTrue: [
		^self morphPositionInWorld: newBounds topLeft ].
	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[
		"We're growing. First move then resize."
		self morphPositionInWorld: newBounds topLeft; morphExtent: newExtent.
	] ifFalse: [
		"We're shrinking. First resize then move."
		self morphExtent: newExtent; morphPositionInWorld: newBounds topLeft.
	].! !
!Morph methodsFor: 'geometry eToy' stamp: 'jmv 4/12/2012 09:13' prior: 16897917!
                            referencePosition
	"Return the current reference position of the receiver"
	"a rather ugly way to say #center . At least, we avoid false polymorphism"
	"remove some day"
	self flag: #jmvVer2.
	^bounds center! !
!Morph methodsFor: 'geometry eToy' stamp: 'jmv 4/12/2012 09:13' prior: 50367890!
                            referencePosition: aPoint
	"a rather ugly way to say #center: . Just for consistency with #referencePosition"
	"remove some day"
	self flag: #jmvVer2.
	self morphPositionInWorld: aPoint - (bounds extent // 2)! !
!SketchMorph methodsFor: 'accessing' stamp: 'jmv 4/12/2012 09:14' prior: 50366647!
                         form: aForm
	"Set the receiver's form"

	| oldForm |
	oldForm _ originalForm.
	originalForm _ aForm.
	self basicExtent: originalForm extent.

	oldForm ifNotNil: [ self morphPositionInOwner: self morphPositionInOwner + (oldForm extent - aForm extent // 2) ]! !
!StarMorph methodsFor: 'editing' stamp: 'jmv 4/12/2012 09:14' prior: 50366814!
             dragVertex: label event: evt fromHandle: handle
	| ext oldR pt center |
	label == #center ifTrue: [
		self morphPositionInOwner: self morphPositionInOwner + (evt eventPosition - handle referencePosition)].

	label == #outside ifTrue: [
		center _ handles first referencePosition.
		pt _ center - evt eventPosition.
		ext _ pt r.
		oldR _ ext.
		vertices _ (0 to: 359 by: (360//vertices size)) collect: [ :angle |
			(Point r: (oldR _ oldR = ext ifTrue: [ext*5//12] ifFalse: [ext])
					degrees: angle + pt degrees)
				+ center].
		handle align: handle referencePosition with: evt eventPosition ].

	self computeBounds.
! !

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1305-SmallCleanup3-jmv.1.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4211] on 12 April 2012 at 10:41:12 am'!
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 10:38'!
                     freeSliderRoom
	"Answer the length or height of the free slider area, i.e. substract the slider itself"

	^ (self isHorizontal
		ifTrue: [ self morphExtent x - slider morphExtent x]
		ifFalse: [ self morphExtent y - slider morphExtent y])
			- (borderWidth * 2) - (self buttonExtent * 2).! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 10:38'!
                            totalSliderRoom
	"Answer the length or height of the slider area"

	^ (self isHorizontal
		ifTrue: [ self morphExtent x ]
		ifFalse: [ self morphExtent y ])
			- (borderWidth * 2) - (self buttonExtent * 2).! !
!ScrollBar methodsFor: 'testing' stamp: 'jmv 4/12/2012 09:51'!
               isHorizontal
	| e |
	e _ self morphExtent.
	^e x > e y! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 10:27' prior: 50366627!
                      computeSlider

	| delta |
	delta _ self buttonExtent + (self freeSliderRoom * value) asInteger.
	self isHorizontal
		ifTrue: [
			slider morphPositionInOwner: borderWidth +  delta @ borderWidth ]
		ifFalse: [
			slider morphPositionInOwner: borderWidth @ (borderWidth + delta) ] ! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 10:20' prior: 50370099!
                     expandSlider
	"Compute the new size of the slider (use the old sliderThickness as a minimum)."

	| e |
	e _ (self totalSliderRoom * interval) asInteger max: 7.
	slider morphExtent: (self isHorizontal
		ifTrue: [ e @ self buttonExtent ]
		ifFalse: [ self buttonExtent @ e ])! !
!ScrollBar methodsFor: 'geometry' stamp: 'jmv 4/12/2012 09:52' prior: 50371293!
                           morphExtent: newExtent

	| newExtentToUse |
	self validatePositionAndBounds.
	self validateExtentAndBounds.
	newExtent = extent ifTrue: [^ self].
	newExtentToUse _ self isHorizontal
		ifTrue: [ (newExtent x max: 14) @ newExtent y ]
		ifFalse: [ newExtent x @ (newExtent y max: 14) ].
	newExtentToUse = extent ifTrue: [^ self].
	super morphExtent: newExtentToUse.
		
	self flag: #jmv.
	"Most times it is not necessary to recreate the buttons"
	self recreateSubmorphs! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 4/12/2012 09:57' prior: 16934969!
                         initializeDownButton
	"initialize the receiver's downButton"

	| e |
	e _ self buttonExtent.
	downButton _ self buttonClass new.
	downButton model: self.
	self addMorph: downButton.
	downButton
		morphPositionInOwner: self morphExtent - borderWidth - e;
		morphExtent: e.
	self isHorizontal
		ifTrue: [ downButton updateRightButtonImage ]
		ifFalse: [ downButton updateDownButtonImage ]! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 4/12/2012 10:02' prior: 16934983!
        initializeSlider
	"initialize the receiver's slider"

	sliderShadow _ RectangleMorph new.
	sliderShadow borderWidth: 0.
	self addMorph: sliderShadow.
	sliderShadow hide.
		
	slider _ self sliderClass new.
	slider model: self.
	slider grabSelector: #sliderGrabbed.
	slider dragSelector: #scrollAbsolute:.
	slider action: #sliderReleased.
	self addMorph: slider.

	self computeSlider! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 4/12/2012 09:56' prior: 16935000!
             initializeUpButton
	"initialize the receiver's upButton"

	upButton _ self buttonClass new.
	upButton model: self.
	self addMorph: upButton.
	upButton
		morphPositionInOwner: borderWidth@borderWidth;
		morphExtent: self buttonExtent.
	self isHorizontal
		ifTrue: [ upButton updateLeftButtonImage ]
		ifFalse: [ upButton updateUpButtonImage ].! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 4/12/2012 10:38' prior: 16935039!
                     scrollAbsolute: aPoint
	| relativePoint v |
	relativePoint _ aPoint - bounds topLeft.
	v _ (self isHorizontal
		ifTrue: [ relativePoint x ]
		ifFalse: [ relativePoint y ])
			- borderWidth - self buttonExtent * 1.0
				/ self freeSliderRoom.
	self setValue: v! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 4/12/2012 09:53' prior: 50366637!
        setNextDirectionFromEvent: event

	nextPageDirection _ self isHorizontal
		ifTrue: [ event eventPosition x >= slider referencePosition x ]
		ifFalse: [ event eventPosition y >= slider referencePosition y ]! !
!ScrollBar methodsFor: 'scrolling' stamp: 'jmv 4/12/2012 09:30' prior: 16935086!
                              sliderGrabbed

	| delta e |
	sliderShadow
		morphPositionInOwner: slider morphPositionInOwner;
		morphExtent: slider morphExtent;
		show! !

ScrollBar removeSelector: #freeSliderSpace!

ScrollBar removeSelector: #roomToMove!

ScrollBar removeSelector: #roomToMove!

ScrollBar removeSelector: #sliderExtent!

ScrollBar removeSelector: #sliderExtent!

ScrollBar removeSelector: #totalSliderArea!

ScrollBar removeSelector: #totalSliderArea!

ScrollBar removeSelector: #totalSliderHeight!

ScrollBar removeSelector: #totalSliderSpace!

ScrollBar removeSelector: #totalSliderWidth!

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1306-ScrollBarCleanup-jmv.7.cs----!

'From Cuis 4.0 of 3 April 2012 [latest update: #4218] on 20 April 2012 at 2:50:57 pm'!
!Morph methodsFor: 'meta-actions' stamp: 'jmv 4/20/2012 14:45'!
 dismissMorph
	| w |
	w _ self world ifNil:[^self].
	w deleteAllHalos; stopStepping: self.
	self delete
! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 4/20/2012 14:46'!
                     resizeMorph
	| handle |
	handle := HandleMorph new 
				forEachPointDo: [:newPoint | self morphExtent: newPoint - bounds topLeft].
	self activeHand attachMorph: handle.
	handle startStepping! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 4/20/2012 14:46' prior: 16898960!
              resizeFromMenu
	"Commence an interaction that will resize the receiver"

	self resizeMorph! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 4/20/2012 14:45' prior: 16899493!
          dismissViaHalo
	"The user has clicked in the delete halo-handle.  This provides a hook in case some concomitant action should be taken, or if the particular morph is not one which should be put in the trash can, for example."

	^ self dismissMorph! !
!HandMorph methodsFor: 'event handling' stamp: 'jmv 4/20/2012 14:47' prior: 16864966!
               processEvents
	"Process user input events from the local input devices."

	| evt evtBuf type hadAny |

	hadAny := false.
	[ (evtBuf := Sensor nextEvent) isNil ] whileFalse: [
		evt := nil.	"for unknown event types"
		type := evtBuf first.
		type = EventSensor eventTypeMouse
			ifTrue: [ evt := self generateMouseEvent: evtBuf ].
		type = EventSensor eventTypeKeyboard 
			ifTrue: [ evt := self generateKeyboardEvent: evtBuf ].
		type = EventSensor eventTypeWindow
			ifTrue: [ evt _ self generateWindowEvent: evtBuf ].
		"All other events are ignored"
		evt
			ifNil: [
				^hadAny]
			ifNotNil: [
				"Finally, handle it"
				self handleEvent: evt.
				hadAny := true.
				"For better user feedback, return immediately after a mouse event has been processed."
				evt isMouse ifTrue: [ ^hadAny ]]].
	"note: if we come here we didn't have any mouse events"
	mouseClickState 
		ifNotNil: [ 
			"No mouse events during this cycle. Make sure click states time out accordingly"
			mouseClickState
				handleEvent: (lastMouseEvent asMouseMove: (Time millisecondClockValue - lastMouseEventTime max: 0))
				from: self ].
	^hadAny! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 4/20/2012 14:47' prior: 16865656!
  sendEvent: anEvent
	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."

	^owner processEvent: anEvent! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 4/20/2012 14:48' prior: 16865666!
                    sendFocusEvent: anEvent to: focusHolder in: world
	"Send the event to focusHolder, the morph currently holding the focus"
	| result |
	world becomeActiveDuring: [
		ActiveHand _ self.
		result _ focusHolder handleFocusEvent: anEvent ].
	^result! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 4/20/2012 14:48' prior: 16879952!
                        layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableWidth sumOfFixed normalizationFactor availableForPropWidth widths l usableHeight boundsTop boundsRight r t b |
	xSep _ self xSeparation.
	ySep _ self ySeparation.
	usableWidth _ boundsForLayout width - ((submorphs size + 1) * xSep).
	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedWidth ].
	availableForPropWidth _ usableWidth - sumOfFixed.
	padding ifNil: [	"shrink"
		availableForPropWidth = 0 ifFalse: [
			self flag: #jmvVer2.
			self width: self width - availableForPropWidth.
			^ self layoutSubmorphsAndComputeFullBounds ]].
	normalizationFactor _ self proportionalWidthNormalizationFactor.
	availableForPropWidth _ availableForPropWidth * normalizationFactor.
	widths _ submorphs collect: [ :m | m layoutSpec widthFor: availableForPropWidth ].
	l _ ((usableWidth - widths sum) * (padding ifNil: [0]) + xSep max: 0) +  boundsForLayout left.
	usableHeight _ boundsForLayout height - (2*ySep) max: 0.
	boundsTop _ boundsForLayout top.	
	boundsRight _ boundsForLayout right.
	submorphs size to: 1 by: -1 do: [ :index | | m w h ls |
		m _ submorphs at: index.
		w _ widths at: index.
		"major direction"
		r _ l + w min: boundsRight.
		"minor direction"
		ls _ m layoutSpec.
		h _ (ls heightFor: usableHeight) min: usableHeight.
		t _ (usableHeight - h) * ls minorDirectionPadding + ySep + boundsTop.
		b _ t + h.
		"Set bounds and adjust major direction for next step"
		m bounds: (l rounded @ t rounded corner: r rounded @ b rounded).
		w > 0 ifTrue: [
			l _ r + xSep min: boundsRight ]]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 4/20/2012 14:48' prior: 16880005!
                     layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableHeight sumOfFixed normalizationFactor availableForPropHeight heights t usableWidth boundsLeft boundsBottom b l r |
	xSep _ self xSeparation.
	ySep _ self ySeparation.
	usableHeight _ boundsForLayout height - ((submorphs size + 1) * ySep).
	sumOfFixed _ submorphs sum: [ :m | m layoutSpec fixedHeight ].
	availableForPropHeight _ usableHeight - sumOfFixed.
	padding ifNil: [	"shrink"
		availableForPropHeight = 0 ifFalse: [
			self flag: #jmvVer2.
			self height: self height - availableForPropHeight.
			^ self layoutSubmorphsAndComputeFullBounds ]].
	normalizationFactor _ self proportionalHeightNormalizationFactor.
	availableForPropHeight _ availableForPropHeight * normalizationFactor.
	heights _ submorphs collect: [ :m | m layoutSpec heightFor: availableForPropHeight ].
	t _ ((usableHeight - heights sum) * (padding ifNil: [0]) + ySep max: 0) +  boundsForLayout top.
	usableWidth _ boundsForLayout width - (2*xSep) max: 0.
	boundsLeft _ boundsForLayout left.	
	boundsBottom _ boundsForLayout bottom.
	submorphs size to: 1 by: -1 do: [ :index | | m h w ls |
		m _ submorphs at: index.
		h _ heights at: index.
		"major direction"
		b _ t + h min: boundsBottom.
		"minor direction"
		ls _ m layoutSpec.
		w _ (ls widthFor: usableWidth) min: usableWidth.
		l _ (usableWidth - w) * ls minorDirectionPadding + xSep + boundsLeft.
		r _ l + w.
		"Set bounds and adjust major direction for next step"
		m bounds: (l rounded @ t rounded corner: r rounded @ b rounded).
		h > 0 ifTrue: [
			t _ b + ySep min: boundsBottom ]]! !
!PasteUpMorph methodsFor: 'initialization' stamp: 'jmv 4/20/2012 14:49' prior: 16911793!
                        becomeActiveDuring: aBlock
	"Make the receiver the ActiveWorld during the evaluation of aBlock.
	Note that this method does deliberately *not* use #ensure: to prevent
	re-installation of the world on project switches."
	| priorWorld priorHand |
	priorWorld _ ActiveWorld.
	priorHand _ ActiveHand.
	ActiveWorld _ self.
	ActiveHand _ self hands first. "default"
	aBlock
		on: Error
		do: [:ex | 
			ActiveWorld _ priorWorld.
			ActiveHand _ priorHand.
			ex pass]! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 4/20/2012 14:50' prior: 16912464!
                         install
	owner := nil.	"since we may have been inside another world previously"
	ActiveWorld := self.
	ActiveHand := self hands first.	"default"
	submorphs do: [:ss | ss owner ifNil: [ss privateOwner: self]].
	"Transcript that was in outPointers and then got deleted."
	self viewBox: Display boundingBox.
	Sensor flushAllButDandDEvents.
	worldState handsDo: [:h | h initForEvents].
	self borderWidth: 0.	"default"
	SystemWindow noteTopWindowIn: self.
	self displayWorldSafely! !
!ProjectX class methodsFor: 'as yet unclassified' stamp: 'jmv 4/20/2012 14:50' prior: 16923664!
 interruptNameX: labelString
	"Create a Notifier on the active scheduling process with the given label."
	| preemptedProcess projectProcess |
	
	ActiveHand ifNotNil:[ActiveHand interrupted].
	ActiveWorld _ World. "reinstall active globals"
	ActiveHand _ World activeHand.
	ActiveHand interrupted. "make sure this one's interrupted too"

	projectProcess _ ProjectX uiProcessX.	"we still need the accessor for a while"
	preemptedProcess _ Processor preemptedProcess.
	"Only debug preempted process if its priority is >= projectProcess' priority"
	preemptedProcess priority < projectProcess priority ifTrue:[
		projectProcess suspend.
		preemptedProcess _ projectProcess.
	] ifFalse:[
		preemptedProcess suspend.
	].
	Debugger openInterrupt: labelString onProcess: preemptedProcess
! !

Morph removeSelector: #dismissMorph:!

Morph removeSelector: #dismissMorph:!

Morph removeSelector: #resizeMorph:!

Morph removeSelector: #resizeMorph:!

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1307-KillActiveEvent-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #4219] on 11 May 2012 at 3:17:29 pm'!
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 4/27/2012 16:38' prior: 50368382!
        bringWindowsFullOnscreen
	"Make ever SystemWindow on the desktop be totally on-screen, whenever possible."
	
	(SystemWindow windowsIn: self satisfying: [:w | true]) do: [ :each |
		each makeMeFullyVisible ]! !

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1308-CuisCore-JuanVuletich-2012May11-15h11m-jmv.1.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #4220] on 15 May 2012 at 6:04:54 pm'!
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/15/2012 16:50' prior: 50367597!
     placeEmbeddedObject: anchoredFormOrMorph
	"Place the anchoredMorph or return false if it cannot be placed.
	In any event, advance destX by its width."

	| w |
	w _ (anchoredFormOrMorph is: #Morph)
		ifTrue: [ anchoredFormOrMorph morphWidth ]
		ifFalse: [ anchoredFormOrMorph width ].
	destX _ destX + w.
	(destX > rightMargin and: [ lastIndex ~= line first ])
		"Won't fit, but  not at start of a line. Start a new line with it"
		ifTrue: [ ^ false].
	lastIndex _ lastIndex + 1.
	^ true! !
!CharacterBlockScanner methodsFor: 'scanning' stamp: 'jmv 5/15/2012 16:52' prior: 50367612!
                          placeEmbeddedObject: anchoredFormOrMorph

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	specialWidth _ (anchoredFormOrMorph is: #Morph)
		ifTrue: [ anchoredFormOrMorph morphWidth ]
		ifFalse: [ anchoredFormOrMorph width ].
	^ true! !
!CompositionScanner methodsFor: 'stop conditions' stamp: 'jmv 5/15/2012 16:51' prior: 50367621!
                             placeEmbeddedObject: anchoredFormOrMorph
	| descent h |

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [
		line stop: lastIndex-1.
		^ false].
	descent _ lineHeight - baseline.
	h _ (anchoredFormOrMorph is: #Morph)
		ifTrue: [ anchoredFormOrMorph morphHeight ]
		ifFalse: [ anchoredFormOrMorph height ].
	baseline _ baseline max: h.
	lineHeight _ baseline + descent.
	line stop: lastIndex.
	^ true! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 5/15/2012 16:39' prior: 16880599!
          example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane _ LayoutMorph newRow separation: 5. "1"
pane color: Color lightGreen; bounds: (120 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '1').

rect1 := RectangleMorph new color: (Color lightOrange); 
	morphWidth: 20; morphHeight: 30.
pane addMorph: rect1.
rect2 := RectangleMorph new color: (Color cyan); 
	morphWidth: 20; morphHeight: 30.
pane addMorph: rect2.
pane openInWorld.


pane _ LayoutMorph newRow separation: 5. "2"
pane color: Color lightGreen; bounds: (320 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '2').

rect1 := RectangleMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect1.
rect2 := RectangleMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane openInWorld.


pane _ LayoutMorph newRow separation: 5. "3"
pane color: Color lightGreen; bounds: (520 @ 50 extent: 180 @ 100).
pane addMorph: (StringMorph contents: '3').

rect1 := RectangleMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
rect2 := RectangleMorph new color: (Color cyan);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect2.
pane openInWorld.! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 5/15/2012 17:49' prior: 16880657!
                             testLayout1
	"
	self new testLayout1
	"
	| pane row1 row2 row3 r1c1 r1c2 r1c3 r1c4 r1c5 r2c1 r2c2 r2c3 r3c1 r3c2 r3c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row1 _ LayoutMorph newRow separation: 5.
	row1 color: Color red;
		addMorph: (r1c1 _ RectangleMorph new color: (Color h: 60 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 10);
		addMorph: (r1c2 _ RectangleMorph new color: Color blue)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8);
		addMorph: (r1c3 _ RectangleMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.4);
		addMorph: (r1c4 _ RectangleMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.15);
		addMorph: (r1c5 _ RectangleMorph new color: (Color h: 60 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
	pane addMorph: row1 layoutSpec: LayoutSpec useAll.
	row2 _ LayoutMorph newRow separation: 5.
	row2 color: Color red;
		addMorph: (r2c1 _ RectangleMorph new color: Color blue)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8);
		addMorph: (r2c2 _ RectangleMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.4);
		addMorph: (r2c3 _ RectangleMorph new color: (Color h: 30 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.2).
	pane addMorph: row2 layoutSpec: LayoutSpec useAll.
	row3 _ LayoutMorph newRow separation: 5.
	row3 color: Color red;
		addMorph: (r3c1 _ RectangleMorph new color: (Color h: 120 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
		addMorph: (r3c2 _ RectangleMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40);
		addMorph: (r3c3 _ RectangleMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row3 layoutSpec: (LayoutSpec fixedHeight: 60).
	pane openInWorld; morphExtent: 408@300.
	World doOneCycleNow.

	self assert: row1 morphWidth = (pane morphWidth - 10).
	self assert: r1c1 morphWidth class == SmallInteger.
	self assert: r1c1 morphHeight class == SmallInteger.
	self assert: r1c1 morphWidth = 10.
	self assert: r1c1 morphHeight = (row1 morphHeight - 10).
	self assert: r1c2 morphWidth = 200.
	self assert: r1c2 morphHeight = (row1 morphHeight - 10).
	self assert: r1c3 morphWidth = (r1c2 morphWidth / 0.8 * 0.4) rounded.
	self assert: r1c3 morphHeight = (row1 morphHeight - 10).
	self assert: r1c4 morphWidth = (r1c2 morphWidth / 0.8 * 0.15) rounded.
	self assert: r1c4 morphHeight = (row1 morphHeight - 10).
	self assert: r1c5 morphWidth = 20.
	self assert: r1c5 morphHeight = 20.

	self assert: row2 morphWidth = (pane morphWidth - 10).
	self assert: r2c1 morphWidth = 216.
	self assert: r2c1 morphHeight = (row2 morphHeight - 10).
	self assert: r2c2 morphWidth = (r2c1 morphWidth / 0.8 * 0.4) rounded.
	self assert: r2c2 morphHeight = (row2 morphHeight - 10).
	self assert: r2c3 morphWidth = (r2c1 morphWidth / 0.8 * 0.2) rounded.
	self assert: r2c3 morphHeight = (row2 morphHeight - 10).

	self assert: row3 morphWidth = (pane morphWidth - 10).
	self assert: row3 morphHeight = 60.
	self assert: r3c1 morphWidth = 20.
	self assert: r3c1 morphHeight = (row3 morphHeight - 10 * 0.8) rounded.
	self assert: r3c2 morphWidth = (row3 morphWidth - 10 - 20 - 10 - 30 * 0.5) rounded.
	self assert: r3c2 morphHeight = 40.
	self assert: r3c3 morphWidth = 30.
	self assert: r3c3 morphHeight = (row3 morphHeight - 10).

	pane delete! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 5/15/2012 17:47' prior: 16880764!
    testLayout2
	"
	self new testLayout2
	"
	| pane row c1 c2 c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (c1 _ RectangleMorph new color: (Color h: 120 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8 minorDirectionPadding: #bottom);
		addMorph: (c2 _ RectangleMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (c3 _ RectangleMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 0.7 minorDirectionPadding: #center).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane openInWorld; morphExtent: 400@300.
	World doOneCycleNow.

	self assert: row morphWidth = (pane morphWidth - 10).
	self assert: row morphHeight = (pane morphHeight - 10 * 0.9) rounded.
	self assert: c1 bounds bottom = (row bounds bottom - 5) description: 'Should be at bottom'.
	self assert: c1 morphWidth = 20.
	self assert: c1 morphHeight = (row morphHeight - 10 * 0.8) rounded.
	self assert: c2 bounds top = (row bounds top + 5) description: 'Should be at top'.
	self assert: c2 morphWidth = 256.
	self assert: c2 morphHeight = 40.
	self assert: ((c3 bounds top - row bounds top) - (row bounds bottom - c3 bounds bottom)) abs < 2 description: 'Should be centered'.
	self assert: c3 morphWidth = 30.
	self assert: c3 morphHeight = (c1 morphHeight / 0.8 * 0.7) rounded.

	pane delete! !
!LayoutMorphTest methodsFor: 'tests' stamp: 'jmv 5/15/2012 17:45' prior: 16880814!
                  testLayout3
	"
	self new testLayout3
	"
	| pane row innerRow i1 i2 i3 c2 c3 |
	pane _ LayoutMorph newColumn separation: 5.
	pane color: Color red.
	row _ LayoutMorph newRow separation: 5.
	innerRow _ LayoutMorph newRow color: Color red;  separation: 5.
	innerRow
		addMorph: (i1 _ RectangleMorph new  borderWidth: 0)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (i2 _ RectangleMorph new  borderWidth: 0)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (i3 _ RectangleMorph new  borderWidth: 0)
			layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 minorDirectionPadding: #center);
		addMorph: (c2 _ RectangleMorph new color: (Color h: 90 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (c3 _ RectangleMorph new color: (Color h: 150 s: 0.6 v: 0.6))
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 200).
	pane openInWorld; morphExtent: 400@300.
	World doOneCycleNow.

	self assert: row bounds left = (pane bounds left + 5).
	self assert: row morphWidth = (pane morphWidth - 10).
	self assert: row morphHeight = 200.
	self assert: innerRow bounds left = (row bounds left + 5).
	self assert: (innerRow bounds top - row bounds top) = (row bounds bottom - innerRow bounds bottom) description: 'Should be centered'.
	self assert: innerRow morphWidth = (pane morphWidth - 10 - 10 - 30 - 10 * 0.5) rounded.
	self assert: innerRow morphHeight = 30.

	self assert: i1 bounds left = (innerRow bounds left + 5).
	self assert: (i1 bounds top - innerRow bounds top) = (innerRow bounds bottom - i1 bounds bottom) description: 'Should be centered'.
	self assert: i1 morphWidth = 10.
	self assert: i1 morphHeight = 10.
	self assert: i2 bounds left = (innerRow bounds left + 20).
	self assert: (i2 bounds top - innerRow bounds top) = (innerRow bounds bottom - i2 bounds bottom) description: 'Should be centered'.
	self assert: i2 morphWidth = 10.
	self assert: i2 morphHeight = 10.
	self assert: i3 bounds left = (innerRow bounds left + 35).
	self assert: (i3 bounds top - innerRow bounds top) = (innerRow bounds bottom - i3 bounds bottom) description: 'Should be centered'.
	self assert: i3 morphWidth = (innerRow morphWidth - 40).
	self assert: i3 morphHeight = 10.

	self assert: c2 bounds top = (row bounds top + 5) description: 'Should be at top'.
	self assert: c2 morphWidth = (pane morphWidth - 10 - 10 - 30 - 10 * 0.5) rounded.
	self assert: c2 morphHeight = 40.
	self assert: (c3 bounds top - row bounds top) = (row bounds bottom - c3 bounds bottom) description: 'Should be centered'.
	self assert: c3 morphWidth = 30.
	self assert: c3 morphHeight = (row morphHeight - 10).

	pane delete! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 5/15/2012 16:54' prior: 50369156!
                         placeEmbeddedObject: anchoredFormOrMorph

	(super placeEmbeddedObject: anchoredFormOrMorph) ifFalse: [^ false].
	(anchoredFormOrMorph is: #Morph)
		ifTrue: [
			anchoredFormOrMorph morphPosition:
				((destX - anchoredFormOrMorph morphWidth)@
				(lineY+ line baseline - anchoredFormOrMorph morphHeight)) -
					paraTopLeft ]
		ifFalse: [
			destY _ lineY.
			runX _ destX.
			anchoredFormOrMorph 
				displayOn: canvas grafPort destForm 
				at: destX - anchoredFormOrMorph width @ (destY + line baseline - anchoredFormOrMorph height)
				clippingBox: canvas grafPort clipRect
				rule: Form blend
				fillColor: nil ].
	^ true! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 5/15/2012 17:09' prior: 50372840!
                      initializeDownButton
	"initialize the receiver's downButton"

	| e |
	e _ self buttonExtent.
	downButton _ self buttonClass new.
	downButton model: self.
	self addMorph: downButton.
	downButton
		morphPositionInOwner: self morphExtent - borderWidth - e;
		morphExtent: e@e.
	self isHorizontal
		ifTrue: [ downButton updateRightButtonImage ]
		ifFalse: [ downButton updateDownButtonImage ]! !
!ScrollBar methodsFor: 'initialize' stamp: 'jmv 5/15/2012 17:09' prior: 50372870!
      initializeUpButton
	"initialize the receiver's upButton"

	| e |
	e _ self buttonExtent.
	upButton _ self buttonClass new.
	upButton model: self.
	self addMorph: upButton.
	upButton
		morphPositionInOwner: borderWidth@borderWidth;
		morphExtent: e@e.
	self isHorizontal
		ifTrue: [ upButton updateLeftButtonImage ]
		ifFalse: [ upButton updateUpButtonImage ].! !
!TaskbarTest methodsFor: 'test cases' stamp: 'jmv 5/15/2012 17:41' prior: 16967428!
 testHeight
	
	self should: [ taskbar morphHeight = 18 ]! !
!TaskbarTest methodsFor: 'test cases' stamp: 'jmv 5/15/2012 17:41' prior: 16967461!
                 testWidth
	
	self should: [ taskbar morphWidth = World morphWidth ]! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

SystemWindow allSubInstancesDo: [ :each | each delete ].
TranscriptWindow openTranscript.
Transcript clear!

----End fileIn of /Volumes/CANON_DC/Cuis/CambiosParaIrAMorphic3/1309-CuisCore-JuanVuletich-2012May15-16h29m-jmv.9.cs----!
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 22:02' prior: 50368815!
                          createAcceptButton
	"create the [accept] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current acceptButton;
		 label: 'Accept';
		 action: #acceptClicked.
	self addMorph: result.
	result bounds: (29@90 corner: 122@117).
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 5/23/2012 22:03' prior: 50368833!
             createCancelButton
	"create the [cancel] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current cancelButton;
		 label: 'Cancel';
		 action: #cancelClicked.
	self addMorph: result.
	result bounds: (149@90 corner: 242@117).
	^ result! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/23/2012 22:04' prior: 50363616!
                  drawRegularLabelOn: aCanvas

	| w f center x y  availableW l labelMargin |

	f _ self fontToUse.
	center _ bounds center.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ bounds width-labelMargin-labelMargin-1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ bounds left + labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			in: (x@y extent: extent - (labelMargin*2-2@4))
			font: f
			color: Theme current buttonLabel ]! !

----QUIT/NOSAVE----#(23 May 2012 10:05:44 pm) Cuis4.0-1289.image priorSource: 1047615!

----STARTUP----#(25 May 2012 11:26:14 am) as /Volumes/CANON_DC/Cuis/Cuis4.0-1289.image!


'From Cuis 4.0 of 21 April 2012 [latest update: #1289] on 23 May 2012 at 10:26:51 pm'!
!BlueTheme methodsFor: 'colors' stamp: 'DSG 5/23/2012 22:19' prior: 16792894!
                      shout
	"Color symbols as an association list."
	
	^ {
		#defaults 							-> #white.
		#undefined 						-> #(orange lighter).
		#methodTags 					-> #(green lighter).
		#pseudoVariables 			-> #(red veryMuchLighter).
		#messages 						-> #(cyan).
		#arguments 				-> #white.
		#instVar 							-> #(magenta muchDarker).
		#incompleteMessages 	-> #(gray veryMuchDarker).
		#blockLevelFour 				-> #(green darker).
		#blockLevelFive 				-> #(red darker).
		#blockLevelSix 				-> #(magenta darker).
		#blockLevelSeven 			-> #blue.
		#tempBar 							-> #gray.
		#tempVars 						-> #(gray quiteWhiter).
	}! !
!HighContrastBlackTheme methodsFor: 'colors' stamp: 'DSG 5/23/2012 22:16' prior: 16867255!
              shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #white.
		#undefined 				-> #cyan.
		#methodTags 			-> #(magenta darker).
		#pseudoVariables 		-> #(cyan darker).
		#messages 				-> #(yellow darker).
		#arguments 				-> #(white darker).
		#instVar 					-> #(green darker).
		#incompleteMessages -> #gray.
		#blockLevelFour 		-> #(magenta).
		#blockLevelFive 		-> #(orange negated).
		#blockLevelSix 			-> #(green).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #(gray veryMuchLighter lighter).
		#tempVars 				-> #(gray muchLighter).
	}! !

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates/1290-CuisCore-DavidGraham-2012May23-22h16m-DSG.2.cs----!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/25/2012 11:33'!
               knownInitialsAndNames
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk contributorInitialsAndNames collect: [ :pair | pair first ]) asSet.
self assert: all = ok

initials         name"
^ #(
	#('ab' 					'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 					'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 					'Andreas Raab')
	#('asm' 				'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('bf' 					'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 				'Bolot Kerimbaev')
	#('bp' 					'Bernhard Pieber')
	#('BP' 					'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'					'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 				'Chris Muller')
	#('crl' 					'Craig Latta')
	#('cwp' 				'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 					'Damien Cassou')
	#('dew' 				'Doug Way')
	#('dgd' 				'Diego Gomez Deck')
	#('dhhi' 				'Dan Ingalls')
	#('di' 					'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DSM' 				'Duane Maxwell')
	#('dtl' 					'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 				'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 					'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 	'Fernando Olivero')
	#('FernanodOlivero' 	'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gh' 					'Goran Krampe (nee Hultgren)')
	#('gk' 					'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 					'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('hmm' 				'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 					'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 					'Joern Eyrich')
	#('jf' 					'Julian Fitzell')
	#('JF' 					'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jlb' 					'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 				'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 					'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 				'Kurt Thams')
	#('laza' 				'Alexander Lazarevic')
	#('LC' 					'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lr' 					'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 					'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 				'Mike Rutenberg')
	#('mga' 				'Markus Galli')
	#('mha' 				'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 				'Michael Hewner')
	#('mpw' 				'Marcel Weiher')
	#('MPW' 				'Marcel Weiher')
	#('mrm' 				'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 					'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 					'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 					'Nathanael Schaerli')
	#('panda' 				'Michael Rueger')
	#('PHK' 				'Peter Keeler')
	#('Pmm' 				'Philippe Marschall')
	#('pnm' 				'Paul McDonough')
	#('r++' 				'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 				'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 					'Robert Hirschfeld')
	#('rr' 					'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 					'Robert Withers')
	#('rww' 				'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 				'Stephan B. Wessels')
	#('sd' 					'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 				'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sr' 					'Stephan Rudlof')
	#('SSS' 				'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 				'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 					'Torge Husfeldt')
	#('tk' 					'Ted Kaehler')
	#('tlk' 					'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 					'Levente Uzonyi')
	#('vb' 					'Vassili Bykov')
	#('ward' 				'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 				'Bill Dargel')
	#('yo' 					'Yoshiki Ohshima')
	#('zz' 					'Serge Stinckwich'))! !
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/25/2012 11:34' prior: 50358557!
   unknownContributors
	"Answer a collection of authorInitials for whom there is code in the system 
	(either in core or in loaded packages), but we don't knwo their full name.
	Smalltalk unknownContributors
	"

	| all ok |
	all _ Smalltalk allContributors asSet.
	ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
	^(all difference: ok) asArray sort! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/25/2012 11:34' prior: 50357638!
         setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	AuthorInitials _ (FillInTheBlank
		request: 'Please type your initials: '
		initialAnswer: AuthorInitials) withBlanksTrimmed.
	authorName _ (Smalltalk knownInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ (FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name') withBlanksTrimmed.
			^ self ]) second withBlanksTrimmed.
	(self confirm: 'Are you ' , authorName , '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [
			self inform: 'Please enter different initials, then'.
			self setAuthor ]! !

SystemDictionary removeSelector: #contributorInitialsAndNames!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/25/2012 11:34' prior: 50373762!
            knownInitialsAndNames
	"This list could include people who hasn't contributed code too"
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk contributorInitialsAndNames collect: [ :pair | pair first ]) asSet.
self assert: all = ok

initials         name"
^ #(
	#('ab' 					'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 					'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 					'Andreas Raab')
	#('asm' 				'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('bf' 					'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 				'Bolot Kerimbaev')
	#('bp' 					'Bernhard Pieber')
	#('BP' 					'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'					'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 				'Chris Muller')
	#('crl' 					'Craig Latta')
	#('cwp' 				'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 					'Damien Cassou')
	#('dew' 				'Doug Way')
	#('dgd' 				'Diego Gomez Deck')
	#('dhhi' 				'Dan Ingalls')
	#('di' 					'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DSM' 				'Duane Maxwell')
	#('dtl' 					'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 				'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 					'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 	'Fernando Olivero')
	#('FernanodOlivero' 	'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gh' 					'Goran Krampe (nee Hultgren)')
	#('gk' 					'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 					'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('hmm' 				'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 					'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 					'Joern Eyrich')
	#('jf' 					'Julian Fitzell')
	#('JF' 					'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jlb' 					'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 				'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 					'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 				'Kurt Thams')
	#('laza' 				'Alexander Lazarevic')
	#('LC' 					'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lr' 					'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 					'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 				'Mike Rutenberg')
	#('mga' 				'Markus Galli')
	#('mha' 				'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 				'Michael Hewner')
	#('mpw' 				'Marcel Weiher')
	#('MPW' 				'Marcel Weiher')
	#('mrm' 				'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 					'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 					'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 					'Nathanael Schaerli')
	#('panda' 				'Michael Rueger')
	#('PHK' 				'Peter Keeler')
	#('Pmm' 				'Philippe Marschall')
	#('pnm' 				'Paul McDonough')
	#('r++' 				'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 				'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 					'Robert Hirschfeld')
	#('rr' 					'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 					'Robert Withers')
	#('rww' 				'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 				'Stephan B. Wessels')
	#('sd' 					'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 				'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sr' 					'Stephan Rudlof')
	#('SSS' 				'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 				'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 					'Torge Husfeldt')
	#('tk' 					'Ted Kaehler')
	#('tlk' 					'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 					'Levente Uzonyi')
	#('vb' 					'Vassili Bykov')
	#('ward' 				'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 				'Bill Dargel')
	#('yo' 					'Yoshiki Ohshima')
	#('zz' 					'Serge Stinckwich'))! !
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/25/2012 11:35' prior: 50373971!
 knownInitialsAndNames
	"This list could include people who hasn't contributed code too"
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk contributorInitialsAndNames collect: [ :pair | pair first ]) asSet.
self assert: all = ok

initials         name"
^ #(
	#('ab' 					'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 					'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 					'Andreas Raab')
	#('asm' 				'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('bf' 					'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 				'Bolot Kerimbaev')
	#('bp' 					'Bernhard Pieber')
	#('BP' 					'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'					'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 				'Chris Muller')
	#('crl' 					'Craig Latta')
	#('cwp' 				'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 					'Damien Cassou')
	#('dew' 				'Doug Way')
	#('dgd' 				'Diego Gomez Deck')
	#('dhhi' 				'Dan Ingalls')
	#('di' 					'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DSM' 				'Duane Maxwell')
	#('DSG'					'David Graham')
	#('dtl' 					'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 				'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 					'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 	'Fernando Olivero')
	#('FernanodOlivero' 	'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gh' 					'Goran Krampe (nee Hultgren)')
	#('gk' 					'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 					'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('hmm' 				'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 					'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 					'Joern Eyrich')
	#('jf' 					'Julian Fitzell')
	#('JF' 					'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jlb' 					'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 				'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 					'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 				'Kurt Thams')
	#('laza' 				'Alexander Lazarevic')
	#('LC' 					'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lr' 					'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 					'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 				'Mike Rutenberg')
	#('mga' 				'Markus Galli')
	#('mha' 				'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 				'Michael Hewner')
	#('mpw' 				'Marcel Weiher')
	#('MPW' 				'Marcel Weiher')
	#('mrm' 				'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 					'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 					'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 					'Nathanael Schaerli')
	#('panda' 				'Michael Rueger')
	#('PHK' 				'Peter Keeler')
	#('Pmm' 				'Philippe Marschall')
	#('pnm' 				'Paul McDonough')
	#('r++' 				'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 				'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 					'Robert Hirschfeld')
	#('rr' 					'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 					'Robert Withers')
	#('rww' 				'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 				'Stephan B. Wessels')
	#('sd' 					'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 				'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sr' 					'Stephan Rudlof')
	#('SSS' 				'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 				'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 					'Torge Husfeldt')
	#('tk' 					'Ted Kaehler')
	#('tlk' 					'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 					'Levente Uzonyi')
	#('vb' 					'Vassili Bykov')
	#('ward' 				'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 				'Bill Dargel')
	#('yo' 					'Yoshiki Ohshima')
	#('zz' 					'Serge Stinckwich'))! !

	Smalltalk unknownContributors!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/25/2012 11:35' prior: 50374140!
   knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk contributorInitialsAndNames collect: [ :pair | pair first ]) asSet.
self assert: all = ok

initials         name"
^ #(
	#('ab' 					'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 					'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 					'Andreas Raab')
	#('asm' 				'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('bf' 					'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 				'Bolot Kerimbaev')
	#('bp' 					'Bernhard Pieber')
	#('BP' 					'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'					'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 				'Chris Muller')
	#('crl' 					'Craig Latta')
	#('cwp' 				'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 					'Damien Cassou')
	#('dew' 				'Doug Way')
	#('dgd' 				'Diego Gomez Deck')
	#('dhhi' 				'Dan Ingalls')
	#('di' 					'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DSM' 				'Duane Maxwell')
	#('DSG'					'David Graham')
	#('dtl' 					'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 				'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 					'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 	'Fernando Olivero')
	#('FernanodOlivero' 	'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gh' 					'Goran Krampe (nee Hultgren)')
	#('gk' 					'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 					'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('hmm' 				'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 					'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 					'Joern Eyrich')
	#('jf' 					'Julian Fitzell')
	#('JF' 					'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jlb' 					'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 				'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 					'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 				'Kurt Thams')
	#('laza' 				'Alexander Lazarevic')
	#('LC' 					'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lr' 					'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 					'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 				'Mike Rutenberg')
	#('mga' 				'Markus Galli')
	#('mha' 				'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 				'Michael Hewner')
	#('mpw' 				'Marcel Weiher')
	#('MPW' 				'Marcel Weiher')
	#('mrm' 				'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 					'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 					'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 					'Nathanael Schaerli')
	#('panda' 				'Michael Rueger')
	#('PHK' 				'Peter Keeler')
	#('Pmm' 				'Philippe Marschall')
	#('pnm' 				'Paul McDonough')
	#('r++' 				'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 				'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 					'Robert Hirschfeld')
	#('rr' 					'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 					'Robert Withers')
	#('rww' 				'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 				'Stephan B. Wessels')
	#('sd' 					'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 				'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sr' 					'Stephan Rudlof')
	#('SSS' 				'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 				'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 					'Torge Husfeldt')
	#('tk' 					'Ted Kaehler')
	#('tlk' 					'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 					'Levente Uzonyi')
	#('vb' 					'Vassili Bykov')
	#('ward' 				'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 				'Bill Dargel')
	#('yo' 					'Yoshiki Ohshima')
	#('zz' 					'Serge Stinckwich'))! !

----QUIT/NOSAVE----#(25 May 2012 11:42:30 am) Cuis4.0-1289.image priorSource: 1047615!

----STARTUP----#(25 May 2012 11:42:44 am) as /Volumes/CANON_DC/Cuis/Cuis4.0-1289.image!


'From Cuis 4.0 of 21 April 2012 [latest update: #1289] on 23 May 2012 at 10:26:51 pm'!
!BlueTheme methodsFor: 'colors' stamp: 'DSG 5/23/2012 22:19' prior: 16792894!
                             shout
	"Color symbols as an association list."
	
	^ {
		#defaults 							-> #white.
		#undefined 						-> #(orange lighter).
		#methodTags 					-> #(green lighter).
		#pseudoVariables 			-> #(red veryMuchLighter).
		#messages 						-> #(cyan).
		#arguments 				-> #white.
		#instVar 							-> #(magenta muchDarker).
		#incompleteMessages 	-> #(gray veryMuchDarker).
		#blockLevelFour 				-> #(green darker).
		#blockLevelFive 				-> #(red darker).
		#blockLevelSix 				-> #(magenta darker).
		#blockLevelSeven 			-> #blue.
		#tempBar 							-> #gray.
		#tempVars 						-> #(gray quiteWhiter).
	}! !
!HighContrastBlackTheme methodsFor: 'colors' stamp: 'DSG 5/23/2012 22:16' prior: 16867255!
              shout
	"Color symbols as an association list."
	
	^ {
		#defaults 				-> #white.
		#undefined 				-> #cyan.
		#methodTags 			-> #(magenta darker).
		#pseudoVariables 		-> #(cyan darker).
		#messages 				-> #(yellow darker).
		#arguments 				-> #(white darker).
		#instVar 					-> #(green darker).
		#incompleteMessages -> #gray.
		#blockLevelFour 		-> #(magenta).
		#blockLevelFive 		-> #(orange negated).
		#blockLevelSix 			-> #(green).
		#blockLevelSeven 		-> #blue.
		#tempBar 				-> #(gray veryMuchLighter lighter).
		#tempVars 				-> #(gray muchLighter).
	}! !

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates/1290-CuisCore-DavidGraham-2012May23-22h16m-DSG.2.cs----!

'From Cuis 4.0 of 21 April 2012 [latest update: #1290] on 25 May 2012 at 11:40:36 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/25/2012 11:35'!
                       knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk contributorInitialsAndNames collect: [ :pair | pair first ]) asSet.
self assert: all = ok

initials         name"
^ #(
	#('ab' 					'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 					'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 					'Andreas Raab')
	#('asm' 				'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('bf' 					'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 				'Bolot Kerimbaev')
	#('bp' 					'Bernhard Pieber')
	#('BP' 					'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'					'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 				'Chris Muller')
	#('crl' 					'Craig Latta')
	#('cwp' 				'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 					'Damien Cassou')
	#('dew' 				'Doug Way')
	#('dgd' 				'Diego Gomez Deck')
	#('dhhi' 				'Dan Ingalls')
	#('di' 					'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DSM' 				'Duane Maxwell')
	#('DSG'					'David Graham')
	#('dtl' 					'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 				'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 					'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 	'Fernando Olivero')
	#('FernanodOlivero' 	'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gh' 					'Goran Krampe (nee Hultgren)')
	#('gk' 					'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 					'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('hmm' 				'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 					'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 					'Joern Eyrich')
	#('jf' 					'Julian Fitzell')
	#('JF' 					'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jlb' 					'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 				'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 					'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 				'Kurt Thams')
	#('laza' 				'Alexander Lazarevic')
	#('LC' 					'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lr' 					'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 					'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 				'Mike Rutenberg')
	#('mga' 				'Markus Galli')
	#('mha' 				'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 				'Michael Hewner')
	#('mpw' 				'Marcel Weiher')
	#('MPW' 				'Marcel Weiher')
	#('mrm' 				'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 					'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 					'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 					'Nathanael Schaerli')
	#('panda' 				'Michael Rueger')
	#('PHK' 				'Peter Keeler')
	#('Pmm' 				'Philippe Marschall')
	#('pnm' 				'Paul McDonough')
	#('r++' 				'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 				'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 					'Robert Hirschfeld')
	#('rr' 					'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 					'Robert Withers')
	#('rww' 				'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 				'Stephan B. Wessels')
	#('sd' 					'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 				'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sr' 					'Stephan Rudlof')
	#('SSS' 				'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 				'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 					'Torge Husfeldt')
	#('tk' 					'Ted Kaehler')
	#('tlk' 					'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 					'Levente Uzonyi')
	#('vb' 					'Vassili Bykov')
	#('ward' 				'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 				'Bill Dargel')
	#('yo' 					'Yoshiki Ohshima')
	#('zz' 					'Serge Stinckwich'))! !
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/25/2012 11:34' prior: 50358557!
                          unknownContributors
	"Answer a collection of authorInitials for whom there is code in the system 
	(either in core or in loaded packages), but we don't knwo their full name.
	Smalltalk unknownContributors
	"

	| all ok |
	all _ Smalltalk allContributors asSet.
	ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
	^(all difference: ok) asArray sort! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 5/25/2012 11:34' prior: 50357638!
         setAuthor
	"Put up a dialog allowing the user to specify the author's initials.
	Utilities setAuthor
	"
	| authorName |
	AuthorInitials _ (FillInTheBlank
		request: 'Please type your initials: '
		initialAnswer: AuthorInitials) withBlanksTrimmed.
	authorName _ (Smalltalk knownInitialsAndNames
		detect: [ :pair |
			pair first = AuthorInitials ]
		ifNone: [
			AuthorName _ (FillInTheBlank
				request: 'Please type your name:'
				initialAnswer: 'Your Name') withBlanksTrimmed.
			^ self ]) second withBlanksTrimmed.
	(self confirm: 'Are you ' , authorName , '?')
		ifTrue: [ AuthorName _ authorName ]
		ifFalse: [
			self inform: 'Please enter different initials, then'.
			self setAuthor ]! !

SystemDictionary removeSelector: #contributorInitialsAndNames!

SystemDictionary removeSelector: #contributorInitialsAndNames!

----End fileIn of /Volumes/CANON_DC/Cuis/CuisUpdates/1291-AuthorInitialsTweaks-JuanVuletich-2012May25-11h33m-jmv.1.cs----!

----SNAPSHOT----#(25 May 2012 11:43:05 am) Cuis4.0-1291.image priorSource: 1047615!

----QUIT/NOSAVE----#(25 May 2012 11:43:11 am) Cuis4.0-1291.image priorSource: 1379476!